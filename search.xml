<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Vue动态切换页签缓存页面内容</title>
    <url>/Vue%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E9%A1%B5%E7%AD%BE%E7%BC%93%E5%AD%98%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9.html</url>
    <content><![CDATA[<p>之前在上家公司自己建系统的时候出现过切换页签，但切换后上个页面的内容没有被缓存，而是重新渲染了。</p>
<p>正好学习Vue3时看到了解决方法。</p>
<p>（之前因为赶工作进度，学习Vue2时没有用心看&lt;–要改正的问题</p>
<p>使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>将切换的组件包裹起来即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件通信</title>
    <url>/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html</url>
    <content><![CDATA[<blockquote>
<p>Vue组件实例的作用域相互独立，不同组件之间的数据无法相互引用</p>
</blockquote>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><blockquote>
<p>参数<code>props</code>用于父组件向子组件传递数据</p>
</blockquote>
<p>父组件调用子组件，在子组件的<code>props</code>写入需要的属性。传递时，在父组件内调用的子组件中直接使用。</p>
<p>可以传入静态的值：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">const app &#x3D; Vue.createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;title&#39;],</span><br><span class="line">  template: &#96;&lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h4&gt;&#96;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(&#39;#blog-post-demo&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;blog-post title&#x3D;&quot;My journey with Vue&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br></pre></td></tr></table></figure>


<p>也可以通过<code>v-bind</code>或简写<code>:</code>动态赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;blog-post :title&#x3D;&quot;post.title&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;blog-post :title&#x3D;&quot;post.title + &#39;by&#39; + post.author.name &quot;&gt;&lt;&#x2F;blog-post&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除传递静态string值外，传入数据、布尔值、数组、对象等，即使传递静态数据也要使用<code>v-bind</code>告诉Vue。即<code>&lt;blog-post :like=&quot;42&quot;&gt;&lt;/blog-post&gt;</code></p>
</blockquote>
<p>所有props均为单项数据流，即父级prop的更新会向下流动到子组件，无法由子组件传递给父组件。</p>
<h3 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h3><blockquote>
<p>emit用于子组件向父组件传递数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&#x2F;&#x2F;需要子组件提供postFontSize的值更新字体大小</span><br><span class="line">&lt;div :style&#x3D;&quot;&#123;fontSize: postFontSize + &#39;em&#39;&#125;&quot;&gt;</span><br><span class="line">    &lt;!--父组件通过@&#x2F;v-on监听子组件实例的enlarge-text事件将字体大小增大0.1，当子组件事件触发，则父组件通过此监听器接收到事件并更新需要的postFontSize值--&gt;</span><br><span class="line">    &lt;blog-post</span><br><span class="line">        v-for&#x3D;&quot;post in posts&quot;</span><br><span class="line">        :key &#x3D; &quot;post.id&quot;</span><br><span class="line">        :title&#x3D;&quot;post.title&quot;</span><br><span class="line">        @enlarge-text&#x3D;&quot;postFontSize +&#x3D; 0.1&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;&#x2F;blog-post&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">app.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;title&#39;],</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div class&#x3D;&quot;blog-post&quot;&gt;</span><br><span class="line">      &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;!--子组件通过调用$emit方法传入事件名称enlargeText来触发事件--&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;$emit(&#39;enlargeText&#39;)&quot;&gt;</span><br><span class="line">        Enlarge text</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>$emit:</p>
<pre><code>参数：{string}```eventName```, ```[...args]```

触发当前实例上的事件```eventName```，附加参数```args```会传给监听器回调</code></pre><h3 id="使用事件监听子组件"><a href="#使用事件监听子组件" class="headerlink" title="使用事件监听子组件"></a>使用事件监听子组件</h3><blockquote>
<p>使用<code>$emit</code>的附加参数提供特定的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">&lt;button @click&#x3D;&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&#x2F;&#x2F;通过$event访问被抛出的附加参数</span><br><span class="line">&lt;blog-post ... @enlarge-text&#x3D;&quot;postFontSize +&#x3D; $event&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若事件处理函数是一个方法，则此抛出的附加参数会作为方法的第一个参数传入</span><br><span class="line">&lt;blog-post ... @enlarge-text&#x3D;&quot;onEnlargeText&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  onEnlargeText(enlargeAmount) &#123;</span><br><span class="line">    this.postFontSize +&#x3D; enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h3 id="provide-amp-amp-inject"><a href="#provide-amp-amp-inject" class="headerlink" title="provide&amp;&amp;inject"></a>provide&amp;&amp;inject</h3>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue事件处理修饰符</title>
    <url>/Vue%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E4%BF%AE%E9%A5%B0%E7%AC%A6.html</url>
    <content><![CDATA[<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><blockquote>
<p>在事件处理程序中调用<code>event.preventDefault()</code>或<code>event.stopPropagation()</code>是非常常见的需求。因此推荐使用事件修饰符处理。尽管可以在方法中实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理<code>DOM</code>事件细节。</p>
</blockquote>
<p>修饰符是由点开头的指令后缀来表示的。使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a @click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form @submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a @click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form @submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div @click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div @click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a @click.once&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发--&gt;</span><br><span class="line">&lt;!-- 而不会等待 &#96;onScroll&#96; 完成--&gt;</span><br><span class="line">&lt;!-- 这其中包含 &#96;event.preventDefault()&#96; 的情况--&gt;</span><br><span class="line">&lt;!-- .passive和.prevent不要一起使用，.prevent会被忽略--&gt;</span><br><span class="line">&lt;div @scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><blockquote>
<p>用于监听键盘事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只有在 &#96;key&#96; 是 &#96;Enter&#96; 时调用 &#96;vm.submit()&#96; --&gt;</span><br><span class="line">&lt;input @keyup.enter&#x3D;&quot;submit&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;input @keyup.page-down&#x3D;&quot;onPageDown&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="按键别名"><a href="#按键别名" class="headerlink" title="按键别名"></a>按键别名</h4><ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete (捕获“删除”和“退格”键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
<h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><blockquote>
<p>实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p>
</blockquote>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Alt + Enter --&gt;</span><br><span class="line">&lt;input @keyup.alt.enter&#x3D;&quot;clear&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Ctrl + Click --&gt;</span><br><span class="line">&lt;div @click.ctrl&#x3D;&quot;doSomething&quot;&gt;Do something&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>.exact</code>修饰符允许控制由精确的系统修饰符组合触发的事件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>鼠标按钮修饰符</p>
</blockquote>
<ul>
<li>.left</li>
<li>.right</li>
<li>.middle</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue条件渲染区分</title>
    <url>/Vue%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%8C%BA%E5%88%86.html</url>
    <content><![CDATA[<ol>
<li><code>v-if</code>在初始渲染时判断条件，若为假，则不进行渲染。只有当条件为真时才开始渲染条件块。确保在切换过程中条件块内的事件监听器和子组件被适当的销毁和重建。</li>
<li><code>v-show</code>无论初始判断条件是真或假，均会进行渲染。即只是切换元素的CSS Property <code>display</code>。</li>
<li><code>v-show</code>不支持<code>&lt;template&gt;</code>和<code>v-else</code></li>
</ol>
<blockquote>
<p>使用<code>v-if</code>有更高的切换开销，若运行时条件很少改变，则选择<code>v-if</code>。<code>v-show</code>有更高的初始开销，若需要频繁的切换，则使用<code>v-show</code>更好。</p>
</blockquote>
<a id="more"></a>

<h3 id="v-if和v-for不要同时用在同一元素上"><a href="#v-if和v-for不要同时用在同一元素上" class="headerlink" title="v-if和v-for不要同时用在同一元素上"></a>v-if和v-for不要同时用在同一元素上</h3><blockquote>
<p>参数<code>v-for</code>的优先级比<code>v-if</code>高</p>
</blockquote>
<ol>
<li><p>过滤列表中的项目，优先将过滤的项目替换为计算属性，使其返回过滤后的列表进行v-for</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">        v-if&#x3D;&quot;user.isActive&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p> 无论列表数据量有多大，筛选后的列表有没有变化，都会在每次重新渲染时遍历整个列表。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;改写后</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in activeUsers&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    activeUsers() &#123;</span><br><span class="line">        return this.users.filter(user &#x3D;&gt; user.isActive)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 改写后，过滤列表只会在筛选后列表发生变化时才会重新计算，过滤更高效。且在<code>v-for</code>遍历时，只会遍历选后的列表，渲染更高效。解耦渲染层的逻辑，可维护性更强。</p>
</li>
<li><p>避免渲染需要被隐藏的列表，将v-if移动到容器元素上。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;改写前</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">        v-if&#x3D;&quot;shouldShowUsers&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;改写后</span><br><span class="line">&lt;ul v-if&#x3D;&quot;shouldShowUsers&quot;&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p> 改写后不需要对列表内每个用户都检查是否应该显示，而只检查一次，且不会<code>v-for</code>不应该显示的用户。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS真值Truthy和假值Falsy</title>
    <url>/JS%E7%9C%9F%E5%80%BCTruthy%E5%92%8C%E5%81%87%E5%80%BCFalsy.html</url>
    <content><![CDATA[<p>假值Falsy：<code>false</code>,<code>0</code>,<code>&quot;&quot;</code>,<code>null</code>,<code>undefined</code>,<code>NaN</code></p>
<p>真值Truthy：除假值外均为真值。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;真值Truthy,以下均会被当作true执行if内的代码</span><br><span class="line">if (true)</span><br><span class="line">if (&#123;&#125;)</span><br><span class="line">if (42)</span><br><span class="line">if (&quot;foo&quot;)</span><br><span class="line">if (new Date())</span><br><span class="line">if (-Infinity)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;假值Falsy，以下均会被当作false跳过if内的代码</span><br><span class="line">if (false)</span><br><span class="line">if (null)</span><br><span class="line">if (undefined)</span><br><span class="line">if (0)</span><br><span class="line">if (0n)</span><br><span class="line">if (NaN)</span><br><span class="line">if (&#39;&#39;)</span><br><span class="line">if (&quot;&quot;)</span><br><span class="line">if (&#96;&#96;)</span><br><span class="line">if (document.all)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue计算属性</title>
    <url>/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7.html</url>
    <content><![CDATA[<blockquote>
<p>不要在模版中放入太多的逻辑。模版最好是简单和声明性的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        book:&#123;</span><br><span class="line">            author: &#39;xxx&#39;,</span><br><span class="line">            borrower: [</span><br><span class="line">                &#39;aaa&#39;,</span><br><span class="line">                &#39;bbb&#39;,</span><br><span class="line">                &#39;ccc&#39;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;This book has been borrowed?&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; book.borrower.length &gt; 0 ? &#39;yes&#39; : &#39;no&#39; &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<blockquote>
<p>对于包含响应式数据的复杂逻辑，应使用计算属性<code>computed</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        book:&#123;</span><br><span class="line">            author: &#39;xxx&#39;,</span><br><span class="line">            borrower: [</span><br><span class="line">                &#39;aaa&#39;,</span><br><span class="line">                &#39;bbb&#39;,</span><br><span class="line">                &#39;ccc&#39;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">    &#x2F;&#x2F;计算属性的getter</span><br><span class="line">    borrowedMessage()&#123;</span><br><span class="line">        &#x2F;&#x2F;this指向vm实例</span><br><span class="line">        return this.book.borrower.length &gt; 0 ? &#39;yes&#39; : &#39;no&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;This book has been borrowed?&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; borrowedMessage &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在表达式中调用方法同样可以达成一样的效果"><a href="#在表达式中调用方法同样可以达成一样的效果" class="headerlink" title="在表达式中调用方法同样可以达成一样的效果"></a>在表达式中调用方法同样可以达成一样的效果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        book:&#123;</span><br><span class="line">            author: &#39;xxx&#39;,</span><br><span class="line">            borrower: [</span><br><span class="line">                &#39;aaa&#39;,</span><br><span class="line">                &#39;bbb&#39;,</span><br><span class="line">                &#39;ccc&#39;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    borrowedMessage()&#123;</span><br><span class="line">        &#x2F;&#x2F;this指向vm实例</span><br><span class="line">        return this.book.borrower.length &gt; 0 ? &#39;yes&#39; : &#39;no&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;This book has been borrowed?&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;!--调用方法--&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; borrowedMessage() &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ol>
<li><p>计算属性基于依赖关系缓存。即<code>vm.borrowedMessage</code>依赖<code>vm.book.borrower</code>。故当<code>vm.book.borrower</code>改变，所有依赖<code>vm.borrowedMessage</code>的绑定都会更新，若<code>vm.book.borrower</code>没有改变，则多次访问<code>vm.borrowedMessage</code>均返回之前的结果，不会再次执行函数。</p>
</li>
<li><p>调用方法不会有缓存，每次触发重新渲染都会再次执行函数。即<code>Date.now()</code>在<code>methods</code>中调用可以每次渲染更新数值，但在<code>computed</code>中则不会被更新。</p>
</li>
</ol>
<blockquote>
<p>若出现性能开销大的计算属性，需要缓存来节省开销则使用<code>computed</code>，若程序不想要缓存，则使用<code>methods</code>替代计算属性</p>
</blockquote>
<h3 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    fullName:&#123;</span><br><span class="line">        &#x2F;&#x2F;getter</span><br><span class="line">        get()&#123;</span><br><span class="line">            return this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;setter</span><br><span class="line">        set(newValue)&#123;</span><br><span class="line">            const names &#x3D; newValue.split(&#39; &#39;)</span><br><span class="line">            this.firstName &#x3D; names[0]</span><br><span class="line">            this.lastName &#x3D; names[names.length - 1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听器watch"><a href="#监听器watch" class="headerlink" title="监听器watch"></a>监听器watch</h3><blockquote>
<p>当需要在数据变化时执行异步操作或者开销比较大的操作时，使用watch监听数据的变化。当数据有变化时才执行下一步操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;template</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;question:&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;question&quot; &#x2F;&gt; </span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;script</span><br><span class="line">watch:&#123;</span><br><span class="line">    question(new,old)&#123;</span><br><span class="line">        if(new.indexOf(&#39;?&#39;)&gt;-1)&#123;</span><br><span class="line">            this.getAnswer()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    getAnswer()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-data及methods</title>
    <url>/vue-data%E5%8F%8Amethods.html</url>
    <content><![CDATA[<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>组件的<code>data</code>是一个<code>函数</code>，调用它返回一个<code>对象</code>，被vue封装后，以<code>$data</code>的形式存储在组件实例中</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        example: [2,3,1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>组件的<code>methods</code>是一个包含方法的<code>对象</code>，自动绑定<code>this</code>，始终指向组件实例。定义时避免使用箭头函数，会影响<code>this</code>的指向</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    exampleFuction()&#123;</span><br><span class="line">        example[2] &#x3D; 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以在组件模版中被访问</span><br><span class="line">&lt;button @click&#x3D;&quot;exampleFuction&quot;&gt;Change example&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue运行单文件</title>
    <url>/vue%E8%BF%90%E8%A1%8C%E5%8D%95%E6%96%87%E4%BB%B6.html</url>
    <content><![CDATA[<ol>
<li><p>安装依赖<code>npm install -g @vue/cli-service-global</code></p>
</li>
<li><p>创建文件<code>xxx.vue</code></p>
</li>
<li><p>在文件目录运行<code>vue serve xxx.vue</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>新坑</title>
    <url>/%E6%96%B0%E5%9D%91.html</url>
    <content><![CDATA[<p>最近打算重写个人网站了，想想可以把之前练手的前端设计的个站、gist网站、还有当前的个站整合在一起，还要加一些作品集展示区。<br>本事一般想法挺大。感觉又要重学一遍了。<br>这周末再怎么犹豫也要把离职提了，做点自己喜欢的吧。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>咕咕咕</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-2D光随鼠标移动转变方向</title>
    <url>/unity-2D%E5%85%89%E9%9A%8F%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%8A%A8%E8%BD%AC%E5%8F%98%E6%96%B9%E5%90%91.html</url>
    <content><![CDATA[<h2 id="2D光随鼠标移动转变方向"><a href="#2D光随鼠标移动转变方向" class="headerlink" title="2D光随鼠标移动转变方向"></a>2D光随鼠标移动转变方向</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Update () &#123;</span><br><span class="line">&#x2F;&#x2F;获取鼠标的坐标，鼠标是屏幕坐标，Z轴为0，这里不做转换  </span><br><span class="line">Vector3 mouse &#x3D; Input.mousePosition;</span><br><span class="line">&#x2F;&#x2F;获取物体坐标，物体坐标是世界坐标，将其转换成屏幕坐标，和鼠标一直  </span><br><span class="line">Vector3 obj &#x3D; Camera.main.WorldToScreenPoint(transform.position);</span><br><span class="line">&#x2F;&#x2F;屏幕坐标向量相减，得到指向鼠标点的目标向量，即黄色线段  </span><br><span class="line">Vector3 direction &#x3D; mouse - obj;</span><br><span class="line">&#x2F;&#x2F;将Z轴置0,保持在2D平面内  </span><br><span class="line">direction.z &#x3D; 0f;</span><br><span class="line">&#x2F;&#x2F;将目标向量长度变成1，即单位向量，这里的目的是只使用向量的方向，不需要长度，所以变成1  </span><br><span class="line">direction &#x3D; direction.normalized;</span><br><span class="line">&#x2F;&#x2F;物体自身的Y轴和目标向量保持一直，这个过程XY轴都会变化数值  </span><br><span class="line">transform.up &#x3D; direction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-法线贴图&amp;BlendTree&amp;特效VFX</title>
    <url>/unity-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE&amp;BlendTree&amp;%E7%89%B9%E6%95%88VFX.html</url>
    <content><![CDATA[<h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><blockquote>
<p>法线贴图：记录了一个需要进行光影变换的贴图上的各个点的凹凸情况的贴图，显示芯片根据贴图的内容来实时生成新的有光影变换的贴图，从而实现立体效果</p>
</blockquote>
<blockquote>
<p>法线贴图不是真正的贴图，故不会直接贴到物体的表面，其作用就是记录每个点上法线的方向。</p>
</blockquote>
<a id="more"></a>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>模型面数越高，可以表现的细节越多，效果越好，但面数多了，顶点数便多了，计算量变大了。为了能用尽可能简单的模型来做出更好的效果，最初提出纹理映射，但它只影响像素阶段输出的颜色值，不能让模型有凹凸的细节，故提出法线贴图解决此问题。</p>
<p>最早在计算时需要逐顶点计算光照，然后每个像素的颜色在各个顶点的颜色之间插值，在此情况下，面数决定一切效果。但在像素着色器出现后，可以通过逐像素来计算光照效果。在计算时，会计算此像素所在面的法向量，此法向量也是由这个面周围的顶点的法线插值得来。当改变法线的方向，则可以改变这个点的光照结果。</p>
<p>在平面的情况下，感觉物体的凹凸很大一部分取决于面的亮度，有了对比，就容易感觉有凹凸。因此通过改变法线来改变面上点的光照条件进而可以让观察者感觉这个面有凹凸</p>
<p><a href="https://imgchr.com/i/sXFc0U" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sXFc0U.png" alt="sXFc0U.png"></a></p>
<h2 id="BlendTree"><a href="#BlendTree" class="headerlink" title="BlendTree"></a>BlendTree</h2><blockquote>
<p>混合树(Blend Tree)按不同程度组合所有动画的各个部分来平滑混合多个动画。即将多个动画融合在一起按条件触发。</p>
</blockquote>
<ol>
<li><code>Animator</code>选择新建混合树的状态，右键选择<code>Create New Blend Tree in State</code></li>
</ol>
<p><a href="https://imgchr.com/i/sXFRk4" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sXFRk4.png" alt="sXFRk4.png"></a></p>
<ol start="2">
<li><p>双击<code>Blend Tree</code>打开<code>Inspector</code>在<code>Motion</code>处新建需要混合的多个动画。</p>
</li>
<li><p>选择参数<code>Parameter</code>是通过速度<code>Speed</code>计算还是通过垂直加速度<code>verticalVelocity</code>，两个都是<code>Float</code>类型</p>
</li>
<li><p>在各个动画的<code>Threshold</code>设置不同的参数值来控制其出现的时间</p>
</li>
</ol>
<p><a href="https://imgchr.com/i/sXFg7F" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sXFg7F.png" alt="sXFg7F.png"></a></p>
<ol start="5">
<li>在脚本中为动画参数赋值，即关联实际角色与动画设置的参数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fallID;</span><br><span class="line">&#x2F;&#x2F;fallID为Animator状态参数的编号</span><br><span class="line">fallID &#x3D; Animator.StringToHash(&quot;verticalVelocity&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置跳跃BlendTree的动画，其float值就是角色刚体y轴跳跃的加速度,</span><br><span class="line">anim.SetFloat(fallID, rb.velocity.y);</span><br></pre></td></tr></table></figure>

<h2 id="解决更换场景也不销毁某对象"><a href="#解决更换场景也不销毁某对象" class="headerlink" title="解决更换场景也不销毁某对象"></a>解决更换场景也不销毁某对象</h2><p>在代码中使用<code>DontDestroyOnLoad(gameObject)</code>方法</p>
<h2 id="代码中给角色添加特效VFX"><a href="#代码中给角色添加特效VFX" class="headerlink" title="代码中给角色添加特效VFX"></a>代码中给角色添加特效VFX</h2><ol>
<li>脚本中创建特效变量</li>
<li>unity中将特效拖入对应变量中</li>
<li>使用<code>Instantiate(origin,position,rotation)</code>方法替换当前角色的位置为特效动画</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-2D场景透视效果&amp;多个电光源部分光源失效的问题</title>
    <url>/unity-2D%E5%9C%BA%E6%99%AF%E9%80%8F%E8%A7%86%E6%95%88%E6%9E%9C&amp;%E5%A4%9A%E4%B8%AA%E7%94%B5%E5%85%89%E6%BA%90%E9%83%A8%E5%88%86%E5%85%89%E6%BA%90%E5%A4%B1%E6%95%88%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="2D场景透视效果"><a href="#2D场景透视效果" class="headerlink" title="2D场景透视效果"></a>2D场景透视效果</h2><ol>
<li>调整Camera的<code>Projection</code>为<code>Perspective</code><ul>
<li><code>Perspective</code>接近真实摄像机，在3D视图中表现为以点发散的射线构成的画面<br><img src="https://s3.ax1x.com/2021/01/25/sqIAFs.png" alt="sqIAFs.png"></li>
</ul>
</li>
</ol>
<a id="more"></a>

<pre><code>- ```Orthographic```为方形的摄像机，在3D视图中表现为方形垂直的射线构成的画面
![sqIEYn.png](https://s3.ax1x.com/2021/01/25/sqIEYn.png)</code></pre><ol start="2">
<li>调整景深，即调整不同背景图层<code>Position</code>的<code>z轴</code></li>
</ol>
<h2 id="解决设置多个电光源但部分光源失效的问题"><a href="#解决设置多个电光源但部分光源失效的问题" class="headerlink" title="解决设置多个电光源但部分光源失效的问题"></a>解决设置多个电光源但部分光源失效的问题</h2><blockquote>
<p>Unity中Quality Setting的Pixel Light Count的个数过小</p>
</blockquote>
<ol>
<li><p>点击<code>Edit</code>-&gt;<code>Project Setting</code>-&gt;<code>Quality</code>，查看<code>QualitySetting</code></p>
</li>
<li><p>在<code>Rendering</code>设置<code>Pixel Light Count</code>，即场景中渲染的点光源个数。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-合并地图碰撞器&amp;标记字段&amp;射线检测碰撞体</title>
    <url>/unity-%E5%90%88%E5%B9%B6%E5%9C%B0%E5%9B%BE%E7%A2%B0%E6%92%9E%E5%99%A8&amp;%E6%A0%87%E8%AE%B0%E5%AD%97%E6%AE%B5&amp;%E5%B0%84%E7%BA%BF%E6%A3%80%E6%B5%8B%E7%A2%B0%E6%92%9E%E4%BD%93.html</url>
    <content><![CDATA[<h2 id="将地图碰撞器合并"><a href="#将地图碰撞器合并" class="headerlink" title="将地图碰撞器合并"></a>将地图碰撞器合并</h2><ol>
<li>在<code>Tile Collider 2D</code>中勾选<code>Used by Composite</code></li>
<li>新建一个<code>Composite Collider 2D</code>，同时会自动生成一个刚体<code>RigidBody 2D</code></li>
<li>将<code>RigidBody 2D</code>的<code>Body Type</code>设置为<code>static</code>，则其不会因重力而运动，固定在原地</li>
<li>同时也可以在<code>Inspector</code>的右上角将<code>Static</code>勾选</li>
</ol>
<a id="more"></a>

<h2 id="unity在脚本中使用标记字段"><a href="#unity在脚本中使用标记字段" class="headerlink" title="unity在脚本中使用标记字段"></a>unity在脚本中使用标记字段</h2><blockquote>
<p>在脚本中使用标记字段可以在<code>Inspector</code>中组织属性显示</p>
</blockquote>
<ol>
<li><code>[Space(10)]</code>: 与上面产生一个10的空隙，也可以不带参数</li>
<li><code>Header(&quot;xxx&quot;)</code>: 在<code>Inspector</code>面板上给定义的字段的上一行加描述，形成分组的感觉</li>
<li><code>[Tooltip(&quot;xxx&quot;)]</code>: 给变量加Tooltip属性使在<code>Inspector</code>面板鼠标悬停在该变量上显示提示</li>
<li><code>[Range(min,max)]</code>: 限制数值变量的取值范围并以滑动条显示在<code>Inspector</code>中</li>
<li><code>[SerializeField]</code>: 强制序列化一个私有的变量，使之可以在<code>Inspector</code>面板显示</li>
</ol>
<p><a href="https://blog.csdn.net/FifthGently/article/details/78363364?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control" target="_blank" rel="noopener">其他内容可看此链接</a></p>
<p>使用前：</p>
<p><img src="https://s3.ax1x.com/2021/01/22/sIM5N9.png" alt="sIM5N9.png"></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]</span><br><span class="line">private float crouchSpeedDivison &#x3D; 3f;</span><br><span class="line"></span><br><span class="line">[Header(&quot;移动速度&quot;)]</span><br><span class="line">public float speed &#x3D; 8f;</span><br><span class="line">[Space(10)]</span><br><span class="line"></span><br><span class="line">[Range(0, 10)]</span><br><span class="line">public float xVelocity;</span><br></pre></td></tr></table></figure>
<p>使用后：</p>
<p><img src="https://s3.ax1x.com/2021/01/22/sIMIhR.png" alt="sIMIhR.png"></p>
<h2 id="射线检测碰撞体-RaycastHit2D"><a href="#射线检测碰撞体-RaycastHit2D" class="headerlink" title="射线检测碰撞体(RaycastHit2D)"></a>射线检测碰撞体(RaycastHit2D)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;画射线</span><br><span class="line">RaycastHit2D leftCheck &#x3D; Physics2D.Raycast(pos + offset, Vector2.down, groundDistance, groundLayer);</span><br><span class="line">&#x2F;&#x2F;显示射线用于debug</span><br><span class="line">Debug.DrawRay(pos + offset, Vector2.down, Color.red, 0.2f);</span><br></pre></td></tr></table></figure>

<h3 id="Physics-Raycast"><a href="#Physics-Raycast" class="headerlink" title="Physics.Raycast"></a>Physics.Raycast</h3><blockquote>
<p><strong>射线投射(raycast)</strong>：射线投射从原点沿着射线方向发送假想的“激光束”，直至命中场景中的碰撞体，随后返回有关该对象和<code>RaycastHist</code>对象内的投射命中点的信息。</p>
</blockquote>
<blockquote>
<p>向场景中的所有碰撞体投射一条射线，该射线起点为<code>origin</code>，朝向<code>direction</code>，长度为<code>maxDistance</code>。</p>
</blockquote>
<blockquote>
<p>若射线与任何碰撞体相交，返回<code>true</code>否则为<code>false</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static bool Raycast (Vector3 origin, Vector3 direction, float maxDistance&#x3D; Mathf.Infinity, int layerMask&#x3D; DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction&#x3D; QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>origin</td>
<td>射线在坐标系中的起点</td>
</tr>
<tr>
<td>direction</td>
<td>射线方向</td>
</tr>
<tr>
<td>maxDistance</td>
<td>射线检查碰撞的最大距离</td>
</tr>
<tr>
<td>layerMask</td>
<td>遮罩层，用于投射射线时选择性的忽略碰撞体</td>
</tr>
<tr>
<td>queryTriggerInteraction</td>
<td>指定该查询是否应该命中触发器</td>
</tr>
</tbody></table>
<p><strong>重写Raycast方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重构Raycast方法</span><br><span class="line">RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)</span><br><span class="line">&#123;</span><br><span class="line">    Vector2 pos &#x3D; transform.position;</span><br><span class="line">    RaycastHit2D hit &#x3D; Physics2D.Raycast(pos + offset, rayDirection, length, layer);</span><br><span class="line">    Color color &#x3D; hit ? Color.red : Color.green;</span><br><span class="line">    Debug.DrawRay(pos + offset, rayDirection * length,color);</span><br><span class="line">    return hit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Csharp-类&amp;方法</title>
    <url>/Csharp-%E7%B1%BB&amp;%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li><p><code>public</code>：成员可由任何代码访问</p>
</li>
<li><p><code>private</code>：成员只能由类中的代码访问</p>
</li>
<li><p><code>protected</code>：成员只能由类或派生类中的代码访问</p>
</li>
</ul>
<a id="more"></a>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p><code>static</code>：若使用<code>static</code>关键字，该方法只能通过类访问，不能通过对象实例来访问</p>
</li>
<li><p><code>virtual</code>：方法可以重写</p>
</li>
<li><p><code>abstract</code>：方法必须在非抽象的派生类中重写（只用于抽象类）</p>
</li>
<li><p><code>override</code>：方法重写了一个基类方法（若方法被重写，必须使用该关键字）</p>
</li>
<li><p><code>extern</code>：方法定义放在其他地方</p>
</li>
<li><p><code>base</code>：调用重写或隐藏的基类方法，表示包含在派生类中的基类的实现代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基类</span><br><span class="line">public class MyBaseClass&#123;</span><br><span class="line">    &#x2F;&#x2F;若子类可重写此方法，必须使用virtual关键字</span><br><span class="line">    public virtual void DoSomething()&#123;</span><br><span class="line">        &#x2F;&#x2F;方法内容</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">public class MyDerivedClass : MyBaseClass&#123;</span><br><span class="line">    &#x2F;&#x2F;重写基类方法必须使用override关键字</span><br><span class="line">    public override void DoSomething()&#123;</span><br><span class="line">        &#x2F;&#x2F;继承基类方法DoSomething()的已有内容</span><br><span class="line">        base.DoSomething();</span><br><span class="line">        &#x2F;&#x2F;重写方法其他独有功能</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-音效&amp;UI&amp;场景变换及光源</title>
    <url>/unity-%E9%9F%B3%E6%95%88&amp;UI&amp;%E5%9C%BA%E6%99%AF%E5%8F%98%E6%8D%A2%E5%8F%8A%E5%85%89%E6%BA%90.html</url>
    <content><![CDATA[<h2 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h2><ul>
<li><p>Audio Listener：音乐接收</p>
</li>
<li><p>Audio Source：音乐音源</p>
</li>
<li><p>Audio Clips：音乐片段</p>
</li>
</ul>
<a id="more"></a>

<h3 id="背景音乐"><a href="#背景音乐" class="headerlink" title="背景音乐"></a>背景音乐</h3><ol>
<li>下载音乐素材</li>
<li>在player界面添加<code>Audio Source</code></li>
<li>将对应bgm拖入<code>Audio Clip</code></li>
</ol>
<ul>
<li>Play On Awake: 游戏一开始就播放</li>
<li>Loop: 循环播放</li>
</ul>
<h3 id="为其他动作添加音效"><a href="#为其他动作添加音效" class="headerlink" title="为其他动作添加音效"></a>为其他动作添加音效</h3><ol>
<li><p>对象单个动作添音效</p>
<ul>
<li>下载音乐素材</li>
<li>在对象界面添加<code>Audio Source</code></li>
<li>将对应bgm拖入<code>Audio Clip</code></li>
<li>在脚本中添加<code>AudioSource</code>对象，并在<code>start()</code>方法使用<code>GetComponent&lt;AudioSource&gt;()</code>创建component</li>
<li>在合适的位置添加代码<code>audio.Play();</code>方法播放音效 </li>
</ul>
</li>
<li><p>对象多个动作添音效</p>
<ul>
<li>下载音乐素材</li>
<li>在对象界面添加<code>Audio Source</code></li>
<li>将对应bgm拖入<code>Audio Clip</code></li>
<li>在脚本中添加多个<code>public</code>的<code>AudioSource</code>对象，在unity界面将不同的音效拖入脚本的不同属性中</li>
<li>在合适的位置添加代码<code>audio.Play();</code>方法播放音效 </li>
</ul>
</li>
</ol>
<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><ol>
<li>添加UI中的<code>Panel</code>面板</li>
<li>选择合适的位置和颜色</li>
<li>在<code>Panel</code>中添加<code>Text</code>，并添加对应文字和样式</li>
<li>设置出现对话位置的碰撞体并设置<code>is Trigger</code></li>
<li>在代码中实现出现对话框的逻辑</li>
<li>在unity中将对应的对话框拖入<code>script</code>的对应<code>Object</code>中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public GameObject enterDialog;&#x2F;&#x2F;对话框Object</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;角色碰撞到出现对话的位置，触发函数</span><br><span class="line">public void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.tag.Equals(&quot;Player&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        enterDialog.SetActive(true);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;角色离开出现对话的位置，触发函数</span><br><span class="line">public void OnTriggerExit2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.tag.Equals(&quot;Player&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        enterDialog.SetActive(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="场景变换"><a href="#场景变换" class="headerlink" title="场景变换"></a>场景变换</h2><blockquote>
<p>SceneManagement</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重新加载scene--死亡后重启</span><br><span class="line">SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进入下一个场景</span><br><span class="line">&#x2F;&#x2F;使用buildIndex前需要到File-&gt;Build Setting中加入所有场景</span><br><span class="line">SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);</span><br></pre></td></tr></table></figure>


<h2 id="增加光源"><a href="#增加光源" class="headerlink" title="增加光源"></a>增加光源</h2><blockquote>
<p>先让环境暗下来，再让发光的地方发出光源</p>
</blockquote>
<ol>
<li>给背景添加材质<code>Default_diffuse</code>，使其变暗</li>
<li>给人物及其他角色添加材质<ul>
<li>新建材质</li>
<li>在<code>Shader</code>中选择<code>Sprites/Diffuse</code>，若有法线贴图，则将其添加到<code>Normal Map</code>中</li>
<li>将材质拖入人物及其他角色的材质栏</li>
</ul>
</li>
<li>添加<code>Point Light</code>，光源是3D的，需要调节z轴的值来调节光线的亮度，并通过调节Range和Intensity改变光的范围和强度</li>
<li>更改光源位置到需要的地方</li>
</ol>
<p>若添加光源有边缘线，可讲cell size改成1、1，若出现锯齿，则在Project Setting中的Quality，将抗锯齿Anti Aliasing设置为Disabled</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-调用其他类&amp;敌人death动画</title>
    <url>/unity-%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E7%B1%BB&amp;%E6%95%8C%E4%BA%BAdeath%E5%8A%A8%E7%94%BB.html</url>
    <content><![CDATA[<h2 id="调用其他类的方法"><a href="#调用其他类的方法" class="headerlink" title="调用其他类的方法"></a>调用其他类的方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;调用Enemy_Frog类的方法切换敌人的动画</span><br><span class="line">Enemy_Frog frog &#x3D; collision.gameObject.GetComponent&lt;Enemy_Frog&gt;();</span><br><span class="line">frog.SwitchDeath();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="敌人death动画切换"><a href="#敌人death动画切换" class="headerlink" title="敌人death动画切换"></a>敌人death动画切换</h2><ol>
<li>创建敌人动画</li>
<li>创建动画关联Transition</li>
<li>设置条件Trigger(当该触发器被触发则切换动画)</li>
<li>在<code>Animation</code>创建event实现当动画播放结束再销毁敌人GameObject</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-收集&amp;tilemap拼接缝隙&amp;collider碰撞摩擦&amp;敌人</title>
    <url>/unity-%E6%94%B6%E9%9B%86&amp;tilemap%E6%8B%BC%E6%8E%A5%E7%BC%9D%E9%9A%99&amp;collider%E7%A2%B0%E6%92%9E%E6%91%A9%E6%93%A6&amp;%E6%95%8C%E4%BA%BA.html</url>
    <content><![CDATA[<h2 id="创建收集内容"><a href="#创建收集内容" class="headerlink" title="创建收集内容"></a>创建收集内容</h2><ol>
<li>新建收集object</li>
<li>添加sprite和动画</li>
<li>移动至合适位置</li>
<li>设置collider碰撞体</li>
<li>设置isTrigger，使之碰撞时触发一些改变</li>
<li>为object设置特有tag，便于写脚本时获取该object</li>
<li>编写脚本实现计数、销毁等操作<a id="more"></a>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.tag.Equals(&quot;Cherry&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            cherry++;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (collision.tag.Equals(&quot;Gem&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            gem++;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些记录"><a href="#一些记录" class="headerlink" title="一些记录"></a>一些记录</h3><p>is Trigger: 触发器 触发后会发生一些改变</p>
<p>inspector中: <code>Tag</code>、<code>Layer</code></p>
<p>Perfabs: 一个预置，类似于一个模版</p>
<h2 id="瓦片地图出现拼接缝隙"><a href="#瓦片地图出现拼接缝隙" class="headerlink" title="瓦片地图出现拼接缝隙"></a>瓦片地图出现拼接缝隙</h2><p>将<code>tilemap</code>的<code>grid</code>中<code>cellsize</code>改为0.99</p>
<h2 id="解决两个collider碰撞摩擦的问题-material材质"><a href="#解决两个collider碰撞摩擦的问题-material材质" class="headerlink" title="解决两个collider碰撞摩擦的问题(material材质)"></a>解决两个collider碰撞摩擦的问题(material材质)</h2><ol>
<li>创建<code>physical material 2d</code></li>
<li>修改摩擦力<code>friction</code>为0</li>
<li>将材质放入需要的collider里的material中</li>
</ol>
<h2 id="解决角色可多次跳的问题"><a href="#解决角色可多次跳的问题" class="headerlink" title="解决角色可多次跳的问题"></a>解决角色可多次跳的问题</h2><blockquote>
<p>设置角色只有触碰地面才可以跳跃，无法在空中跳跃</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public LayerMask ground;&#x2F;&#x2F;图层</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;角色跳跃</span><br><span class="line">if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; coll.IsTouchingLayers(ground))</span><br><span class="line">&#123;</span><br><span class="line">    rb.velocity &#x3D; new Vector2(rb.velocity.x, jumpForce * Time.deltaTime);</span><br><span class="line">    anim.SetBool(&quot;jumping&quot;, true);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ol>
<li>新建UI画布<code>canvas</code></li>
<li>在<code>canvas</code>内添加需要的内容</li>
<li>需要变化的变量在脚本中实现，unity中新建的UI是什么选项，脚本中就按该关键字获取UI</li>
<li>在unity脚本框内拖入相应的ui选项</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine.UI</span><br><span class="line"></span><br><span class="line">public Text CherryNumber;&#x2F;&#x2F;新建Text类</span><br><span class="line"></span><br><span class="line">CherryNumber.text &#x3D; cherry.ToString();&#x2F;&#x2F;将实际cherry值传给unity的Text类中</span><br></pre></td></tr></table></figure>

<h2 id="敌人"><a href="#敌人" class="headerlink" title="敌人"></a>敌人</h2><h3 id="创建敌人"><a href="#创建敌人" class="headerlink" title="创建敌人"></a>创建敌人</h3><ol>
<li>新建角色sprite</li>
<li>添加动画</li>
<li>添加刚体</li>
<li>添加collider。<code>circle</code>最好，可以保证移动时不翻转</li>
<li>给敌人加标签，便于编写脚本时获取</li>
</ol>
<h3 id="踩敌人消灭"><a href="#踩敌人消灭" class="headerlink" title="踩敌人消灭"></a>踩敌人消灭</h3><blockquote>
<p>判断角色是下落状态时，碰撞到敌人则destroy敌人</p>
</blockquote>
<h3 id="受伤"><a href="#受伤" class="headerlink" title="受伤"></a>受伤</h3><ol>
<li>添加受伤动画</li>
<li>在<code>Animator</code>添加hurt标志，调整不同状态转换的条件</li>
<li>编写受伤脚本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]private bool isHurt;&#x2F;&#x2F;判断是否受伤</span><br><span class="line">&#x2F;&#x2F;受伤动画转换</span><br><span class="line">else if (isHurt)</span><br><span class="line">&#123;</span><br><span class="line">    anim.SetBool(&quot;hurt&quot;, true);</span><br><span class="line">    anim.SetFloat(&quot;running&quot;, 0);&#x2F;&#x2F;保证受伤后处于静止状态而不是跑步状态</span><br><span class="line">    if (Mathf.Abs(rb.velocity.x) &lt; 0.1) &#123;&#x2F;&#x2F;判断角色是否已经反弹结束处于静止状态</span><br><span class="line">        isHurt &#x3D; false;</span><br><span class="line">        anim.SetBool(&quot;hurt&quot;, false);</span><br><span class="line">        anim.SetBool(&quot;idle&quot;, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;消灭敌人</span><br><span class="line">private void OnCollisionEnter2D(Collision2D collision)&#x2F;&#x2F;当该刚体碰撞另一个刚体时调用的函数</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.tag.Equals(&quot;Enemies&quot;)) &#123; &#x2F;&#x2F;函数代表的是整个碰撞器&#x2F;刚体，故需要.gameObject获其角色类</span><br><span class="line">    	&#x2F;&#x2F;消灭敌人</span><br><span class="line">        if (anim.GetBool(&quot;falling&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">            &#x2F;&#x2F;增加消灭后再次小跳的效果</span><br><span class="line">            rb.velocity &#x3D; new Vector2(rb.velocity.x, jumpForce * Time.deltaTime);</span><br><span class="line">            anim.SetBool(&quot;jumping&quot;, true);</span><br><span class="line">        &#125;else if(transform.position.x &lt; collision.gameObject.transform.position.x)</span><br><span class="line">        &#123;&#x2F;&#x2F;增加受伤反弹的效果</span><br><span class="line">            rb.velocity &#x3D; new Vector2(-5, rb.velocity.y);</span><br><span class="line">            isHurt &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (transform.position.x &gt; collision.gameObject.transform.position.x)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.velocity &#x3D; new Vector2(5, rb.velocity.y);</span><br><span class="line">            isHurt &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="敌人移动AI"><a href="#敌人移动AI" class="headerlink" title="敌人移动AI"></a>敌人移动AI</h3><ol>
<li>敌人角色下创建两个<code>GameObject</code>表示左右边界，设置移动边界位置（此时角色与边界为父子关系）</li>
<li>新建敌人脚本</li>
<li>新建两个<code>Transform</code>类表示左右边界，并在unity中拖入边界Object完成关联</li>
<li>在脚本中在start时获取边界的x值，然后将其边界Object销毁，保证其不随敌人角色移动</li>
<li>编写自动移动脚本</li>
<li>在unity设置初始speed使之移动<br>（以下均可选）</li>
<li>添加跳跃动画</li>
<li>设置相关条件，并编写动画切换脚本</li>
<li>在<code>Animation</code>界面静止状态最后一秒新建事件<code>event</code>，设置其事件函数为移动的movement。使敌人角色在播放完静止动画后执行移动函数，进行跳跃等其他动作。此时不需要在update中每秒执行movement函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Rigidbody2D rb;</span><br><span class="line">&#x2F;&#x2F;左右的行动边界</span><br><span class="line">public Transform leftPoint,rightPoint;</span><br><span class="line">private bool isFaceLeft &#x3D; true;</span><br><span class="line">public float speed;</span><br><span class="line">private float leftx, rightx;&#x2F;&#x2F;用于保存左右边界的x值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;敌人移动</span><br><span class="line">void Movement()</span><br><span class="line">&#123;</span><br><span class="line">    if (isFaceLeft)</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(-speed, rb.velocity.y);</span><br><span class="line">        if(transform.position.x &lt; leftx)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;控制敌人面向右边，即掉头</span><br><span class="line">            transform.localScale &#x3D; new Vector3(-1, 1, 1);</span><br><span class="line">            isFaceLeft &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(speed, rb.velocity.y);</span><br><span class="line">        if (transform.position.x &gt; rightx)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale &#x3D; new Vector3(1, 1, 1);</span><br><span class="line">            isFaceLeft &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Csharp-基础</title>
    <url>/Csharp-%E5%9F%BA%E7%A1%80.html</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello World!&quot;); &#x2F;&#x2F;有换行符</span><br><span class="line">Console.Write(&quot;Hello New World&quot;!); &#x2F;&#x2F;无换行符</span><br></pre></td></tr></table></figure>

<p>C#区分大小写，字符串只能用<code>“”</code>，单字符char使用<code>&#39;&#39;</code></p>
<p>十进制文本：12.3m/12.3M（m/M-文本后缀）</p>
<a id="more"></a>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>字符类：string、char<br>计算类：int、decimal<br>布尔：bool</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量名区分大小写，使用驼峰命名法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char userOption;</span><br><span class="line">int gameScore;</span><br><span class="line">decimal particlesPerMillion;</span><br><span class="line">bool processedCustomer;</span><br></pre></td></tr></table></figure>

<p>使用前必须初始化。</p>
<p>可以使用<code>var</code>隐式创建变量。但初始化后推断出类型，则无法用另外的类型覆盖。且必须在初始化时使用，即<code>var word = &quot;hello!&quot;;</code></p>
<h4 id="逐字字符串"><a href="#逐字字符串" class="headerlink" title="逐字字符串"></a>逐字字符串</h4><p>逐字字符串文本保留所有空格和字符，且无需转义字符。使用时在文本字符串前加<code>@</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(&quot;C:\\Users\\Desktop&quot;);</span><br><span class="line">Console.WriteLine(@&quot;C:\Users\Desktop</span><br><span class="line">	(this is where your code goes)&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="字符串内插"><a href="#字符串内插" class="headerlink" title="字符串内插"></a>字符串内插</h4><p>使用“template”和一/多个内插表达式将多个值合为单个文本字符串。</p>
<p>内插表达式使用<code>{}</code></p>
<p>文本字符串使用<code>$</code>为前缀，该字符串变为模版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string firstName &#x3D; &quot;Bob&quot;;</span><br><span class="line">Console.WriteLine($&quot;Hello &#123;firstName&#125;!&quot;);</span><br><span class="line"></span><br><span class="line">string projectName &#x3D; &quot;First-Project&quot;;</span><br><span class="line">Console.WriteLine($@&quot;C:\Output\&#123;projectName&#125;\Data&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>除法中商必须为<code>decimal</code>，且除数或被除数必须为<code>decimal</code>（或两者都是），才能保证完全准确的结果</p>
<p>运算顺序PEMDAS：</p>
<ul>
<li>P 圆括号</li>
<li>E 指数</li>
<li>M 乘法 和 D 除法</li>
<li>A 加法 和 S 减法</li>
</ul>
<p>C#顺序相同，但没有<code>指数</code>。可以使用<code>System.Math.Pow()</code>方法。</p>
<h3 id="NET类库"><a href="#NET类库" class="headerlink" title=".NET类库"></a>.NET类库</h3><p>包含成千上万个方法的类的集合。</p>
<p>命名空间可视为类型的“姓氏”，类被组织称不同的命名空间，以防发生命名冲突。命名空间有助于确保任何两个类中不具有相同的全名。</p>
<h4 id="状态方法"><a href="#状态方法" class="headerlink" title="状态方法"></a>状态方法</h4><p>“状态”用来描述特定时刻下执行环境的状况。在代码执行过程中，应用程序的当前状态为存储在内存中的所有值的集合。</p>
<ul>
<li><p>无状态方法（静态方法）：正常工作不依赖于应用程序的当前状态，即在不引用或更改内存中存储的任何值的情况下正常工作。</p>
</li>
<li><p>有状态方法（实例方法）：依赖于由以前的已执行代码行存储在内存中的值构建的，即有状态方法通过更新值或将新值存储在内存中来修改应用程序的状态。有状态方法在字段（类上定义的变量）中跟踪方法的状态。</p>
</li>
</ul>
<p>单个类可支持有状态方法和无状态方法。需要调用有状态方法时，必须先创建类的实例，才能访问状态。</p>
<p>类的实例即对象。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string[] ids &#x3D; new string[3];</span><br><span class="line">string[] scores &#x3D; &#123;&quot;Abc&quot;,&quot;cdsd&quot;,&quot;sss&quot;&#125;;</span><br><span class="line">int length &#x3D; scores.Length;</span><br><span class="line">foreach(string num in scores)&#123; &#x2F;&#x2F;将每个元素执行一次</span><br><span class="line">	Console.WriteLine(num); &#x2F;&#x2F; foreach中不能分配num的值，它为foreach迭代内部实现的一部分</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 0; i&lt;2; i++)&#123;</span><br><span class="line">	Console.WriteLine(scores[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-tilemap&amp;角色移动&amp;刚体&amp;碰撞</title>
    <url>/unity-tilemap&amp;%E8%A7%92%E8%89%B2%E7%A7%BB%E5%8A%A8&amp;%E5%88%9A%E4%BD%93&amp;%E7%A2%B0%E6%92%9E.html</url>
    <content><![CDATA[<h2 id="制作地图（Tilemap）"><a href="#制作地图（Tilemap）" class="headerlink" title="制作地图（Tilemap）"></a>制作地图（Tilemap）</h2><ol>
<li>设置素材大小<code>Pixels Per Unit</code>为合适的数值</li>
<li>设置sprite Mode为Multiple用于切割</li>
<li>打开素材Sprite Editor编辑，选择不同slice方式切割素材</li>
<li>选择每个单元格的素材在scene中绘制地图<a id="more"></a>

</li>
</ol>
<h2 id="添加角色"><a href="#添加角色" class="headerlink" title="添加角色"></a>添加角色</h2><ol>
<li>设置素材大小为合适数值</li>
<li>将角色拖至<code>Hierarchy</code>中，设置其<code>sorting layer</code></li>
<li>在<code>Animation</code>窗口添加多张图片以添加动画</li>
<li>拖拽时间轴使动画频率合适</li>
</ol>
<h2 id="刚体–Rigidbody"><a href="#刚体–Rigidbody" class="headerlink" title="刚体–Rigidbody"></a>刚体–Rigidbody</h2><blockquote>
<p>让平面物体拥有重量，使其有重力，阻力等，可以受力的作用</p>
</blockquote>
<ol>
<li><code>Add Component</code>中选择<code>Rigidbody 2D</code></li>
<li>设置<code>Gravity Scale</code>重力为合适的数值</li>
<li>若使角色保持直立，则勾选<code>Constraints</code>中<code>Freeze Rotation</code>的Z轴使之锁定</li>
</ol>
<h2 id="碰撞–Collider"><a href="#碰撞–Collider" class="headerlink" title="碰撞–Collider"></a>碰撞–Collider</h2><blockquote>
<p>让物体可碰撞，接触。</p>
</blockquote>
<ol>
<li><code>Add Component</code>中选择需要的collider</li>
<li>勾选<code>Edit Collider</code>编辑角色碰撞的范围</li>
<li>设置不同图层，使角色与环境分离</li>
</ol>
<h2 id="角色移动"><a href="#角色移动" class="headerlink" title="角色移动"></a>角色移动</h2><ol>
<li><code>Edit</code>-&gt;<code>Project Settings</code>-&gt;<code>Input Manager</code>获取需要的输入信息</li>
<li>左右方向Horizontal，-1为左，0不动，1为右</li>
<li>编写脚本，距离=速度speed*单位位移*Time.delTime（delTime保证不同环境下都能顺滑移动），speed越高，移动的越快</li>
<li>跳跃时给角色添加跳跃的力<code>jumpForce</code>，在unity脚本页面设置的jumpForce越大跳的越高</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]private Rigidbody2D rb;</span><br><span class="line">public float speed;</span><br><span class="line">public float jumpForce;</span><br><span class="line"></span><br><span class="line">void movement()</span><br><span class="line">&#123;</span><br><span class="line">    float horizontalMove &#x3D; Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">    float faceDirection &#x3D; Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class="line">    &#x2F;&#x2F;角色移动</span><br><span class="line">    if(horizontalMove !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(horizontalMove * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line">        anim.SetFloat(&quot;running&quot;, Mathf.Abs(faceDirection)); </span><br><span class="line">    &#125;</span><br><span class="line">    if(faceDirection !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        transform.localScale &#x3D; new Vector3(faceDirection, 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;角色跳跃</span><br><span class="line">    if (Input.GetButtonDown(&quot;Jump&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(rb.velocity.x, jumpForce * Time.deltaTime);</span><br><span class="line">        anim.SetBool(&quot;jumping&quot;, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="角色移动时动画的改变"><a href="#角色移动时动画的改变" class="headerlink" title="角色移动时动画的改变"></a>角色移动时动画的改变</h2><ol>
<li>新建动画</li>
<li>打开<code>Animator</code>设置不同改变顺序</li>
<li>点击各箭头关闭<code>Has Exit Time</code>和<code>Transition Duration</code>使变化没有延迟时间</li>
<li>若需要变化条件，则在<code>Parameter</code>中新建不同的参数用于脚本使用</li>
<li>并在<code>Conditions</code>处设置不同的条件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]private Rigidbody2D rb;</span><br><span class="line">[SerializeField]private Animator anim;</span><br><span class="line"></span><br><span class="line">void switchAnim()</span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetBool(&quot;idle&quot;, false);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;跳跃到下落动画切换</span><br><span class="line">        if (anim.GetBool(&quot;jumping&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            if(rb.velocity.y &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                anim.SetBool(&quot;jumping&quot;, false);</span><br><span class="line">                anim.SetBool(&quot;falling&quot;, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if (coll.IsTouchingLayers(ground))&#x2F;&#x2F;下降到地面动画切换</span><br><span class="line">        &#123;</span><br><span class="line">            anim.SetBool(&quot;falling&quot;, false);</span><br><span class="line">            anim.SetBool(&quot;idle&quot;, true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="一些记录"><a href="#一些记录" class="headerlink" title="一些记录"></a>一些记录</h2><p>Input.GetAxis()//获取-1～0，0～1<br>Input.GetAxisRaw()//仅获取-1.0.1，左，不动，右</p>
<p>Vector2: 2维变化<br>Vector3: 3维变化    </p>
<p>FixedUpdate();<br>Update();</p>
<p>LayerMask: 在脚本中获取图层</p>
<p>public可以在script里看到<br>private不能看到，在start里初始化<br>[SerializeField]private则可以看到，但不能改</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS设置div垂直横向居中</title>
    <url>/CSS%E8%AE%BE%E7%BD%AEdiv%E5%9E%82%E7%9B%B4%E6%A8%AA%E5%90%91%E5%B1%85%E4%B8%AD.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre><code>最近写公司登陆页面，打算设置登录框水平竖直均居中，尝试了各种方式，最终解决方式如下</code></pre><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><pre><code>父级div：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.login-div&#123;</span><br><span class="line">	width: 100%,</span><br><span class="line">	height: 100%,</span><br><span class="line">	overflow: hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

子级登录框：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.login-box&#123;</span><br><span class="line">	&#x2F;&#x2F; 以左上角为原点,不处以中心位置</span><br><span class="line">	top: 50%,</span><br><span class="line">	left: 50%,</span><br><span class="line">	&#x2F;&#x2F; 往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置</span><br><span class="line">	transform: translate(-50%,-50%)</span><br><span class="line">	position: absolute</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>React(5)-构建React应用的一般步骤</title>
    <url>/React-5-%E6%9E%84%E5%BB%BAReact%E5%BA%94%E7%94%A8%E7%9A%84%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4.html</url>
    <content><![CDATA[<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>获得一张组件设计图和后台返回的JSON数据。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0bqnovjoj30f60g00uz.jpg" alt="设计图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="划分组件层级"><a href="#划分组件层级" class="headerlink" title="划分组件层级"></a>划分组件层级</h2><p>按照给定的组件设计图，划分组件层级。</p>
<p>将组件看作函数或对象来考虑，根据单一功能原则判定组件范围，即一个组件只负责一个功能。若负责多个功能则考虑将其拆分。</p>
<p>按给定的JSON数据模型设计UI（组件结构），使两者一一对应。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0byibhvyj30es0g876c.jpg" alt="划分组件"></p>
<p>如上图，可将整个设计图层级分为5部分：</p>
<ol>
<li>红色区域（FilterProductTable）：整个组件应用整体</li>
<li>绿色区域（SearchBar）：获取用户输入部分</li>
<li>蓝色部分（ProductTable）：整个数据展示部分</li>
<li>粉色部分（ProductCategoryRow）：数据展示部分的产品分类标题部分</li>
<li>橘色部分（ProductRow）：数据展示部分的分类下每个产品的部分。</li>
</ol>
<p>层级关系可表示为：</p>
<ul>
<li>FilterProductTable<ul>
<li>SearchBar</li>
<li>ProductTable<ul>
<li>ProductCategoryRow</li>
<li>ProductRow</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="根据层级关系编写应用的静态版本"><a href="#根据层级关系编写应用的静态版本" class="headerlink" title="根据层级关系编写应用的静态版本"></a>根据层级关系编写应用的静态版本</h2><p>应用静态版本即使用已有的数据模型渲染一个不包含交互的UI。</p>
<p>静态版本不需要考虑交互细节，而添加交互功能需要考虑大量的细节。故在实际应用中分开进行更合适。构建静态版本只需要通过props传入所需的数据，props是父组件向子组件传递数据的方式。此时不需要考虑state，因为state代表会随时间变化的数据，应只在交互时使用。</p>
<p>编写静态版本有两种方式：自上而下和自下而上。</p>
<ol>
<li>自上而下：先构建层级较高的组件，再自上而下分步细化组件。适用于构建简单的应用。</li>
<li>自下而上：先构建最基本的组件，再一层一层向上构建。适用于构建大型的项目。</li>
</ol>
<p>静态版本的组件提供<code>render()</code>方法用于渲染数据模型。故当数据模型改变，则调用<code>ReactDOM.render()</code>重新渲染，UI相应更新，即React的单向数据流思想。</p>
<p>相应代码见<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React官方文档</a></p>
<h2 id="确定state变量"><a href="#确定state变量" class="headerlink" title="确定state变量"></a>确定state变量</h2><blockquote>
<p>全称:Don’t Repeat Yourself (摘自wikipedia),是指编程过程中不写重复代码,将能够公共的部分抽象出来,封装成工具类或者用“abstraction”类来抽象公有的东西,降低代码的耦合性,</p>
</blockquote>
<p>按照DRY原则，只保留应用所需的<code>state</code>的最小集合，其他数据由此<code>state</code>计算得出。</p>
<p>确定<code>state</code>需考虑以下问题：</p>
<ol>
<li>该数据是否由父组件通过<code>props</code>传递而来，若是，则不是<code>state</code></li>
<li>该数据是否变化？若保持不变，则不是<code>state</code></li>
<li>该数据是否能根据其他数据计算而来，若是，则不是<code>state</code>。</li>
</ol>
<p>由上文可得，产品的所有信息都可由父组件<code>FilterProductTable</code>传递而来，故不是<code>state</code>。<code>SearchBar</code>中的搜索字段和checkbox选中值需要由用户交互而变化，且无法由其他数据计算而来，故应该为<code>state</code></p>
<h2 id="确定state位置"><a href="#确定state位置" class="headerlink" title="确定state位置"></a>确定state位置</h2><p>由于React的数据是单向流动，且按组件层级自上而下传递，故<code>state</code>所属的组件很难确定。</p>
<p>判断时，依照如下步骤考虑：</p>
<ol>
<li>查看根据此<code>state</code>渲染的所有组件</li>
<li>找到这些组件的共同所有者组件，即层级高于这些组件的组件</li>
<li>该共同所有者组件或比他层级更高的组件应该拥有此<code>state</code></li>
<li>若无法找到合适的位置存放<code>state</code>，则可以创建一个新的组件来存放<code>state</code>。</li>
</ol>
<p>根据上述步骤，可发现：</p>
<ol>
<li><code>SearchBar</code>和<code>ProductTable</code>都需要此state。<code>SearchBar</code>需要state展示搜索框和checkbox的状态。<code>ProductTable</code>需要根据state筛选产品列表。</li>
<li><code>SearchBar</code>和<code>ProductTable</code>的共同所有者是<code>FilterProductTable</code></li>
<li>因此state应存放在<code>FilterProductTable</code>中。</li>
</ol>
<p>首先，将实例属性<code>this.state = {filterText: &#39;&#39;, inStockOnly: false}</code>添加到<code>FilterableProductTable</code>的 <code>constructor</code>中，设置应用的初始 <code>state</code>；接着，将<code>filterText</code>和<code>inStockOnly</code>作为<code>props</code>传入 <code>ProductTable</code>和<code>SearchBar</code>；最后，用这些<code>props</code>筛选<code>ProductTable</code>中的产品信息，并设置<code>SearchBar</code>的表单值。</p>
<p>相应代码见<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React官方文档</a></p>
<h2 id="添加state的数据流控制"><a href="#添加state的数据流控制" class="headerlink" title="添加state的数据流控制"></a>添加state的数据流控制</h2><p>之前步骤通过props和state自上而下传递了需要的数据。现在控制处于较低层级的表单组件更新较高组件中的state，以达到完成交互。</p>
<p>要实现的功能是：<br>用户改变表单的值-&gt;改变state反映用户输入。</p>
<p>state只能由拥有它的组件进行更改，故需要设置一个能触发state改变的回调函数传递给SearchBar。思路为：</p>
<ol>
<li>使用输入框的onChange事件监视用户输入</li>
<li>当用户改变表单的值，触发onChange事件，调用表单组件的handle方法。</li>
<li>表单组件的handle方法调用父组件FilterProductTable的onFilterTextChange事件</li>
<li>FilterProductTable的handleFilterTextChange方法使用setState改变state的值，更新应用</li>
</ol>
<p>所有代码见<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React官方文档</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(4)-状态提升及组合</title>
    <url>/React-4-%E7%8A%B6%E6%80%81%E6%8F%90%E5%8D%87%E5%8F%8A%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF.html</url>
    <content><![CDATA[<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>React应用中，任何可变的数据应只有一个唯一数据源，此时state首先添加到需要渲染的组件中。但当多个组件需要共用反映同样的变化数据时，即其他组件也需要这个state时，需要将state提升到这些组件的共同父组件中。通过自顶向下的数据源，更新唯一的数据源state。</p>
<p>在子组件中使用<code>this.props.xxx</code>代替<code>this.state</code>。在共同父组件中使用<code>state</code>更新子组件中的值。</p>
<a id="more"></a>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>React有丰富的组合模式，供组件间的代码重用。</p>
<h3 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FancyBorder(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&#123;&#39;FancyBorder FancyBorder-&#39; + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color&#x3D;&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&quot;Dialog-title&quot;&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p className&#x3D;&quot;Dialog-message&quot;&gt;</span><br><span class="line">        Thank you for visiting our spacecraft!</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WelcomeDialog</code>方法中<code>&lt;FancyBorder&gt;</code>标签内的内容对应<code>FancyBorder</code>函数里的<code>{props.children}</code>，此时<code>props.children</code>中的内容都被渲染到<code>&lt;div&gt;</code>中。</p>
<p>也可以通过标签属性来自行约定<code>children</code>，将所需的内容传入props。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Contacts() &#123;</span><br><span class="line">  return &lt;div className&#x3D;&quot;Contacts&quot; &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Chat() &#123;</span><br><span class="line">  return &lt;div className&#x3D;&quot;Chat&quot; &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function SplitPane(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;SplitPane&quot;&gt;</span><br><span class="line">      &lt;div className&#x3D;&quot;SplitPane-left&quot;&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div className&#x3D;&quot;SplitPane-right&quot;&gt;</span><br><span class="line">        &#123;props.right&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SplitPane</span><br><span class="line">      left&#x3D;&#123;</span><br><span class="line">        &lt;Contacts &#x2F;&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right&#x3D;&#123;</span><br><span class="line">        &lt;Chat &#x2F;&gt;</span><br><span class="line">      &#125; &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中<code>&lt;Contacts /&gt;</code>和<code>&lt;Chat /&gt;</code>本质即为对象，故可以当作props来传递。</p>
<h3 id="特例关系"><a href="#特例关系" class="headerlink" title="特例关系"></a>特例关系</h3><p>有些组件可看作其他组件的特殊实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Dialog(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color&#x3D;&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&quot;Dialog-title&quot;&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p className&#x3D;&quot;Dialog-message&quot;&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Dialog</span><br><span class="line">      title&#x3D;&quot;Welcome&quot;</span><br><span class="line">      message&#x3D;&quot;Thank you for visiting our spacecraft!&quot; &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(3)-列表及简单表单</title>
    <url>/React-3-%E5%88%97%E8%A1%A8%E5%8F%8A%E7%AE%80%E5%8D%95%E8%A1%A8%E5%8D%95.html</url>
    <content><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>使用<code>{}</code>在JSX构建一个元素集合。<br>使用JS的<code>map()</code>方法遍历数组，将数组中的元素变成<code>&lt;li&gt;</code>标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const number &#x3D; [1,2,3,4,5];</span><br><span class="line">const listitems &#x3D; numbers.map((number) &#x3D;&gt; </span><br><span class="line">    &lt;li&gt;&#123;number&#125;&lt;&#x2F;li&gt;</span><br><span class="line">);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;&#x2F;ul&gt;,</span><br><span class="line">document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>当创建元素时必须包含一个key属性。key属性帮助React识别元素的变化。</p>
<h4 id="key的正确使用"><a href="#key的正确使用" class="headerlink" title="key的正确使用"></a>key的正确使用</h4><p>一个元素的key最好是元素在列表中拥有的独一无二的字符串，万不得已时才使用索引作为key。</p>
<p>元素的key只有放在就近的数组上下文才有意义。故如果提取一个组件，就应把组件的key保留在该组件的元素上，而不是它里面的子元素上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ListItem(props)&#123;</span><br><span class="line">    &#x2F;&#x2F;子元素无需指定key</span><br><span class="line">    return &lt;li&gt;&#123;props.value&#125;&lt;&#x2F;li&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function NumberList(props)&#123;</span><br><span class="line">    const numbers &#x3D; props.numbers;</span><br><span class="line">    const listItems &#x3D; numbers.map((number) &#x3D;&gt;</span><br><span class="line">    &#x2F;&#x2F;key应在数组的上下文中指定，经验法则：在map()中的元素需指定key属性</span><br><span class="line">        &lt;ListItem key&#x3D;&#123;number.toString()&#125; value&#x3D;&#123;number&#125; &#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">    return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers&#x3D;&#123;numbers&#125; &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="key的唯一性"><a href="#key的唯一性" class="headerlink" title="key的唯一性"></a>key的唯一性</h4><p>key在兄弟节点之间必须唯一，但不是全局唯一。即当有两个不同的数组时，key可以相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sidebar &#x3D; (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.posts.map((post) &#x3D;&gt;</span><br><span class="line">        &lt;li key&#x3D;&#123;post.id&#125;&gt;</span><br><span class="line">          &#123;post.title&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  );</span><br><span class="line">  const content &#x3D; props.posts.map((post) &#x3D;&gt;</span><br><span class="line">    &lt;div key&#x3D;&#123;post.id&#125;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;post.title&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;post.content&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>key传递信息给React，但不会传递给组件。因此，若需要使用key的值，需要使用其他属性将其显式的传递出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const content &#x3D; posts.map((post) &#x3D;&gt;</span><br><span class="line">  &lt;Post</span><br><span class="line">    key&#x3D;&#123;post.id&#125;</span><br><span class="line">    id&#x3D;&#123;post.id&#125;</span><br><span class="line">    title&#x3D;&#123;post.title&#125; &#x2F;&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="在JSX中嵌入map"><a href="#在JSX中嵌入map" class="headerlink" title="在JSX中嵌入map()"></a>在JSX中嵌入map()</h3><p>以上都是声明单独的变量并将其包含在JSX中，但JSX允许在大括号<code>{}</code>中嵌入表达式，因此可以直接内联<code>map()</code>返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function NumberList(props)&#123;</span><br><span class="line">    const numbers &#x3D; props.numbers;</span><br><span class="line">    return (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;numbers.map((number) &#x3D;&gt; </span><br><span class="line">                &lt;ListItem key&#x3D;&#123;number.toString()&#125;</span><br><span class="line">                          value&#x3D;&#123;number&#125;</span><br><span class="line">                &#x2F;&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>HTML表单与其他DOM元素不同，它内部通常保持一些state，大多情况下，使用JavaScript函数可以方便的处理表单提交，同时访问用户填写的表单数据。实现此效果的标准方式是使用受控组件</p>
<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>受控组件使React的state成为唯一数据源。渲染表单的React组件控制用户输入过程中发生的操作。（结合state及事件处理操作）</p>
<h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    &#x2F;&#x2F;输入input组件值由state控制，此处设置初始值。</span><br><span class="line">    this.state &#x3D; &#123;value: &#39;&#39;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit &#x3D; this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;input框内容改变事件</span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;提交内容事件</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&#39;提交的名字: &#39; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          名字:</span><br><span class="line">          &#x2F;&#x2F;state.value是input框的唯一数据源</span><br><span class="line">          &#x2F;&#x2F;onChange事件会在用户每一次按键后更新React的state</span><br><span class="line">          &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h4><p>text的使用与input相同，但默认有初值</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select选择框的选中属性使用value控制，而不使用selected属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;value: &#39;coconut&#39;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit &#x3D; this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          选择你喜欢的风味:</span><br><span class="line">          &lt;select value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;grapefruit&quot;&gt;葡萄柚&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;lime&quot;&gt;酸橙&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;coconut&quot;&gt;椰子&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;mango&quot;&gt;芒果&lt;&#x2F;option&gt;</span><br><span class="line">          &lt;&#x2F;select&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>option内容也可直接在select标签内将数组传递到vlue属性。使用多选时，设置<code>multiple={true}</code></p>
<h3 id="接受多个输入"><a href="#接受多个输入" class="headerlink" title="接受多个输入"></a>接受多个输入</h3><p>当需要处理多个input元素时，给每个元素添加<code>name</code>属性，处理函数根据<code>event.target.name</code>选择要执行的操作。<code>setState()</code>自动将部分state合并到当前state。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Reservation extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      isGoing: true,</span><br><span class="line">      numberOfGuests: 2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleInputChange &#x3D; this.handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    const target &#x3D; event.target;</span><br><span class="line">    const value &#x3D; target.name &#x3D;&#x3D;&#x3D; &#39;isGoing&#39; ? target.checked : target.value;</span><br><span class="line">    const name &#x3D; target.name;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          参与:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;isGoing&quot;</span><br><span class="line">            type&#x3D;&quot;checkbox&quot;</span><br><span class="line">            checked&#x3D;&#123;this.state.isGoing&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          来宾人数:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;numberOfGuests&quot;</span><br><span class="line">            type&#x3D;&quot;number&quot;</span><br><span class="line">            value&#x3D;&#123;this.state.numberOfGuests&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(2)-事件处理及条件渲染</title>
    <url>/React-2-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%8F%8A%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93.html</url>
    <content><![CDATA[<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><blockquote>
<p>为了与传统HTML区别开，React事件命名采用小驼峰（camelCase）形式。<br>使用JSX语法时需要传入函数作为事件处理函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&#123;function&#125;&gt;</span><br><span class="line">Function</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>阻止默认行为必须显式的使用<code>preventDefault</code></p>
<a id="more"></a>    

 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ActionLink()&#123;</span><br><span class="line">    function handleClick(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        console.log(&quot;Clicked!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;a href&#x3D;&quot;#&quot; onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">        Click me!</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> e为合成事件，无跨浏览器的兼容问题。</p>
</li>
<li><p>使用React不需要使用<code>addEventListener</code>为DOM元素添加监听器。只需要在元素初始渲染时添加监听器即可。</p>
</li>
<li><p>使用class定义组件时，通常将事件处理函数声明为class的方法。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    class Toggle extends React.Component &#123;</span><br><span class="line">        constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state &#x3D; &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 为了在回调中使用 &#96;this&#96;，这个绑定是必不可少的</span><br><span class="line">        this.handleClick &#x3D; this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class="line">            &#123;this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;&#125;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;Toggle &#x2F;&gt;,</span><br><span class="line">        document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p> JavaScript中class方法默认不会绑定this。若在JSX中没有绑定this.handleClick并把它传入onClick。则调用函数时，this的值为undifined。</p>
</li>
<li><p>事件绑定this<br> <strong>优先使用方法一和方法二</strong></p>
<ul>
<li><p>方法一：bind<br>如3中代码所示</p>
</li>
<li><p>方法二：class field语法<br>class field语法为实验性语法</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LoggingButton extends React.Component&#123;</span><br><span class="line">    handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;this is:&#39;, this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class="line">            Click me</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  create React app默认使用该方法。</p>
</li>
<li><p>方法三：回调函数中使用箭头函数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    class LoggingButton extends React.Component &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">        console.log(&#39;this is:&#39;, this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">        &#x2F;&#x2F; 此语法确保 &#96;handleClick&#96; 内的 &#96;this&#96; 已被绑定。</span><br><span class="line">            return (</span><br><span class="line">                &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.handleClick()&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="向事件处理函数传递参数"><a href="#向事件处理函数传递参数" class="headerlink" title="向事件处理函数传递参数"></a>向事件处理函数传递参数</h3><p>当向事件处理函数传递额外参数时，有两种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一：箭头函数</span><br><span class="line">&lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; this.deleteRow(id, e)&#125;&gt;Delete&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F;方法二：Function.prototype.bind</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.deleteRow.bind(this,id)&#125;&gt;Delete&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>箭头函数中，事件对象e必须显式的传递，bind方式，事件对象e及更多参数会被隐式的传递。</p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="使用if渲染"><a href="#使用if渲染" class="headerlink" title="使用if渲染"></a>使用if渲染</h3><p>即if-else语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件)&#123;</span><br><span class="line">    return 元素1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    return 元素2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">let 变量;</span><br><span class="line">if(条件)&#123;</span><br><span class="line">    变量 &#x3D; 元素1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    变量 &#x3D; 元素2;</span><br><span class="line">&#125;</span><br><span class="line">return (变量);</span><br></pre></td></tr></table></figure>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符为JSX中内联条件渲染的方法，通过花括号<code>{}</code>包裹代码。</p>
<h4 id="使用-amp-amp-渲染"><a href="#使用-amp-amp-渲染" class="headerlink" title="使用&amp;&amp;渲染"></a>使用&amp;&amp;渲染</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;条件 &amp;&amp; 表达式&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>true &amp;&amp; expression</code> =&gt; <code>expression</code><br><code>false &amp;&amp; expression</code> =&gt; <code>false</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="line">&lt;h2&gt;</span><br><span class="line">You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">&lt;&#x2F;h2&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; condition ? true expression : false expression&#125;</span><br></pre></td></tr></table></figure>


<h3 id="阻止渲染（隐藏组件）"><a href="#阻止渲染（隐藏组件）" class="headerlink" title="阻止渲染（隐藏组件）"></a>阻止渲染（隐藏组件）</h3><p>若希望组件隐藏，可以让<code>render</code>方法返回<code>null</code>。不进行任何渲染，此种方式不会影响组件的生命周期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function WarningBanner(props) &#123;</span><br><span class="line">  if (!props.warn) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;warning&quot;&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Page extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;showWarning: true&#125;;</span><br><span class="line">    this.handleToggleClick &#x3D; this.handleToggleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      showWarning: !state.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn&#x3D;&#123;this.state.showWarning&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.showWarning ? &#39;Hide&#39; : &#39;Show&#39;&#125;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(1)-基础知识</title>
    <url>/React-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</url>
    <content><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React是一个声明式，高效且灵活的用于构建用户界面的JavaScript库。使用React可以将一些简短、独立的代码片段组合成复杂的UI界面，这些代码片段称为“组件”。</p>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>JSX是JavaScript的语法拓展，可以生成React“元素”。React认为渲染逻辑与其他UI逻辑内在耦合，故其没有采用将标记和逻辑分离在不同文件的方式，而是将他们共同存入“组件”的松散耦合单元中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;JSX语法</span><br><span class="line">&lt;div &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">React.createElement(&#39;div&#39;)</span><br></pre></td></tr></table></figure>

<p>在JSX中可以任意使用JavaScript表达式，只需要用大括号<code>{}</code>括起来。</p>
<a id="more"></a>
<ul>
<li><p>使用<code>{}</code>嵌入元素：可嵌入变量、表达式、函数等。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello,&#123;formatName(user)&#125;&lt;&#x2F;h1&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>&quot;&quot;</code>：将属性值指定为字符串字面量。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;div tabIndex&#x3D;&quot;0&quot;&gt;&lt;&#x2F;div&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>{}</code>：在属性值插入一个JavaScript表达式。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;img src&#x3D;&#123;user.avatarUrl&#125;&gt;&lt;&#x2F;img&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>JSX可以安全的插入用户输入的内容：React DOM渲染输入内容前，默认会进行转义。可以确保在应用中，永远不会注入并非自己明确编写的内容。所有内容渲染之前都被转换成了字符串。此方法可以有效防止XSS（跨站脚本）攻击。</p>
</li>
<li><p><code>React.createElement()</code>：创建React对象，即React元素。描述了用户希望在屏幕上看到的内容。React通过读取这些对象并使用他们来构建DOM以及保持随时更新。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &#123;</span><br><span class="line">    &lt;h1 className&#x3D;&quot;greeting&quot;&gt;</span><br><span class="line">        Hello, world!</span><br><span class="line">    &lt;&#x2F;h1&gt;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">const element &#x3D; React.createElement(</span><br><span class="line">    &#39;h1&#39;,</span><br><span class="line">    &#123;className: &#39;greeting&#39;&#125;,</span><br><span class="line">    &#39;Hello, world!&#39;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;创建对象的结构如下：</span><br><span class="line">const element &#x3D; &#123;</span><br><span class="line">    type: &#39;h1&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        className: &#39;greeting&#39;,</span><br><span class="line">        children: &#39;Hello, world!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意点：</p>
<ol>
<li><p>空元素必须用/结束，如<code>&lt;br /&gt;</code></p>
</li>
<li><p>根元素不能为两个，如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;Hello World!&lt;p&gt;</span><br><span class="line">    &lt;br&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;&lt;p&gt;和&lt;br&#x2F;&gt;为两个根元素，故只能用&lt;div&gt;包起来。</span><br></pre></td></tr></table></figure></li>
<li><p>JSX的属性和方法命名规则都必须为小驼峰，如<code>className</code></p>
</li>
<li><p>if使用<code>&amp;&amp;</code>表示，<code>&amp;&amp;</code>前为条件，后为执行的JSX语句</p>
</li>
<li><p>if-else使用<code>a?b:c</code>，a为条件，是执行b，else执行c</p>
</li>
<li><p>循环语句使用数组的map方法实现，在回调函数里处理每个子元素。为了方便的找出哪个节点有更新，其循环的子元素都必须加唯一id。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.map((number) &#x3D;&gt; </span><br><span class="line">    &lt;listItem key&#x3D;&#123;number.toString()&#125;       &#x2F;&#x2F;key-&gt;唯一id</span><br><span class="line">              value&#x3D;&#123;number&#125; &#x2F;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h3><p>元素是构成React应用的最小模块，是创建开销极小的普通对象。</p>
<p>每一个React元素都是一个JavaScript对象，可以在程序中保存到变量中或作为参数传递。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello, world&lt;&#x2F;h1&gt;;</span><br></pre></td></tr></table></figure>

<p>若要将React元素渲染到根DOM节点root，使用ReactDOM.render()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello, world&lt;&#x2F;h1&gt;;</span><br><span class="line">ReactDOM.render(element, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure>

<p>React元素不可变。一旦被创建就无法更改它的子元素或属性，它代表了某个特定时刻的UI。要修改元素只能通过重新绑定新的元素渲染或通过state修改。</p>
<h3 id="组件及Props"><a href="#组件及Props" class="headerlink" title="组件及Props"></a>组件及Props</h3><p>组件，类似于JavaScript函数，接受任意的入参（props），通过<code>render</code>方法返回用于描述页面展示内容的React元素。</p>
<p>两种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：函数</span><br><span class="line">function Welcome(props)&#123;</span><br><span class="line">    return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：ES6的class</span><br><span class="line">class Welcome extends React.Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Welcome(props)&#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意：组件名称必须使用大写字母开头。</p>
<p>自定义组件可以在其输出（return ）中引入其他组件，即组合组件。</p>
<h4 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h4><p>多层嵌套的组合组件若其中包含可复用的组件，可将组件提取出来，构建可复用的组件库。同样，若组件本身过于复杂，也可将其中的元素提取成组件，构建为可复用的组件。</p>
<blockquote>
<p>注意：组件的props绝不能修改，要像纯函数一样保护props不被修改。</p>
</blockquote>
<p>纯函数：函数不会更改入参，多次调用下相同的入参返回相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;非纯函数</span><br><span class="line">function test(a,b)&#123;</span><br><span class="line">    a +&#x3D; b;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;纯函数</span><br><span class="line">function test(a,b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数组件转换class组件"><a href="#函数组件转换class组件" class="headerlink" title="函数组件转换class组件"></a>函数组件转换class组件</h4><ol>
<li>创建同名<code>ES6 class</code>，继承于<code>React.Component</code>。</li>
<li>添加空的<code>render()</code>方法。</li>
<li>将函数组件的函数体移入<code>render()</code>方法中。</li>
<li>将<code>render()</code>方法中的<code>props</code>改为<code>this.props</code>。</li>
<li>删除空的函数组件。</li>
</ol>
<h3 id="state-amp-生命周期"><a href="#state-amp-生命周期" class="headerlink" title="state&amp;生命周期"></a>state&amp;生命周期</h3><blockquote>
<p>React把组件看作状态机。通过与用户的交互，实现不同的状态，渲染UI，让用户界面和数据保持一致。state与props类似，但state是私有的，完全受控于当前组件。React中，只需更新组件的state，根据新的state重新渲染用户界面。</p>
</blockquote>
<p>使用构造函数初始化<code>this.state</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props)&#123;</span><br><span class="line">    &#x2F;&#x2F;使用super函数将props传递到父类的构造函数中</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;date: new Date()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>render()</code>函数中使用<code>this.state</code>获取state中的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><blockquote>
<p>当组件第一次被渲染到DOM中时，调用<code>componentDidMount()</code>函数=&gt; 挂载(mount)<br>当组件被删除时，调用<code>componentWillUnmount()</code>。=&gt;卸载(unmount)</p>
</blockquote>
<p><strong>调用顺序：</strong></p>
<ol>
<li>当组件传给React.render()时，React调用组件的构造函数constructor()初始化this.state。</li>
<li>React调用render()方法。确定在该页面展示内容。更新DOM渲染输出。</li>
<li>当组件的输出插入到DOM后，调用componentDidMount()方法设置挂载时需运行的内容。</li>
<li>若需更新state，需在挂载内容时使用setState()方法更新state。并重新调用render()渲染更新过的数据，相应的更新DOM。</li>
<li>当组件从DOM移除，React调用componentWillUnmount()方法卸载。</li>
</ol>
<h4 id="state注意事项"><a href="#state注意事项" class="headerlink" title="state注意事项"></a>state注意事项</h4><ol>
<li><p>更新state<br>直接修改<code>state</code>不会重新渲染组件，如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此种修改不会渲染组件</span><br><span class="line">this.state.comment &#x3D; &quot;Hello&quot;; </span><br><span class="line">&#x2F;&#x2F;使用setState才能达到更新目的</span><br><span class="line">this.setState(&#123;comment: &#39;Hello&#39;&#125;);</span><br></pre></td></tr></table></figure>
<p> 构造函数是唯一可以给<code>this.state</code>赋值的地方。</p>
</li>
<li><p>state更新可能异步<br> <code>this.props</code>和<code>this.state</code>可能是异步更新的，故如下操作无法更新内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">    counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;若想更新，可让setState()接受函数，而非对象。</span><br><span class="line">this.setState((state, props) &#x3D;&gt; (&#123;</span><br><span class="line">    counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br><span class="line">&#x2F;&#x2F;不使用匿名箭头函数，使用普通函数也可</span><br></pre></td></tr></table></figure>
</li>
<li><p>state合并更新<br> 出于性能考虑，React可能会把多个<code>setState()</code>合并成一个调用。并将提供的对象合并到当前的<code>state</code>，进行部分替换，而非全局覆盖。<br> 如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">        posts: [],</span><br><span class="line">        comments: []</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;更新posts时，只会替换posts部分，comments不变。更新comments同理。</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    fetchPosts().then(response &#x3D;&gt; &#123;</span><br><span class="line">        this.setState(&#123;posts: response.posts&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数据自顶向下<br>无论父组件还是子组件都无法知道某组件是否有状态，且不关心是函数组件还是class组件。除了拥有并设置了state的组件，其他组件都无法访问。但组件可以选择把它的state作为props向下传递给它的子组件。从该state派生的任何数据或UI只能影响树中低于它的组件。<br>每个组件都是真正独立的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离与SPA的理解</title>
    <url>/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E4%B8%8ESPA%E7%9A%84%E7%90%86%E8%A7%A3.html</url>
    <content><![CDATA[<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><h3 id="一些概念理解"><a href="#一些概念理解" class="headerlink" title="一些概念理解"></a>一些概念理解</h3><ul>
<li>前端：在浏览器端运行的内容为前端。通常是用HTML+CSS+JS来实现的，如APP、小程序、H5等。</li>
<li>后端：在服务器端运行的内容为后端。如Java、C、Python、PHP等</li>
<li>静态页面：网页中没有程序代码，仅HTML。一般静态页面一旦生成，内容就不会被改变。</li>
<li>动态页面：网页文件除了HTML还包括一些程序代码使浏览器可以与服务器交互，随用户交互的不同请求动态的生成网页内容。</li>
<li>网页的静态化：将动态数据都提前生成为静态的html页面，避免从数据库取数的时间。</li>
<li>DOM：文档对象模型（Document Object Model），一种将HTML/XML文档组织成对象模型（DOM树）的建模过程。</li>
<li>虚拟DOM：DOM树结构在内存里的映射</li>
</ul>
<a id="more"></a>
<h3 id="前后端不分离架构"><a href="#前后端不分离架构" class="headerlink" title="前后端不分离架构"></a>前后端不分离架构</h3><p>传统的不分离架构的设计大致为：</p>
<ol>
<li>浏览器发出请求。</li>
<li>服务器收到请求，从数据库取出数据后，生成渲染整个页面发送给浏览器。</li>
<li>浏览器将页面展示给用户。</li>
<li>以上步骤循环进行。</li>
</ol>
<p>此种方式缺点是不但无法将前后端开发人员的职能分开（或要求开发人员掌握全栈），且在技术层面，每一次请求，要发送的内容数量很大，包括整个HTML、CSS以及JavaScript。</p>
<p>优点是服务器可以缓存整个页面，页面静态化或访问时可以不用再次访问数据。</p>
<p>若需要提升性能，要么提升服务器响应时间，要么压缩传输的内容。相比之下，压缩传输的内容的优化更有效。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>不分离架构需传输的内容太多，是否可以只传输变化的内容。因此引出了Ajax。</p>
<p>Ajax只传输数据，不传输整个网页。此时处于一种半分离的状态。设计大概为：</p>
<ol>
<li>浏览器发出请求。</li>
<li>HTML中的JS代码以Ajax方式向后台接口请求数据。</li>
<li>后台接口返回JSON数据</li>
<li>页面解析Json数据，通过DOM渲染页面展示给用户。</li>
</ol>
<p>此种方式前端不会嵌入过多后台代码，前端专注自己的开发，不依赖后段。</p>
<p>缺点是JS会出现大量冗余。若JSON数据量大，渲染仍然会花费很长时间。若业务复杂，一个页面需要发起多次http请求才能渲染完整个页面。</p>
<h3 id="前后端分离架构"><a href="#前后端分离架构" class="headerlink" title="前后端分离架构"></a>前后端分离架构</h3><p>由此产生前后端分离架构，前端只负责view和controller层，后段只负责model层、业务处理和数据持久化。前后端只通过JSON交流。</p>
<ol>
<li>浏览器发出请求。</li>
<li>Web服务器解析请求，经过转换，发送给各个相关的后端服务器。</li>
<li>后端服务器返回处理过的业务数据。</li>
<li>Web服务器将返回的业务数据填入HTML模版发送给浏览器。</li>
<li>浏览器展示页面。</li>
</ol>
<p>前后端人员约定好接口后，就可以各自开发测试。前端不用关心业务处理，后端也不用关心前端界面。代码管理、服务部署也可以分别管理。</p>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>SPA（Single Page Web Applications）单页应用，是实践前后端分离架构最好的方案。它是一种只需要将单个页面加载到浏览器中的Web应用程序。</p>
<p>工作时，在Web页面初始化时，就加载完相应的HTML、CSS、JS内容，以后不会因用户的操作而进行页面的重新加载或跳转。当用户交互时，只通过Javascript动态变换HTML的内容，即进行部分内容的动态切换和替换。</p>
<p>优点：用户体验快，避免不必要的跳转和页面的重复渲染，加快了对数据的刷新，对服务器压力小。且共用一套后端代码即可同时应用于Web界面、手机、平板等多种客户端。</p>
<p>缺点：SEO难度较高，页面的前进后退管理复杂，且初次加载时可能耗时会较长。</p>
<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><h4 id="动态切换视图"><a href="#动态切换视图" class="headerlink" title="动态切换视图"></a>动态切换视图</h4><ul>
<li><p>通过JavaScript的<code>$().replacewith()</code>等方法实现切换。</p>
</li>
<li><p>通过URL路由机制，从URL路由中的hashtag获取信息，再通过<code>window.location.hash.slice()</code>方法实现页面内容切换</p>
</li>
</ul>
<h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><ol>
<li>通过ajax获取数据</li>
<li>载入前占位提示。由于从服务器端获取数据需要时间，则设置一个占位符，如loading样式、文字提示，表示数据正在载入，请等待。</li>
<li>异步操作(取数据渲染页面)：await callback promise</li>
</ol>
<h4 id="模版替换"><a href="#模版替换" class="headerlink" title="模版替换"></a>模版替换</h4><ol>
<li>JSON数据转换：JSON是字符串，需要将它转换为DataObject使用，jQuery会自动解析，其他的库需要自己解析</li>
<li>模版替换：数据转换后就发给模版，将对应内容进行替换，得到HTML </li>
</ol>
<h4 id="双向绑定和动态渲染"><a href="#双向绑定和动态渲染" class="headerlink" title="双向绑定和动态渲染"></a>双向绑定和动态渲染</h4><p>服务器端渲染：一次请求渲染一次，新的数据变更在新的请求后渲染。</p>
<p>前端SPA渲染：用户修改数据，相应的数据要同步修改，故需要用到事件机制通知。修改数据后触发事件机制，事件绑定的函数检查修改的数据，重新通过模版渲染页面，填回DOM对应的地方，即做到自动更新。</p>
<p>问题：实现时，每次修改可能会渲染整个页面，效率十分低。</p>
<p>解决：只渲染修改的部分。</p>
<h5 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h5><blockquote>
<p>调用虚拟DOM实现动态渲染修改的内容。</p>
</blockquote>
<p>每次修改完内容，按新内容在内存里构建一个新的虚拟DOM树， 与旧的DOM树比较，检查节点变动情况，再到真实的DOM树中，修改对应的节点，完成渲染更新。</p>
<h4 id="组件化和重用"><a href="#组件化和重用" class="headerlink" title="组件化和重用"></a>组件化和重用</h4><p>支持自定义标签，在重用时只需要关注内容，不需要关心具体结构。若需要变动，只需要调整自定义标签的模版，那整个页面使用的自定义标签都会自动更新。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>SPA</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式学习笔记</title>
    <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</url>
    <content><![CDATA[<p>正则表达式定义了字符串的模式，可以用来搜索、编辑、处理文本。用<code>//</code>包围一个正则表达式</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>测试字符串内模式（数据验证）</li>
<li>替换文本</li>
<li>基于模式匹配提取子字符串</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式由普通字符以及特殊字符（元字符）组成。</p>
<a id="more"></a>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>包括没有显式指定为元字符的所有可打印、不可打印字符。（包括所有大小写字母、数字、标点符号、其他符号）</p>
<ul>
<li>不可打印字符：匹配包括换页符<code>\f</code>、换行符<code>\n</code>、回车符<code>\r</code>、空白字符<code>\s</code>、制表符<code>\t</code>等字符。</li>
</ul>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>类似关键字，匹配特殊字符时需要先使用<code>\</code>将其转义。</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串中的开始位置，若放在方括号表达式中使用，表示不接受该方括号表达式中的字符集合</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾。若设置了<code>RegExp</code>对象的<code>Multiline</code>属性，则也匹配<code>\n</code>和 <code>\r</code></td>
</tr>
<tr>
<td>()</td>
<td>标记子字符串的开始和结束</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式0次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式1次或多次 （至少要有一次）</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式0次或1次（最多1次）</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符\n之外的所有单字符</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为特殊字符或向后引用或转义符或原义字符</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择</td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>用来指定正则表达式中一个给定组件必须出现多少次才能满足匹配，共6种：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式0次或多次，等价于<code>{0,}</code>，如<code>/zo*/</code>匹配<code>z</code>、<code>zoo</code>、<code>zoooo</code></td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式1次或多次 （至少要有一次），如<code>/zo+/</code>匹配<code>zo</code>、<code>zoo</code>，不匹配<code>z</code></td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式0次或1次（最多1次），如<code>/zo?/</code>，只能匹配<code>z</code>、<code>zo</code>，不匹配<code>zoooo</code>等</td>
</tr>
<tr>
<td>{n}</td>
<td><code>n</code>为非负整数。匹配前面的子表达式n次，如<code>o{2}</code>匹配<code>zoo</code>、<code>book</code>，不匹配<code>box</code></td>
</tr>
<tr>
<td>{n,}</td>
<td><code>n</code>为非负整数。至少匹配前面的子表达式n次，如<code>o{2,}</code>匹配<code>zoo</code>、<code>boooook</code>，不匹配<code>box</code></td>
</tr>
<tr>
<td>{n,m}</td>
<td><code>n</code>、<code>m</code>为非负整数，且<code>n&lt;=m</code>。最少匹配前面的子表达式n次，且最多匹配前面的子表达式m次，如<code>o{2,4}</code>匹配<code>zoo</code>、<code>boook</code>，不匹配<code>box</code>、<code>booooox</code></td>
</tr>
</tbody></table>
<blockquote>
<p>限定符出现在范围表达式之后，故应用于整个范围表达式</p>
</blockquote>
<h4 id="非贪婪限定符实现"><a href="#非贪婪限定符实现" class="headerlink" title="非贪婪限定符实现"></a>非贪婪限定符实现</h4><p><code>*</code>和<code>+</code>限定符都是贪婪的，即会尽可能多的匹配文字。若<strong><em>在其后加上?就会实现非贪婪或最小匹配</em></strong>。</p>
<p>如表达式<code>&lt;p&gt;Hello World&lt;p&gt;</code></p>
<ul>
<li>使用<code>/&lt;.*&gt;/</code>匹配，则匹配到的内容为整个表达式<code>&lt;p&gt;Hello World&lt;p&gt;</code></li>
<li>使用<code>/&lt;.*?&gt;/</code>匹配，则只匹配到<code>&lt;p&gt;</code></li>
</ul>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符将正则表达式固定到某位置，让其出现在行首行尾或某单词开头、内部、结尾。用来描述字符串或单词的边界。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串中的开始位置，即匹配一行文本开始处的文本。若放在方括号表达式中使用，表示不接受该方括号表达式中的字符集合</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾，即匹配一行文本结束处的文本。若设置了<code>RegExp</code>对象的<code>Multiline</code>属性，则也匹配<code>\n</code>和 <code>\r</code></td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置。如<code>/\bCha/</code>匹配单词Chapter开头的三个字符。<code>/ter\b/</code>匹配单词Chapter结尾的三个字符</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配，如<code>/\Bapt/</code>匹配Chapter中间的apt，但不匹配aptitude开头的apt，因为此apt出现在单词的边界</td>
</tr>
</tbody></table>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p><code>()</code>：可以将选择项括起来，但其相关的匹配会被缓存，可以使用<code>?:</code>放在第一个选项消除此缓存的作用<br><code>|</code>：分割相邻的选择项。</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>反向引用提供查找文本中两个相同的相邻单词的匹配项的能力。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;Is is the cost of of gasoline going up up&quot;;</span><br><span class="line">var patt1 &#x3D; &#x2F;\b([a-z]+) \1\b&#x2F;ig;</span><br><span class="line">document.write(str.match(patt1));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>\b([a-z]+)</code>:匹配一个或多个字母</li>
<li><code>\1\b</code>:引用第一个子匹配项，即单词的第二个匹配项正好由第一个子匹配项匹配。</li>
<li>引用单词边界符确保只检测整个单词</li>
<li><code>i</code>:忽略大小写</li>
<li><code>g</code>:指定将该表达式应用到输入字符串能够查找到的尽可能多的匹配</li>
</ul>
<p>还可以将url分解为其组件，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;http:&#x2F;&#x2F;www.runoob.com:80&#x2F;html&#x2F;html-tutorial.html&quot;;</span><br><span class="line">var patt1 &#x3D; &#x2F;(\w+):\&#x2F;\&#x2F;([^&#x2F;:]+)(:\d*)?([^# ]*)&#x2F;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(\w+)</code>：<strong>\w等价于[a-zA-Z0-9_]，匹配下划线、所有字母和数字。</strong>该表达式表示匹配url的协议部分，即http。</li>
<li><code>:\/\/</code>：即http后的://</li>
<li><code>([^/:])</code>：匹配非<code>:</code>和<code>/</code>后的一个或多个字符，即url地址部分。</li>
<li><code>(:\d*)?</code>：<strong>\d等价于[0-9]，表示匹配所有的数字</strong>。该表达式表示匹配以:开头的0个或多个数字，即url端口号部分。<code>?</code>表示该端口号部分只匹配0次或1次</li>
<li><code>([^# ]*)</code>：表示匹配非<code>#</code>或<code>空格</code>字符的任何字符序列，即匹配url的指定路径和页信息。</li>
</ul>
<p>对正则表达式模式两边添加()会将相关匹配存储到一个临时缓冲区中，所捕获到的每个子匹配都按在正则表达式模式中从左到右出现的顺序存储，从1开始，最多存储99个捕获的子表达式。<br>可以使用非捕获元字符来重写捕获，忽略对相关匹配的保存。</p>
<h4 id="非捕获元"><a href="#非捕获元" class="headerlink" title="非捕获元"></a>非捕获元</h4><p><code>?:</code>：消除圆括号相关匹配缓存的副作用<br><code>?=</code>：正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来搜索字符串。<br><code>?!</code>：负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>正则表达式相同优先级的从左到右计算，不同优先级的先高后低。</p>
<p>下表表示优先级由高至低：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(),(?:),(?=),[]</td>
<td>圆括号和方括号</td>
</tr>
<tr>
<td>*,+,?,{n},{n,},{n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^,$,以开头的\元字符、字符</td>
<td>定位符和序列</td>
</tr>
<tr>
<td>｜</td>
<td>替换、或操作</td>
</tr>
</tbody></table>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><h3 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h3><p>模式是正则表达式最基本的元素，是一组描述字符串特征的字符。</p>
<p><code>^the</code>: 匹配以the开头的字符串。如匹配<code>the book is over there</code>，不匹配<code>get the book</code>。</p>
<p><code>book$</code>: 匹配以book结尾的字符串。如匹配<code>there is a book</code>，不匹配<code>the book is on the table</code>。</p>
<p><code>^book$</code>: 精准匹配book，只匹配字符串<code>book</code>。</p>
<p><code>book</code>: 与任何包含book的字符串匹配。</p>
<p>若需要匹配转义字符，则需要以<code>\</code>开头，如<code>^\t</code>，匹配以制表符开头的字符串。</p>
<h3 id="字符簇"><a href="#字符簇" class="headerlink" title="字符簇"></a>字符簇</h3><p>字符簇一组字符的集合。用方括号<code>[]</code>扩起来。如<code>[AaEeIiOoUu]</code>匹配<strong>一个元音字符</strong>。</p>
<p>用<code>-</code>连接可表示<strong>一个字符</strong>的范围。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[a-z]：所有小写字母</span><br><span class="line">[A-Z]：所有大写字母</span><br><span class="line">[a-zA-Z]：所有字母</span><br><span class="line">[0-9]：所有数字</span><br></pre></td></tr></table></figure>

<p>方括号内使用<code>^</code>表示非。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[^0-9]：除0-9所有字符</span><br><span class="line">[^a-z]：除a-z所有字符</span><br></pre></td></tr></table></figure>

<p>特殊字符<code>.</code>表示出了新行之外的所有字符。</p>
<h3 id="重复出现"><a href="#重复出现" class="headerlink" title="重复出现"></a>重复出现</h3><p>使用<code>{}</code>确定重复出现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;n&#125;：出现n次</span><br><span class="line">&#123;n,&#125;：出现至少n次</span><br><span class="line">&#123;n,m&#125;：至少出现n次但不超过m次</span><br><span class="line">?：相当于&#123;0,1&#125;，出现0次或1次</span><br><span class="line">+：&#123;1,&#125;，至少出现1次</span><br><span class="line">*：&#123;0,&#125;，出现0次或多次</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript正则表达式RegExp对象"><a href="#JavaScript正则表达式RegExp对象" class="headerlink" title="JavaScript正则表达式RegExp对象"></a>JavaScript正则表达式RegExp对象</h2><p>RefExp是JavaScript的正则表达式对象。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var patt &#x3D; new RegExp(pattern,modifiers);</span><br><span class="line"></span><br><span class="line">var patt &#x3D; &#x2F;pattern&#x2F;modifiers;</span><br></pre></td></tr></table></figure>

<ul>
<li>patterm：正则表达式模式</li>
<li>modifiers：正则表达式修饰符<ul>
<li>i：不区分大小写</li>
<li>g：执行全文搜索</li>
</ul>
</li>
</ul>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var patt &#x3D; new RegExp(&quot;^[abc]&quot;);</span><br><span class="line"></span><br><span class="line">var patt &#x3D; &#x2F;is&#x2F;g;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>test()：搜索字符串指定的值，根据结果返回<code>true</code>或<code>false</code>。</p>
<p>exec()：检索字符中指定值。找到返回该值，未找到返回null。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB安装手册</title>
    <url>/MongoDB%E5%AE%89%E8%A3%85%E6%89%8B%E5%86%8C.html</url>
    <content><![CDATA[<p>在学习Node.js的过程中需要使用Mongoose，故安装MongeDB进行使用。但过程中踩了不少坑。以下安装步骤是多次踩坑后可以正常运行的版本。</p>
<p>安装环境：Mac OS 10.15.3</p>
<h2 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h2><h3 id="方法1-使用官网安装包"><a href="#方法1-使用官网安装包" class="headerlink" title="方法1:使用官网安装包"></a>方法1:使用官网安装包</h3><p><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">官网安装包下载链接</a></p>
<a id="more"></a>
<p>选择对应的操作系统和包格式点击下载即可。</p>
<blockquote>
<p>此方法个人在下载时一直报错，可能是因为浏览器中安装的下载插件问题，故最后未采用此方式下载。</p>
</blockquote>
<h3 id="方法2-获取官网下载链接使用命令行下载"><a href="#方法2-获取官网下载链接使用命令行下载" class="headerlink" title="方法2:获取官网下载链接使用命令行下载"></a>方法2:获取官网下载链接使用命令行下载</h3><p>在官网下载页面复制下载链接：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdealyx2fnj317s0o6acd.jpg" alt="复制官网下载链接"></p>
<ol>
<li><p>在iterm中使用命令行下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% sudo curl -O https:&#x2F;&#x2F;fastdl.mongodb.org&#x2F;osx&#x2F;mongodb-macos-x86_64-4.2.5.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压后，将文件夹重命名为mongodb（<strong><em>重要！！！</em></strong>）</p>
</li>
</ol>
<blockquote>
<p>此方法下载成功且无任何报错</p>
</blockquote>
<h3 id="方法3-使用brew下载"><a href="#方法3-使用brew下载" class="headerlink" title="方法3:使用brew下载"></a>方法3:使用brew下载</h3><blockquote>
<p>确保自己的开发环境中已安装brew</p>
<p>brew安装教程<a href="https://zhuanlan.zhihu.com/p/99104545" target="_blank" rel="noopener">点击此进行跳转</a></p>
</blockquote>
<p>在iterm中使用命令行(<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">以下步骤参考于MongoDB官方下载文档</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% brew tap mongodb&#x2F;brew</span><br><span class="line"></span><br><span class="line">Macbook% brew install mongodb-community@4.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一次使用brew下载安装包没有没有按官网的步骤下载，参考了其他大佬的教程，最终没有安装成功，出现了很多奇怪的问题，可能是版本不太一样。<br>后来使用此方法进行下载，但下载后安装遇到了一些问题，初步怀疑是第一次用brew安装后的一些操作没有卸载整理完，故安装失败。</p>
</blockquote>
<h2 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol>
<li><p>使用命令行打开环境变量文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% open -e .bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>将安装MongoDB的目录下bin的地址添加到环境变量中（<strong><em>此步骤一定要配置对！！重要！！！否则后来可能会无法打开Mongo</em></strong>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin:$PATH</span><br><span class="line">&#x2F;&#x2F;保存文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>使配置生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% source .bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证是否已安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% mongod -version</span><br></pre></td></tr></table></figure>

<p> 出现以下信息，则说明安装成功：</p>
<p> <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeb7a9ou9j30ni07yq61.jpg" alt="配置成功信息"></p>
</li>
</ol>
<h3 id="创建log和data目录"><a href="#创建log和data目录" class="headerlink" title="创建log和data目录"></a>创建log和data目录</h3><blockquote>
<p>很多教程都表示要使用<code>mkdir -p /data/db</code>创建目录，但使用各个方法都无法创建成功，故以下自己创建目录</p>
</blockquote>
<ol>
<li><p>在MongoDB的安装目录下新建log目录和data目录（本人安装目录为/usr/local/mongodb，该目录就是之前解压后重命名的文件夹）<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdebdsqowzj30nm03640e.jpg" alt="创建目录"></p>
</li>
<li><p>进入/usr/local/etc目录打开mongod.conf文件，修改log路径和data路径为步骤1中创建的目录地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  path: &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;mongo.log</span><br><span class="line">  logAppend: true</span><br><span class="line">storage:</span><br><span class="line">  dbPath: &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data</span><br><span class="line">net:</span><br><span class="line">  bindIp: 127.0.0.1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有的教程直接进行第三步运行，但我直接运行第三步后配置并没有改变，出现了一些问题，故还是增加了第二步</p>
</blockquote>
</li>
<li><p>运行MongoDB服务</p>
<blockquote>
<p>MongoDB默认数据保存的地址为/data/db，但我一直没创建成功，故修改了地址后，在启动服务时指定dbpath的位置。由于做了第二步也可不指定，以防万一。</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% mongod --dbpath data --logpath log&#x2F;mongod.log --logappend</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;--logappend:后台运行</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动后，当前终端不要关闭。</p>
</blockquote>
<p> <strong>遇到的问题：</strong></p>
<p> 在运行MongoDB服务时，有以下报错：</p>
<blockquote>
<p>NETWORK  [initandlisten] Failed to unlink socket file /tmp/mongodb-27017.sock Permission denied</p>
</blockquote>
<ul>
<li><p>原因查询:</p>
<p>  在mongodb目录下使用命令<code>ls -lat /tmp/mongodb-27017.sock</code>查看权限，显示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MacBook% srwx------  1 root  wheel  0  4  1 12:27 &#x2F;tmp&#x2F;mongodb-27017.sock</span><br></pre></td></tr></table></figure></li>
<li><p>解决办法：使用命令<code>sudo rm /tmp/mongodb-27017.sock</code>删除该文件即可。</p>
</li>
</ul>
</li>
<li><p>启动数据库<br> 新打开一个终端，输入mongo连接数据库。<br> 若出现<code>command not found</code>错误，直接使用命令<code>source .bash_profile</code>再次使环境变量生效，再使用mongo连接即可解决。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>MongoDB</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(5)-Express基础</title>
    <url>/Node-js-5-Express.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Express 是一个简洁灵活的 Node.js Web 应用框架，其特点为：</p>
<ul>
<li><p>可以设置中间件来响应 HTTP 请求</p>
</li>
<li><p>定义了路由表用于执行不同的 HTTP 请求动作</p>
</li>
<li><p>可以通过向模板传递参数来动态渲染 HTML 页面</p>
<a id="more"></a>

</li>
</ul>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>请求发送到服务器，服务端在监听处理请求时的过程很复杂，若将这些负责的业务拆分成子部分，则每个子部份就是一个中间件，类似一个流水线工作流程。</p>
<blockquote>
<p>function(req, res, next)</p>
</blockquote>
<blockquote>
<p>若符合 function 中的条件，则执行对应的 end()函数结束此次路由，若不符合条件，则执行 next()函数进入 function2</p>
</blockquote>
<blockquote>
<p>类同与异步的 promise.then().then()</p>
</blockquote>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图参考 easy 老师方糖全站课堂内容：</a></p>
<p><img src="https://i.loli.net/2020/03/16/amscOKBu1qZRNSD.jpg" alt="中间件"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var express &#x3D; require(&#39;express&#39;);</span><br><span class="line"> var app &#x3D; express();</span><br><span class="line"></span><br><span class="line"> app.get(&#39;&#x2F;&#39;, function(req, res, next) &#123;&#x2F;&#x2F;function(req, res, next)为中间件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前中间件函数没有结束请求&#x2F;响应循环，调用next(), 将控制权传递给下一个中间件函数继续往下处理，否则页面到此会被挂起</span><br><span class="line">    next();&#x2F;&#x2F;有next()才会往下进行下一个中间件，否则一直被挂起</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;next()代表的下一个中间件</span><br><span class="line">app.get(&#39;&#x2F;end&#39;, function(req, res) &#123;</span><br><span class="line">    &#x2F;&#x2F;此时没有next(),故到此结束</span><br><span class="line">    res.send(&#39;-----END-----&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h3 id="错误中间件"><a href="#错误中间件" class="headerlink" title="错误中间件"></a>错误中间件</h3><blockquote>
<p>function(err, req, res, next)</p>
</blockquote>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图参考 easy 老师方糖全站课堂内容：</a></p>
<p><img src="https://i.loli.net/2020/03/16/AKTki9687StbFu5.jpg" alt="错误中间件"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(function(err, req, res, next) &#123;&#x2F;&#x2F;function(err, req, res, next)为错误处理中间件</span><br><span class="line">  console.error(err.stack);</span><br><span class="line">  res.status(500).send(&#39;Something broke!&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;另一种写法</span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">  next(new Error(&quot;XXX error&quot;));&#x2F;&#x2F;next()将请求交给新建的错误处理中间件。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="单文件-Express-app"><a href="#单文件-Express-app" class="headerlink" title="单文件 Express app"></a>单文件 Express app</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line">const app &#x3D; express()</span><br><span class="line">const port &#x3D; 3000</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; res.send(&#39;Hello World!&#39;))</span><br><span class="line"></span><br><span class="line">app.listen(port, () &#x3D;&gt; console.log(&#96;Example app listening on port &#96;+ port));</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/16/Of4DapRuvUVq5mE.jpg" alt="output"></p>
<h2 id="使用-Express-generate-生成-Express-项目"><a href="#使用-Express-generate-生成-Express-项目" class="headerlink" title="使用 Express generate 生成 Express 项目"></a>使用 Express generate 生成 Express 项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Node.js v8.2.0直接使用npx命令使用生成器</span><br><span class="line">$ npx express-generator</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;之前版本先安装生成器包</span><br><span class="line">$ npm install -g express-generator</span><br><span class="line">$ express</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成项目myapp</span><br><span class="line">&#x2F;&#x2F;将view引擎设置成pug，jade已不被支持</span><br><span class="line">$ express --view&#x3D;pug myapp</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行</span><br><span class="line">&#x2F;&#x2F;安装依赖</span><br><span class="line">$ cd myapp</span><br><span class="line">$ npm install</span><br><span class="line">&#x2F;&#x2F;运行</span><br><span class="line">$ set DEBUG&#x3D;myapp:*</span><br><span class="line">$ npm start</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打开页面http:&#x2F;&#x2F;localhost:3000&#x2F;查看结果</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/16/BNmsdbH4D3yvjqU.jpg" alt="express"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(4)-模块及文件系统</title>
    <url>/Node-js-4-%E6%A8%A1%E5%9D%97%E5%8F%8A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>模块是 Node.js 的基本组成部分，文件和模块一一对应，即一个 Node.js 文件就是一个模块。</p>
<blockquote>
<p><code>exports</code>：模块公开的接口，即封装模块的关键字</p>
</blockquote>
<blockquote>
<p><code>require</code>：从外部获取一个模块的接口，即调用模块的关键字</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入当前目录下的hello文件</span><br><span class="line">var hello &#x3D; require(&quot;.&#x2F;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;使用exports将world作为模块访问的接口</span><br><span class="line">exports.world&#x3D;function()&#123;</span><br><span class="line">    console.log(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <a id="more"></a>
<h3 id="require-调用模块机制"><a href="#require-调用模块机制" class="headerlink" title="require 调用模块机制"></a>require 调用模块机制</h3><p><img src="https://s1.ax1x.com/2020/03/16/8GZTTx.jpg" alt="require"></p>
<blockquote>
<p>其中，</p>
</blockquote>
<blockquote>
<p>原生模块：Node.js 自带的模块，如 http、fs 等。</p>
</blockquote>
<blockquote>
<p>文件模块：某目录下的文件，使用前必须先使用<code>exports</code>封装模块</p>
</blockquote>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br></pre></td></tr></table></figure>

<p>文件模块中所有方法均有异步同步两种，异步方法的最后一个参数为回掉函数，第一个参数包含了错误信息。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步读取</span><br><span class="line">fs.readFile(&#39;fs.txt&#39;, function (err, data) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;异步: &quot; + data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步读取</span><br><span class="line">var data &#x3D; fs.readFileSync(&#39;fs.txt&#39;);</span><br><span class="line">console.log(&quot;同步: &quot; + data.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;------END------&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/16/8Gmoi6.jpg" alt="output"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(3)-回调与事件</title>
    <url>/Node-js-3-%E5%9B%9E%E8%B0%83%E4%B8%8E%E4%BA%8B%E4%BB%B6.html</url>
    <content><![CDATA[<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>回调是 Node.js 异步编程的直接体现。回调函数在完成任务后就会被调用。Node 的所有 API 都支持回调函数。回调函数是一种非阻塞的方式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1(value,callback1,callback2,...)&#123;&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h3><blockquote>
<p>进程：系统中正在运行的一个应用程序，是资源分配的最小单位。</p>
</blockquote>
<blockquote>
<p>线程：系统分配处理器时间资源的最小单位，程序执行的最小单位。</p>
</blockquote>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><blockquote>
<p>1.进程包含一个或多个线程。</p>
</blockquote>
<blockquote>
<p>2.进程=线程+内存+文件/网络句柄</p>
</blockquote>
<blockquote>
<p>3.线程=栈+程序计数器+线程独立内存 TLS</p>
</blockquote>
<blockquote>
<p>4.一个程序至少有一个进程，一个进程至少有一个线程，其第一个线程即为此进程的主线程。</p>
</blockquote>
<blockquote>
<p>5.一个线程可以创建和撤销另一个线程，同一个进程的多个线程可以并发执行。</p>
</blockquote>
<h3 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h3><blockquote>
<p><strong>同步、异步关注应用层，阻塞、非阻塞更多针对进程和线程而谈</strong></p>
</blockquote>
<blockquote>
<p>同步：发送方发送请求之后，需要等接收方发回响应后才接着发。</p>
</blockquote>
<blockquote>
<p>异步：发送方发送请求后，不等待接收方响应请求，继续发送下个请求。</p>
</blockquote>
<blockquote>
<p>阻塞调用：调用结果返回之前，当前线程会被挂起，调用线程在获得结果后才会返回数据。</p>
</blockquote>
<blockquote>
<p>非阻塞调用：调用结果返回之前，当前线程也不会被挂起，而是立刻返回执行下一个调用。</p>
</blockquote>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>进程通信方面，同步、异步和阻塞、非阻塞基本是同义词，发送方阻塞/非阻塞与接收方阻塞/非阻塞互不影响。</p>
</li>
<li><p>I/O 系统调用层面，非阻塞 I/O 系统调用和异步 IO 系统调用都不会阻塞进程，但非阻塞 I/O 系统调用 read()立即返回的是可以立即拿到的数据，完整或不完整的结果或空值都可；而异步 I/O 系统调用 read()返回的结果必须是完整的。</p>
</li>
<li><p>非阻塞 I/O 系统调用可用来实现线程级别的 I/O 并发，与通过多线程实现的 I/O 并发相比，可减少内存消耗及进程切换的开销。</p>
</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote>
<p>Node.js 是单进程单线程的应用程序，但通过 V8 引擎提供的异步执行回调接口，可以处理大量的并发。</p>
</blockquote>
<blockquote>
<p>Node.js 所有的事件机制，都通过观察者模式实现。其单线程类似进入一个<code>while(true)</code>的事件循环，知道没有事件观察者退出，每个异步事件都生成一个事件观察者，若有事件发生就调用该回调函数。</p>
</blockquote>
<blockquote>
<p>观察者模式：其定义了对象的一对多依赖，当一个对象改变，所有依赖它的观察者都会收到通知并自动更新。</p>
</blockquote>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Node.js 使用事件驱动模型。当 web server 收到请求，就将他关闭放到任务队列中，然后服务下一个 web 请求，通过先进先出的原则，任务队列中的事件会被放到调用栈上进行处理（若为非阻塞 I/O 操作，则直接调用栈执行完毕，若为文件或其他数据库等需长时间的操作，则会被放入 Libuv 处理，当前任务挂起，处理下一个任务），当此请求处理完成，它会将结果重新放回任务队列，当到达队列开头，此处理结果被返回给用户（<strong>非阻塞 I/O</strong>或<strong>事件驱动 I/O</strong>）</p>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图 Node.js 工作流程源自 easy 老师方糖全站课堂（超值！！买买买！！！）：</a></p>
<p><a href="https://imgchr.com/i/83rcH1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/15/83rcH1.md.jpg" alt="node.js"></a></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li>事件驱动程序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var events &#x3D; require(&quot;events&quot;);</span><br><span class="line">var eventEmitter &#x3D; new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">var connectHandler &#x3D; function connected() &#123;</span><br><span class="line">  console.log(&quot;Connect Success!!&quot;);</span><br><span class="line">  &#x2F;&#x2F;触发data_received事件</span><br><span class="line">  eventEmitter.emit(&quot;data_received&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;绑定事件处理</span><br><span class="line">eventEmitter.on(&quot;connection&quot;, connectHandler);</span><br><span class="line">&#x2F;&#x2F;绑定data_received事件</span><br><span class="line">eventEmitter.on(&quot;data_received&quot;, function() &#123;</span><br><span class="line">  console.log(&quot;data received success!!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;触发connection事件</span><br><span class="line">eventEmitter.emit(&quot;connection&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;------END------&quot;);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/83ryu9.jpg" alt="event"></p>
<ol start="2">
<li>文件读入</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&quot;fs.txt&quot;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&quot;------ERROR------&quot;);</span><br><span class="line">    console.log(err.stack);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&quot;------DATA------&quot;);</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;------END------&quot;);</span><br></pre></td></tr></table></figure>

<p>运行成功：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/83rrjJ.jpg" alt="fs1"></p>
<p>运行失败：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/83r6BR.jpg" alt="fs2"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(2)-REPL(交互式解释器)</title>
    <url>/Node-js-2-REPL-%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%A7%A3%E9%87%8A%E5%99%A8.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>REPL 表示一个电脑环境类似 Windows 的 cmd 或 powershell 终端，Unix/Linux 的 shell。可进行一些读取、执行、打印、循环操作。</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$node    &#x2F;&#x2F;进入node REPL</span><br><span class="line">&gt; 1+6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; x&#x3D;100</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">&gt; var y&#x3D;50</span><br><span class="line">undifined</span><br><span class="line"></span><br><span class="line">&gt; console.log(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<h3 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var x&#x3D;0;</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&gt; while(x&lt;6)&#123;</span><br><span class="line">... x++;        &#x2F;&#x2F;...为换行，node会自动检测是否为连续的表达式</span><br><span class="line">... console.log(&quot;x:&quot;+x);</span><br><span class="line">...&#125;</span><br><span class="line">x:1</span><br><span class="line">x:2</span><br><span class="line">x:3</span><br><span class="line">x:4</span><br><span class="line">x:5</span><br><span class="line">x:6</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<h3 id="下划线变量"><a href="#下划线变量" class="headerlink" title="下划线变量"></a>下划线变量</h3><blockquote>
<p>node 中下划线_可代表上一个表达式的结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var x&#x3D;5;</span><br><span class="line">undefined</span><br><span class="line">&gt; var y&#x3D;10;</span><br><span class="line">undefined</span><br><span class="line">&gt; x+y</span><br><span class="line">15</span><br><span class="line">&gt; var sum&#x3D;_;</span><br><span class="line">undefined</span><br><span class="line">&gt; console.log(&quot;sum:&quot;+sum);</span><br><span class="line">sum:15</span><br></pre></td></tr></table></figure>

<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+c: 退出当前表达式</span><br><span class="line"></span><br><span class="line">ctrl+c(两次)&#x2F;ctrl+d：退出node REPL</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(1)-创建应用</title>
    <url>/Node-js-1-%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Node.js 为运行在服务端的 JavaScript。它是一个基于 Chrome JavaScript 运行时建立的平台，也是一个事件驱动 I/O 服务端的 JavaScript，基于 Google 的 V8 引擎。</p>
<a id="more"></a>

<p>Node.js 应用由以下部分组成：</p>
<ul>
<li><p>引入 required 模块：使用 require 指令载入 Node.js 模块</p>
</li>
<li><p>创建服务器：服务器监听客户端请求。</p>
</li>
<li><p>接收、响应请求</p>
</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="引入-required-模块"><a href="#引入-required-模块" class="headerlink" title="引入 required 模块"></a>引入 required 模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const server &#x3D; http.createServer();&#x2F;&#x2F;创建服务器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给服务器绑定request事件，并使用匿名函数作为其回调函数</span><br><span class="line">server.on(&quot;request&quot;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(req.url); &#x2F;&#x2F;输出请求的url地址</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;通过normalize将URL规范成路径</span><br><span class="line">  &#x2F;&#x2F;通过join将他和当前目录拼接起来</span><br><span class="line">  &#x2F;&#x2F;__dirname代表当前文件所在目录</span><br><span class="line">  const doc_path &#x3D; path.join(</span><br><span class="line">    __dirname,</span><br><span class="line">    &quot;document_root&quot;,</span><br><span class="line">    path.normalize(req.url)</span><br><span class="line">  );</span><br><span class="line">  console.log(doc_path);</span><br><span class="line"></span><br><span class="line">  const ext &#x3D; path.extname(req.url); &#x2F;&#x2F;获取扩展名</span><br><span class="line">  let mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;;</span><br><span class="line">  switch (</span><br><span class="line">    ext &#x2F;&#x2F;指定对应的MIME信息</span><br><span class="line">  ) &#123;</span><br><span class="line">    case &quot;.html&quot;:</span><br><span class="line">    case &quot;.htm&quot;:</span><br><span class="line">      mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;;</span><br><span class="line">      break;</span><br><span class="line">    case &quot;.css&quot;:</span><br><span class="line">      mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;text&#x2F;css&quot; &#125;;</span><br><span class="line">      break;</span><br><span class="line">    case &quot;.ico&quot;:</span><br><span class="line">      mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;image&#x2F;x-icon&quot; &#125;;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;使用existSync判断文件是否存在</span><br><span class="line">  &#x2F;&#x2F;使用extname去掉url目录，以防路径为目录，但目录里没有文件</span><br><span class="line">  if (path.extname(req.url) !&#x3D; &quot;&quot; &amp;&amp; fs.existsSync(doc_path)) &#123;</span><br><span class="line">    &#x2F;&#x2F;Response里边会包含MIME信息以告诉浏览器这是个什么格式的文件</span><br><span class="line">    res.writeHead(200, mime); &#x2F;&#x2F;输出状态码</span><br><span class="line">    content &#x3D; fs.readFileSync(doc_path); &#x2F;&#x2F;通过readFileSync读取文件内容</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    res.writeHead(404, mime);</span><br><span class="line">    content &#x3D; &quot;文件不存在&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.write(content); &#x2F;&#x2F;将内容写到request响应里去</span><br><span class="line"></span><br><span class="line">  res.end();&#x2F;&#x2F;发送响应数据</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(8080);&#x2F;&#x2F;监听8080端口</span><br></pre></td></tr></table></figure>

<h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><p><img src="https://s2.ax1x.com/2020/03/08/3xIOiT.jpg" alt="测试结果"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>纯HTML/CSS/JS实现九宫格拼图游戏</title>
    <url>/%E7%BA%AFHTML-CSS-JS%E5%AE%9E%E7%8E%B0%E4%B9%9D%E5%AE%AB%E6%A0%BC%E6%8B%BC%E5%9B%BE%E6%B8%B8%E6%88%8F.html</url>
    <content><![CDATA[<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://i.loli.net/2020/02/21/MBsWOjbg8ED7wLd.gif" alt="showall.gif"></p>
<p>github地址：<a href="https://github.com/ChangeZ24/game-gridpuzzle" target="_blank" rel="noopener">https://github.com/ChangeZ24/game-gridpuzzle</a></p>
<p>在线试玩地址： <a href="http://awesolynn.me/game-gridpuzzle/gridpuzzle.html">http://awesolynn.me/game-gridpuzzle/gridpuzzle.html</a></p>
<a id="more"></a>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>整个九宫格看作一个 div，分为 9 份，位置号为 1~9</p>
</li>
<li><p>九宫格内 8 个活动格看作 8 个 div，格号为 1~8，第 9 格为空格，记为 0</p>
</li>
</ul>
<h3 id="乱序排列九宫格内-8-个活动格"><a href="#乱序排列九宫格内-8-个活动格" class="headerlink" title="乱序排列九宫格内 8 个活动格"></a>乱序排列九宫格内 8 个活动格</h3><blockquote>
<p>算法：</p>
</blockquote>
<blockquote>
<p>1、从第 9 格空格开始，选取随机位置号为 1~9 的某格进行两两替换</p>
</blockquote>
<blockquote>
<p>2、接下来，第 8 格，即格号为 8（初始后格号为 8 的格同在位置 8），则选取随机位置号为 1~8 的格进行两两替换</p>
</blockquote>
<blockquote>
<p>以此类推</p>
</blockquote>
<h3 id="活动格鼠标点击进行滑动"><a href="#活动格鼠标点击进行滑动" class="headerlink" title="活动格鼠标点击进行滑动"></a>活动格鼠标点击进行滑动</h3><blockquote>
<p>算法：</p>
</blockquote>
<blockquote>
<p>1、初始时，使用数组记录每个位置可移动的位置号，如位置 1，可移动到位置 2 和位置 4</p>
</blockquote>
<blockquote>
<p>2、使用数组记录每个位置格的左上角点的 x、y 值，在 css 中即为 left、top 值，即每个格从位置 1 移动到位置 2，改变的位移值。</p>
</blockquote>
<blockquote>
<p>3、当鼠标进行点击某格时，若其可移动的格内有空格，则其位移变为空格的 x、y 值，完成移动的动作。</p>
</blockquote>
<h3 id="时间记录"><a href="#时间记录" class="headerlink" title="时间记录"></a>时间记录</h3><blockquote>
<p>时间记录，同样使用<code>setInterval()</code>函数按 1000ms 的间隔进行实时计算。</p>
</blockquote>
<h3 id="关卡设置"><a href="#关卡设置" class="headerlink" title="关卡设置"></a>关卡设置</h3><blockquote>
<p>本游戏共设置 3 关，当每关成功完成拼图，会出现提示<code>play more</code>表示进入下一关</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/BYJ6b4WPpdKz8j9.gif" alt="next.gif"></p>
<blockquote>
<p>当位于最后一关时，成功后只会提示<code>congratulations</code>，表示游戏结束。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/eXKdZgihUxIpHzy.gif" alt="suss.gif"></p>
<h3 id="暂停、重玩机制"><a href="#暂停、重玩机制" class="headerlink" title="暂停、重玩机制"></a>暂停、重玩机制</h3><blockquote>
<p>当点击开始游戏后，开始游戏的按钮会自动变为暂停游戏</p>
</blockquote>
<blockquote>
<p>点击暂停游戏后，时间暂停，各活动格也无法点击，只有点击开始游戏继续玩或点击重新开始，重启此关</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/5gc2CEVIyBKTMpl.gif" alt="pause.gif"></p>
<blockquote>
<p>点击重新开始，会重新启动所在的关卡，重排整个图。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/1r2jPMApN3wGTgo.gif" alt="reset.gif"></p>
<h2 id="疑惑-学习点"><a href="#疑惑-学习点" class="headerlink" title="疑惑/学习点"></a>疑惑/学习点</h2><h3 id="对-CSS-中-position-的理解"><a href="#对-CSS-中-position-的理解" class="headerlink" title="对 CSS 中 position 的理解"></a>对 CSS 中 position 的理解</h3><h4 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h4><p>position：用于层的绝对定位，即让一个层位于一个层内具体什么位置</p>
<p>参数：</p>
<ul>
<li><p>static：默认。按页面文档流放置，忽略 top、bottom、left、right 设置的值</p>
</li>
<li><p>relative：相对位置。对象不可层叠，可通过 top、bottom、left、right 设置在文档流中的位置</p>
</li>
<li><p>absolute：绝对位置。对象可通过 z-index 设置层叠，对象被从文档流拖出，根据 top、bottom、left、right 等属性进行绝对定位。</p>
</li>
<li><p>fixed：固定位置。通过 top、bottom、left、right 进行定位，页面滚动，对象仍存在于固定的位置不变。</p>
</li>
</ul>
<h4 id="对相对、绝对位置的理解"><a href="#对相对、绝对位置的理解" class="headerlink" title="对相对、绝对位置的理解"></a>对相对、绝对位置的理解</h4><ol>
<li><p>当子级使用<code>position: absolute;</code>时。其父级通常定义为<code>position: relative;</code></p>
<p>父级使用<code>position: relative;</code>相对位置时，最好同时定义其<code>width</code>和<code>height</code>。</p>
<p>此时，子级使用<code>position: absolute;</code>，设置的<code>top/bottom、left/right</code>即为距离父级上/下侧、左/右侧的距离，有点类似外边距。</p>
<blockquote>
<p><strong>注意</strong>：此时<code>top/bottom</code>二选一，<code>left/right</code>二选一！</p>
</blockquote>
</li>
<li><p>当子级使用<code>position: absolute;</code>但父级没有设置<code>position: relative;</code>时，无论子级处于 div 哪一层，都会被拖出文档流，以 <code>body</code>为父级，所设置的所有 <code>top/bottom、left/right</code>都会为距离<code>body</code>的上/下侧、左/右侧的距离，不受其父级控制。</p>
</li>
</ol>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol>
<li><p>实验楼拼图实现教学</p>
<p><a href="https://www.shiyanlou.com/courses/161" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/161</a></p>
</li>
<li><p>CSS 中 position 相关讲解</p>
<p><a href="http://www.divcss5.com/rumen/r403.shtml" target="_blank" rel="noopener">http://www.divcss5.com/rumen/r403.shtml</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>Grid Puzzle</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo建站指南</title>
    <url>/Hexo%E5%BB%BA%E7%AB%99%E6%8C%87%E5%8D%97.html</url>
    <content><![CDATA[<h2 id="下载安装必要工具"><a href="#下载安装必要工具" class="headerlink" title="下载安装必要工具"></a>下载安装必要工具</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><blockquote>
<p>搭建网站需要进行版本管理，故下载 git 进行使用。</p>
</blockquote>
<blockquote>
<p>下载网址： <a href="https://www.git-scm.com/download" target="_blank" rel="noopener">https://www.git-scm.com/download</a></p>
</blockquote>
<blockquote>
<p>使用说明可参考 git 官方文档：<a href="https://www.git-scm.com/doc" target="_blank" rel="noopener">https://www.git-scm.com/doc</a></p>
</blockquote>
<ul>
<li>安装时，一键 next 即可<a id="more"></a></li>
<li>安装后，在文件夹内或桌面点击鼠标右键，若出现如下工具，则证明安装成功:</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/iyzHFrNle78sTZn.jpg" alt="git.jpg"></p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><blockquote>
<p>Hexo 是基于 Node.js 编写的，所以需要安装一下 Node.js 和里面的 npm 工具。</p>
</blockquote>
<blockquote>
<p>网址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p>
</blockquote>
<h4 id="安装后检查是否安装成功"><a href="#安装后检查是否安装成功" class="headerlink" title="安装后检查是否安装成功"></a>安装后检查是否安装成功</h4><ul>
<li><code>win+R</code> 打开运行，输入<code>cmd</code>：</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/rn3PRI9HsfzwM4h.jpg" alt="cmd.jpg"></p>
<ul>
<li>检查 node.js 和 npm 是否安装成功：</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/I2HDLrPgampFnke.jpg" alt="node.jpg"></p>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><blockquote>
<p>hexo 即为此次搭建网站的框架</p>
</blockquote>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li><p>创建一个文件夹，名字任取，作为以后网站所有文件的存储地，即本地仓库</p>
</li>
<li><p>进入文件夹，按住<code>shift</code>键点击鼠标右键，win10 选择“在此处打开 powershell 窗口”，win7 选择“在此处打开命令窗口”</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/xKdosqQEHlnMr4X.jpg" alt="powershell2.jpg"></p>
<ul>
<li><p>输入命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装结束，输入命令检查是否安装成功</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="初始化-hexo"><a href="#初始化-hexo" class="headerlink" title="初始化 hexo"></a>初始化 hexo</h4><ul>
<li><p>初始化 hexo 框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>初始化后一般在博客文件夹会出现以下文件：</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/K8XiTDvh4rexBp5.jpg" alt="folder.jpg"></p>
<ul>
<li><p>在文件夹内安装 npm 相关组件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成页面</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地服务器打开查看页面</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
<li><p>若出现此页面，证明生成页面成功</p>
<p><img src="https://i.loli.net/2020/02/20/8fZiS1Wln3x4Ksj.jpg" alt="pagelocal.jpg"></p>
</li>
<li><p><code>ctrl+C</code>关掉本地</p>
</li>
</ul>
<h2 id="使用-Github-作为服务器部署-hexo-网站"><a href="#使用-Github-作为服务器部署-hexo-网站" class="headerlink" title="使用 Github 作为服务器部署 hexo 网站"></a>使用 Github 作为服务器部署 hexo 网站</h2><h3 id="配置-github"><a href="#配置-github" class="headerlink" title="配置 github"></a>配置 github</h3><ul>
<li><p>若没有 github 账号，则首先需要注册</p>
<p>网址：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
</li>
<li><p>新建仓库，点击页面右上角+，新建仓库 repository</p>
<p><img src="https://i.loli.net/2020/02/21/NVMhiTOzBWPGp9U.jpg" alt="repository.jpg"></p>
</li>
<li><p>填入信息，注意仓库名必须为：<strong>你的 github 用户名.github.io</strong></p>
<p>例如：ChangeZ24.github.io</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5P8P.jpg" alt="github"></p>
</li>
<li><p>在 blog 目录内点击鼠标右键，选择在此处打开 git Bash</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/sgNcERCUeFvb7VD.jpg" alt="gitbash.jpg"></p>
<ul>
<li><p>生成 SSH key</p>
<blockquote>
<p>SSH key 提供了一种与 GitHub 通信的方式，通过这种方式，能够在不输入密码的情况下，将 GitHub 作为自己的 remote 端服务器，进行版本控制</p>
</blockquote>
<p>输入命令生成 SSH key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;github用户名&quot;</span><br><span class="line">git config --global user.email &quot;github登陆邮箱&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以使用此命令检查是否输入正确</span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 SSH key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github登陆邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>创建完成后会在我的电脑 C 盘出现 id_rsa、id_rsa.pub 文件</p>
<p><img src="https://i.loli.net/2020/02/20/2Uu6ZaMjqlENSz4.jpg" alt="id.jpg"></p>
</li>
<li><p>打开 id_rsa.pub 文件，复制里面全部内容（即 key）</p>
</li>
<li><p>打开 github 导入 key</p>
<p><img src="https://i.loli.net/2020/02/21/84Wx7mUcVqRMB3Y.jpg" alt="setting.jpg"></p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5SUA.jpg" alt="3m5SUA.jpg"></p>
<p><img src="https://i.loli.net/2020/02/20/5RXFkjyDr2IH4e9.jpg" alt="createSSH.jpg"></p>
<p>新建时 SSHkey 的 title 可以随便填。</p>
</li>
<li><p>在 git Bash 中输入以下命令检查是否导入成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="将-hexo-部署到-github"><a href="#将-hexo-部署到-github" class="headerlink" title="将 hexo 部署到 github"></a>将 hexo 部署到 github</h3><ul>
<li><p>修改站点的配置文件_config.yml</p>
<blockquote>
<p><strong>注意</strong></p>
</blockquote>
<blockquote>
<p>存储在博客目录文件下的_config.yml 为<strong>站点的配置文件</strong></p>
</blockquote>
<blockquote>
<p>存储在博客目录的/theme/xxx(模板名)/_config.yml 为<strong>模板的配置文件</strong></p>
</blockquote>
<p>修改站点配置文件_config.yml 的 deploy 属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  # 此路径可直接在github仓库复制，如下图所示</span><br><span class="line">  repository:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;github用户名&#x2F;你的github用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>repository 路径可直接在仓库页面复制 http 路径：</p>
<p><img src="https://i.loli.net/2020/02/20/cQmOy5DBiz6eKbl.jpg" alt="githubhttp.jpg"></p>
</li>
<li><p>安装部署 git 的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理部署项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成部署命令可一起使用</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署成功即可在<code>http://github用户名.github.io</code>查看生成的页面</p>
<p><img src="https://i.loli.net/2020/02/20/8fZiS1Wln3x4Ksj.jpg" alt="pagelocal.jpg"></p>
</li>
</ul>
<h2 id="常用的-hexo-命令"><a href="#常用的-hexo-命令" class="headerlink" title="常用的 hexo 命令"></a>常用的 hexo 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目缓存内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br><span class="line"></span><br><span class="line">hexo new page &quot;page名&quot; &#x2F;&#x2F;新建页面</span><br><span class="line">hexo new &quot;文章名&quot; &#x2F;&#x2F;新建文章</span><br></pre></td></tr></table></figure>

<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ul>
<li>在 hexo 官网选择喜欢的模板</li>
</ul>
<p>网址：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<ul>
<li>在 blog 目录下打开命令行或 git Bash 输入命令下载主题</li>
</ul>
<blockquote>
<p>主题下载命令一般在主题页面，或预览页面主题创作人的文章里都有</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Shen-Yu&#x2F;hexo-theme-ayer.git themes&#x2F;ayer</span><br></pre></td></tr></table></figure>

<ul>
<li>修改站点配置文件_config.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: ayer  #在此处修改想要使用的主题名</span><br></pre></td></tr></table></figure>

<ul>
<li>重新生成部署页面即可看到新主题下的网页</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目缓存内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br></pre></td></tr></table></figure>

<h2 id="设置自己的个人域名"><a href="#设置自己的个人域名" class="headerlink" title="设置自己的个人域名"></a>设置自己的个人域名</h2><pre><code>目前生成的页面都是通过github提供的xxx.github.io访问，若想使用自己的个性化域名则需要以下步骤</code></pre><h3 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h3><blockquote>
<p>申请域名有很多网站，国内大多使用<a href="https://wanwang.aliyun.com/?spm=5176.8142029.digitalization.2.e9396d3e46JCc5" target="_blank" rel="noopener">阿里云</a>，不同的域名后缀价格不同，挑选自己喜欢可承受的即可。<br>国外域名可使用<a href="https://sg.godaddy.com/domains/domain-name-search" target="_blank" rel="noopener">godaddy</a>、<a href="https://www.namesilo.com/" target="_blank" rel="noopener">namesilo</a>等购买，国外域名一般不需要备案。</p>
</blockquote>
<h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><p>本人注册的域名时在 namesilo 购买，故以 namesilo 为例：</p>
<ul>
<li><p>登陆 namesilo 在自己的账户页面，点击 Account Domain 后的数字，进入域名管理页面</p>
<p><img src="https://i.loli.net/2020/02/20/ZDBEhn9WfrKbLvQ.jpg" alt="namesilo1.jpg"></p>
</li>
<li><p>选择 option 下的蓝色小人图标，进入解析界面</p>
<p><img src="https://i.loli.net/2020/02/20/p4fmEQvedOkT6MA.jpg" alt="domain.jpg"></p>
</li>
<li><p>将 namesoil 自动生成的所有记录删除，即 sevice 下所有未 parking 状态的记录，一般情况为 3 条 A 记录，1 条 CNAME 记录</p>
</li>
<li><p>添加自己的解析内容</p>
<ul>
<li><p>新建一个 A 记录</p>
<p><img src="https://i.loli.net/2020/02/20/lFyMoJXKYPnswN1.jpg" alt="a.jpg"></p>
</li>
<li><p>在系统 cmd 界面 ping github.io 的 ip</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5EDg.jpg" alt="3m5EDg.jpg"></p>
</li>
<li><p>在框内填写解析 ip</p>
<p><img src="https://i.loli.net/2020/02/20/ODTXBP4WRYyZcVK.jpg" alt="A2.jpg"></p>
</li>
<li><p>新建 CNAME 记录</p>
<p><img src="https://i.loli.net/2020/02/20/CP6BZFTMnqYycbh.jpg" alt="cname.jpg"></p>
</li>
<li><p>域名解析</p>
<blockquote>
<p>点击 SUBMIT 之后，回到域名管理界面，等待 status 状态变为 Active，则为解析成功，一般大概需要几分钟时间。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5p4I.jpg" alt="3m5p4I.jpg"></p>
</li>
</ul>
</li>
</ul>
<h3 id="在-github-关联域名"><a href="#在-github-关联域名" class="headerlink" title="在 github 关联域名"></a>在 github 关联域名</h3><ul>
<li><p>进入 github 博客仓库，选择 settings 进入项目设置</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5CCt.jpg" alt="3m5CCt.jpg"></p>
</li>
<li><p>在 Option 界面找到 git page 属性进行以下设置</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/D1tE3YZ8naOTmFS.jpg" alt="githubpage.jpg"></p>
<h3 id="在博客目录下的-source-文件夹新建-CNAME-文件，在文件内填写自己的域名"><a href="#在博客目录下的-source-文件夹新建-CNAME-文件，在文件内填写自己的域名" class="headerlink" title="在博客目录下的 source 文件夹新建 CNAME 文件，在文件内填写自己的域名"></a>在博客目录下的 source 文件夹新建 CNAME 文件，在文件内填写自己的域名</h3><blockquote>
<p>保存时，注意选择所有文件类型，文件名仅为 CNAME，无后缀</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/20/VxqNsOWwflFrESG.jpg" alt="cname2.jpg"></p>
<p><img src="https://i.loli.net/2020/02/20/3aSFl1etGmCx5kU.jpg" alt="cname1.jpg"></p>
<h3 id="重新部署生成页面"><a href="#重新部署生成页面" class="headerlink" title="重新部署生成页面"></a>重新部署生成页面</h3><ul>
<li>生成部署页面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目缓存内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br></pre></td></tr></table></figure>

<ul>
<li>在浏览器输入自己的域名即可看到生成的网页</li>
</ul>
<blockquote>
<p><strong>注意：记得清理浏览器缓存。</strong></p>
</blockquote>
<ul>
<li>使用<code>hexo new “文章名”</code>新建文章，在博客目录的 source/_posts/下找到“文章名.md”，即可使用 Markdown 编辑自己的文章了</li>
</ul>
<blockquote>
<p>写好后，注意使用<code>hexo g -d</code>重新生成，部署页面</p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>纯HTML/CSS/JS实现扫雷游戏</title>
    <url>/%E7%BA%AFHTML-CSS-JavaScript%E5%AE%9E%E7%8E%B0%E6%89%AB%E9%9B%B7%E6%B8%B8%E6%88%8F.html</url>
    <content><![CDATA[<h2 id="使用语言"><a href="#使用语言" class="headerlink" title="使用语言"></a>使用语言</h2><p>  该半个月在<a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web" target="_blank" rel="noopener">MDN Web Docs</a>网站学习网页开发，在学完 HTML、CSS、JavaScript 相关内容以后，决定用项目练练手。在<a href="https://www.shiyanlou.com/courses/?tag=%E5%85%A8%E9%83%A8&fee=all&sort=default&category=Web%20%E5%89%8D%E7%AB%AF&page=2" target="_blank" rel="noopener">实验楼 Web 开发</a>找到仅有的几个纯 HTML + CSS + JavaScript 项目作为练习。</p>
<p>  此项目即为纯Html + CSS + JavaScript的网页版扫雷游戏实现。</p>
<p>  github地址: <a href="https://github.com/ChangeZ24/game-minesweeper" target="_blank" rel="noopener">https://github.com/ChangeZ24/game-minesweeper</a></p>
<p>  在线试玩页面：<a href="http://awesolynn.me/game-minesweeper/">http://awesolynn.me/game-minesweeper/</a></p>
  <a id="more"></a>

<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="https://i.loli.net/2020/02/19/4y2JApmUso1Q6YH.jpg" alt="index.jpg"></p>
<h3 id="游戏页"><a href="#游戏页" class="headerlink" title="游戏页"></a>游戏页</h3><p><img src="https://s2.ax1x.com/2020/02/21/3m5eEj.gif" alt="3m5eEj.gif"></p>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><h3 id="选择游戏难度"><a href="#选择游戏难度" class="headerlink" title="选择游戏难度"></a>选择游戏难度</h3><ol>
<li><p>游戏难度参照 win10 自带扫雷设置：</p>
<ul>
<li>初级 9*9 雷：10</li>
<li>中级 16*16 雷：40</li>
<li>高级 30*16 雷：99</li>
</ul>
</li>
<li><p>选择游戏难度后，点击开始游戏按钮跳转进入游戏页面。</p>
</li>
<li><p>游戏难度自带参数通过 url 传递</p>
</li>
</ol>
<h3 id="左键点击格子显示数字-雷"><a href="#左键点击格子显示数字-雷" class="headerlink" title="左键点击格子显示数字/雷"></a>左键点击格子显示数字/雷</h3><ol>
<li><p>为每个格子绑定 onmousedown 事件，通过其 event.button 值确定点击左键</p>
</li>
<li><p>初始化时，设定扫雷 mineSweeper 类，其中，地图格子以二维数组形式 landArrs 存在</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;由于扫雷每个格子中的内容为数字或雷。数字表示以其为中心的九宫格内雷的数量，故以九宫格中数字1~8表示，0为空格，9为雷</span><br><span class="line">landArrs[i][j]&#x3D;0;&#x2F;&#x2F;空格</span><br><span class="line">landArrs[i][j]&#x3D;1;&#x2F;&#x2F;数字1~8</span><br><span class="line">landArrs[i][j]&#x3D;9;&#x2F;&#x2F;雷</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>游戏开始前，按所选难度的雷数，将各雷随机放在地图内，再根据雷的位置计算雷周围数字的设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1.初始化所有格子为0</span><br><span class="line">landArrs[i][j]&#x3D;0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.按雷数随机放置雷位置</span><br><span class="line">&#x2F;&#x2F;随机数a-b：Math.floor(Math.random() * (max - min)) + min</span><br><span class="line">var randomNum &#x3D; Math.floor(Math.random() * (row * col - 0) + 0);</span><br><span class="line">var rNum &#x3D; parseInt(randomNum &#x2F; this.colCount);&#x2F;&#x2F;随机数所在的格子行数</span><br><span class="line">var cNum &#x3D; parseInt(randomNum % this.colCount);&#x2F;&#x2F;随机数所在的格子列数</span><br><span class="line">&#x2F;&#x2F;判断该位置是否已放置雷（省略）</span><br><span class="line">landArrs[rNum][cNum] &#x3D; 9;&#x2F;&#x2F;放置雷</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.按雷位置，计算其周边数字</span><br><span class="line">&#x2F;&#x2F;算法：遍历每个雷，将每个雷上下左右8格均+1</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>点中雷，游戏失败</li>
</ol>
<h3 id="右键点击插旗或取消旗子"><a href="#右键点击插旗或取消旗子" class="headerlink" title="右键点击插旗或取消旗子"></a>右键点击插旗或取消旗子</h3><ol>
<li><p>为每个格子绑定 onmousedown 事件，通过其 event.button 值确定点击右键</p>
</li>
<li><p>点击右键则将此格的 class 设置为 flag，按 CSS 样式放置旗子背景图—-&gt;插旗</p>
</li>
<li><p>再次点击右键则将已插旗的格子 class 设置为空字符串，取消 CSS 样式—-&gt;拔旗</p>
</li>
</ol>
<h3 id="点击格子为空值无数字时，自动连续展开其周边格子"><a href="#点击格子为空值无数字时，自动连续展开其周边格子" class="headerlink" title="点击格子为空值无数字时，自动连续展开其周边格子"></a>点击格子为空值无数字时，自动连续展开其周边格子</h3><blockquote>
<p>算法：</p>
<ol>
<li>点击格子值为 0，则以该格为中心查看其周围8个格</li>
<li>若其周围格为被打开过，则打开该格。</li>
<li>若其周围格再次遇到 0，自动循环查找</li>
</ol>
</blockquote>
<h3 id="花费时间即剩余雷数计算"><a href="#花费时间即剩余雷数计算" class="headerlink" title="花费时间即剩余雷数计算"></a>花费时间即剩余雷数计算</h3><ol>
<li><p>花费时间</p>
<blockquote>
<p>采用 JS 异步时间间隔 setInterval()算法，每 1s 更新一次时间<br>setInterval(displayTime, 1000);</p>
</blockquote>
</li>
<li><p>剩余雷数</p>
<blockquote>
<p>每标记一处，html 更新一次内容</p>
</blockquote>
</li>
</ol>
<h3 id="双击设定：满足已标记数与自身数字一致时自动打开格子"><a href="#双击设定：满足已标记数与自身数字一致时自动打开格子" class="headerlink" title="双击设定：满足已标记数与自身数字一致时自动打开格子"></a>双击设定：满足已标记数与自身数字一致时自动打开格子</h3><ol>
<li><p>双击已打开的数字格。</p>
<blockquote>
<p>当双击位置周围已标记雷数等于该位置数字时操作有效，相当于对该数字周围未打开的方块均进行一次左键单击操作。<br>地雷未标记完全时使用双击无效。</p>
</blockquote>
</li>
<li><p>若数字周围有标错的地雷，则游戏结束，标错的地雷上会显示一个“×”</p>
</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5VbQ.gif" alt="3m5VbQ.gif"></p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol>
<li><p>实验楼扫雷实现教程</p>
<p><a href="https://www.shiyanlou.com/courses/144" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/144</a></p>
</li>
<li><p>MDN Web Docs</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>MineSweeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Web学习(1)--网络基础</title>
    <url>/Web%E5%AD%A6%E4%B9%A0-1-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80.html</url>
    <content><![CDATA[<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>  Web开发与网络息息相关，故首先从打好网络基础入手：<br>  <a id="more"></a></p>
<p>  <img src="https://i.loli.net/2020/02/19/Q3fYNHwpL6XPcng.jpg" alt="internet.jpg"></p>
<h2 id="参考学习内容"><a href="#参考学习内容" class="headerlink" title="参考学习内容"></a>参考学习内容</h2><p>  MDN Web Docs</p>
<p>  <a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Internet</tag>
      </tags>
  </entry>
</search>
