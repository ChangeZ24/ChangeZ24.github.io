<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>结合Vue3-demo项目分析源码（五）</title>
    <url>/post/3341038055.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/%E7%BB%93%E5%90%88Vue3-demo%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89.html">结合Vue3-demo项目分析源码（四）</a>，整个组件的创建涉及到两个生命周期<code>beforeCreated</code>和<code>created</code>，到<code>created</code>才算组件创建完成，此时进入组件的渲染过程。</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（四）</title>
    <url>/post/2830824608.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/%E7%BB%93%E5%90%88Vue3-demo%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89.html">结合Vue3-demo项目分析源码（三）</a>，回到方法<code>setupStatefulComponent()</code></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/component.ts</code>第538行</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setupStatefulComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const Component &#x3D; instance.type as ComponentOptions</span><br><span class="line">  &#x2F;&#x2F; 1. 创建当前组件实例的代理对象</span><br><span class="line">  instance.proxy &#x3D; new Proxy(instance.ctx, PublicInstanceProxyHandlers)</span><br><span class="line">  &#x2F;&#x2F; 2. 如果组件提供了 setup 方法</span><br><span class="line">     const &#123; setup &#125; &#x3D; Component</span><br><span class="line">  if (setup) &#123;</span><br><span class="line">    &#x2F;&#x2F; setup 的上下文对象</span><br><span class="line">    const setupContext &#x3D; (instance.setupContext &#x3D;</span><br><span class="line">      setup.length &gt; 1 ? createSetupContext(instance) : null)</span><br><span class="line"></span><br><span class="line">    currentInstance &#x3D; instance</span><br><span class="line">    pauseTracking()</span><br><span class="line">    &#x2F;&#x2F; 调用 setup 方法，获取返回值 setupResult</span><br><span class="line">    const setupResult &#x3D; callWithErrorHandling(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      ErrorCodes.SETUP_FUNCTION,</span><br><span class="line">      [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext]</span><br><span class="line">    )</span><br><span class="line">    resetTracking()</span><br><span class="line">    currentInstance &#x3D; null</span><br><span class="line">        &#x2F;&#x2F; 处理 setup 方法返回值</span><br><span class="line">    if (isPromise(setupResult)) &#123;</span><br><span class="line">      if (isSSR) &#123;</span><br><span class="line">        &#x2F;&#x2F; return the promise so server-renderer can wait on it</span><br><span class="line">        return setupResult.then((resolvedResult: unknown) &#x3D;&gt; &#123;</span><br><span class="line">          handleSetupResult(instance, resolvedResult, isSSR)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else if (__FEATURE_SUSPENSE__) &#123;</span><br><span class="line">        &#x2F;&#x2F; async setup returned Promise.</span><br><span class="line">        &#x2F;&#x2F; bail here and wait for re-entry.</span><br><span class="line">        instance.asyncDep &#x3D; setupResult</span><br><span class="line">      &#125; else if (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#96;setup() returned a Promise, but the version of Vue you are using &#96; +</span><br><span class="line">            &#96;does not support it yet.&#96;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回值为非 promise 对象的类型时候，调用 handleSetupResult 方法处理返回值</span><br><span class="line">      handleSetupResult(instance, setupResult, isSSR)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 完成组件的创建</span><br><span class="line">    finishComponentSetup(instance, isSSR)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><blockquote>
<p>setup方法为Vue3提供的新方法，为了定义聚合式（组合式）api组件</p>
</blockquote>
<ul>
<li>组合式api：一种低侵入式、函数式的API。无需指定一长串选项来定义组件，允许用户像编写函数一样自由组合逻辑和代码，可以更灵活的组合组件的逻辑。</li>
</ul>
<p>方法<code>setup</code>是组合式api的入口，在<code>beforeCreate</code>钩子之前调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用setup前</span><br><span class="line">created() &#123;</span><br><span class="line">    console.log(this.$props);</span><br><span class="line">    console.log(&quot; this 就是组件实例的代理对象 proxy&quot;);</span><br><span class="line">    &#x2F;&#x2F; 调用全局的方法</span><br><span class="line">    this.$showSuccuessDialog(&quot;我是全局的 showSuccuessDialog 方法&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F;使用setup后</span><br><span class="line">setup(props,setupContext)&#123;</span><br><span class="line">    const instance &#x3D; getCurrentInstance();</span><br><span class="line">    console.log(props)</span><br><span class="line">    console.log(&quot;instance为组件实例的代理对象proxy，即先前的this&quot;)</span><br><span class="line">    console.log(instance.proxy);&#x2F;&#x2F;即先前的this</span><br><span class="line">    &#x2F;&#x2F;调用全局方法</span><br><span class="line">    instance.proxy.$showSuccessDialog(&quot;全局showSuccessDialog方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setup参数"><a href="#setup参数" class="headerlink" title="setup参数"></a>setup参数</h4><ul>
<li><p>props: 组件的属性值</p>
</li>
<li><p>setupContext: setup方法的上下文对象</p>
</li>
</ul>
<p>对象<code>setupContext</code>定义可查看文件<code>vue-next/vue-next/packages/runtime-core/src/component.ts</code>第751行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createSetupContext(</span><br><span class="line">  instance: ComponentInternalInstance</span><br><span class="line">): SetupContext &#123;</span><br><span class="line">  const expose: SetupContext[&#39;expose&#39;] &#x3D; exposed &#x3D;&gt; &#123;</span><br><span class="line">    if (__DEV__ &amp;&amp; instance.exposed) &#123;</span><br><span class="line">      warn(&#96;expose() should be called only once per setup().&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    instance.exposed &#x3D; proxyRefs(exposed)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    &#x2F;&#x2F; We use getters in dev in case libs like test-utils overwrite instance</span><br><span class="line">    &#x2F;&#x2F; properties (overwrites should not be done in prod)</span><br><span class="line">    return Object.freeze(&#123;</span><br><span class="line">      get props() &#123;</span><br><span class="line">        return instance.props</span><br><span class="line">      &#125;,</span><br><span class="line">      get attrs() &#123;</span><br><span class="line">        return new Proxy(instance.attrs, attrHandlers)</span><br><span class="line">      &#125;,</span><br><span class="line">      get slots() &#123;</span><br><span class="line">        return shallowReadonly(instance.slots)</span><br><span class="line">      &#125;,</span><br><span class="line">      get emit() &#123;</span><br><span class="line">        return (event: string, ...args: any[]) &#x3D;&gt; instance.emit(event, ...args)</span><br><span class="line">      &#125;,</span><br><span class="line">      expose</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      attrs: instance.attrs,</span><br><span class="line">      slots: instance.slots,</span><br><span class="line">      emit: instance.emit,</span><br><span class="line">      expose</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可得，<code>setupContext</code>对象有四个属性</p>
<ul>
<li><p>attrs：除<code>props</code>之外的属性值</p>
</li>
<li><p>slots：组件插槽</p>
</li>
<li><p>emit：事件触发函数</p>
</li>
<li><p>expose：设置暴露在<code>ref</code>上的对象</p>
</li>
</ul>
<h3 id="handleSetupResult"><a href="#handleSetupResult" class="headerlink" title="handleSetupResult()"></a>handleSetupResult()</h3><blockquote>
<p>处理setup方法返回的结果</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/component.ts</code>第610行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function handleSetupResult(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  setupResult: unknown,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F;若返回值为方法</span><br><span class="line">  if (isFunction(setupResult)) &#123;</span><br><span class="line">    &#x2F;&#x2F; setup returned an inline render function</span><br><span class="line">    if (__NODE_JS__ &amp;&amp; (instance.type as ComponentOptions).__ssrInlineRender) &#123;</span><br><span class="line">      &#x2F;&#x2F; when the function&#39;s name is &#96;ssrRender&#96; (compiled by SFC inline mode),</span><br><span class="line">      &#x2F;&#x2F; set it as ssrRender instead.</span><br><span class="line">      instance.ssrRender &#x3D; setupResult</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;返回的不是ssr函数，则把返回的方法给instance的render属性</span><br><span class="line">      instance.render &#x3D; setupResult as InternalRenderFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;返回值是对象</span><br><span class="line">  &#125; else if (isObject(setupResult)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;直接将返回的对象给instance的setupState属性</span><br><span class="line">    instance.setupState &#x3D; proxyRefs(setupResult)</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if (__DEV__ &amp;&amp; setupResult !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      &#96;setup() should return an object. Received: $&#123;</span><br><span class="line">        setupResult &#x3D;&#x3D;&#x3D; null ? &#39;null&#39; : typeof setupResult</span><br><span class="line">      &#125;&#96;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;完成组件setup</span><br><span class="line">  finishComponentSetup(instance, isSSR)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h4><ol>
<li>返回值为方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setup(props,setupContext)&#123;</span><br><span class="line">    const instance &#x3D; getCurrentInstance();</span><br><span class="line">    console.log(props)</span><br><span class="line">    console.log(&quot;instance为组件实例的代理对象proxy，即先前的this&quot;)</span><br><span class="line">    console.log(instance.proxy);&#x2F;&#x2F;即先前的this</span><br><span class="line">    &#x2F;&#x2F;调用全局方法</span><br><span class="line">    instance.proxy.$showSuccessDialog(&quot;全局showSuccessDialog方法&quot;);</span><br><span class="line">    onMounted(()&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F;获取暴露在hello组件ref对象的name属性</span><br><span class="line">        console.log(instance.proxy.$refs[&quot;refHello&quot;].name);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;setup返回值为方法</span><br><span class="line">    return () &#x3D;&gt; h(&quot;div&quot;,&quot;setup返回了一个方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按<code>handleSetupResult</code>方法显示，直接传递给<code>instance</code>的<code>render</code>方法，给页面不显示原来<code>template</code>内容，而直接被渲染为返回值方法的内容</p>
<p><img src="https://z3.ax1x.com/2021/05/27/2iJJpQ.png" alt="返回方法"></p>
<ol start="2">
<li>返回值为对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setup(props,setupContext)&#123;</span><br><span class="line">    const instance &#x3D; getCurrentInstance();</span><br><span class="line">    console.log(props)</span><br><span class="line">    console.log(&quot;instance为组件实例的代理对象proxy，即先前的this&quot;)</span><br><span class="line">    console.log(instance.proxy);&#x2F;&#x2F;即先前的this</span><br><span class="line">    &#x2F;&#x2F;调用全局方法</span><br><span class="line">    instance.proxy.$showSuccessDialog(&quot;全局showSuccessDialog方法&quot;);</span><br><span class="line">    onMounted(()&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F;获取暴露在hello组件ref对象的name属性</span><br><span class="line">        console.log(instance.proxy.$refs[&quot;refHello&quot;].name);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;setup返回值为方法</span><br><span class="line">    &#x2F;&#x2F; return () &#x3D;&gt; h(&quot;div&quot;,&quot;setup返回了一个方法&quot;);</span><br><span class="line">    &#x2F;&#x2F;返回值为对象</span><br><span class="line">    return &#123;</span><br><span class="line">        setupMsg: &quot;setup返回了一个对象，我是属性setupMsg&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按<code>handleSetupResult</code>方法显示，<code>setup</code>返回的对象直接传递给<code>instance</code>的<code>setupState</code>属性，按方法<code>setupStatefulComponent</code>，当用<code>proxy</code>获取<code>instance</code>属性时，首先从<code>setupState</code>中取。</p>
<p><img src="https://z3.ax1x.com/2021/05/27/2iJxN8.png" alt="2iJxN8.png"></p>
<h3 id="finishComponentSetup"><a href="#finishComponentSetup" class="headerlink" title="finishComponentSetup()"></a>finishComponentSetup()</h3><blockquote>
<p>当方法<code>handleSetupResult</code>处理完结果，直接调用<code>finishComponentSetup</code>方法完成组件的创建。</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/component.ts</code>第665行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function finishComponentSetup(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const Component &#x3D; instance.type as ComponentOptions</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; template &#x2F; render function normalization</span><br><span class="line">  if (__NODE_JS__ &amp;&amp; isSSR) &#123;</span><br><span class="line">    &#x2F;&#x2F;若组件有render方法，则直接将其赋予组件实例</span><br><span class="line">    if (Component.render) &#123;</span><br><span class="line">      instance.render &#x3D; Component.render as InternalRenderFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (!instance.render) &#123;</span><br><span class="line">    &#x2F;&#x2F; could be set from setup()</span><br><span class="line">    &#x2F;&#x2F;若组件提供了template属性，则调用compile方法将它转换为render函数</span><br><span class="line">    if (compile &amp;&amp; Component.template &amp;&amp; !Component.render) &#123;</span><br><span class="line">      if (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, &#96;compile&#96;)</span><br><span class="line">      &#125;</span><br><span class="line">      Component.render &#x3D; compile(Component.template, &#123;</span><br><span class="line">        isCustomElement: instance.appContext.config.isCustomElement,</span><br><span class="line">        delimiters: Component.delimiters</span><br><span class="line">      &#125;)</span><br><span class="line">      if (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, &#96;compile&#96;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instance.render &#x3D; (Component.render || NOOP) as InternalRenderFunction</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;兼容Vue2组件参数</span><br><span class="line">  &#x2F;&#x2F; support for 2.x options</span><br><span class="line">  if (__FEATURE_OPTIONS_API__) &#123;</span><br><span class="line">    currentInstance &#x3D; instance</span><br><span class="line">    pauseTracking()</span><br><span class="line">    applyOptions(instance, Component)</span><br><span class="line">    resetTracking()</span><br><span class="line">    currentInstance &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个组件最后都会有一个<code>render</code>方法，前面用<code>setup</code>返回了一个方法充当了组件的<code>render</code>方法。</p>
<p>由上述方法得知，可直接使用<code>sfc</code>组件的形式通过<code>vue-loader</code>编译<code>template</code>，或给组件提供<code>template</code>属性，由<code>compile</code>方法编译成<code>render</code>方法，或直接提供一个<code>render</code>方法。</p>
<h3 id="applyOptions"><a href="#applyOptions" class="headerlink" title="applyOptions()"></a>applyOptions()</h3><blockquote>
<p>为了兼容Vue2组件调用此方法处理Vue2一些属性的兼容。</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/componentOptions.ts</code>第438行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function applyOptions(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  options: ComponentOptions,</span><br><span class="line">  deferredData: DataFn[] &#x3D; [],</span><br><span class="line">  deferredWatch: ComponentWatchOptions[] &#x3D; [],</span><br><span class="line">  deferredProvide: (Data | Function)[] &#x3D; [],</span><br><span class="line">  asMixin: boolean &#x3D; false</span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; applyOptions is called non-as-mixin once per instance</span><br><span class="line">  &#x2F;&#x2F;开始调用beforeCreate生命周期</span><br><span class="line">  if (!asMixin) &#123;</span><br><span class="line">    isInBeforeCreate &#x3D; true</span><br><span class="line">    callSyncHook(</span><br><span class="line">      &#39;beforeCreate&#39;,</span><br><span class="line">      LifecycleHooks.BEFORE_CREATE,</span><br><span class="line">      options,</span><br><span class="line">      instance,</span><br><span class="line">      globalMixins</span><br><span class="line">    )</span><br><span class="line">    isInBeforeCreate &#x3D; false</span><br><span class="line">    &#x2F;&#x2F; global mixins are applied first</span><br><span class="line">    &#x2F;&#x2F;应用全局的mixins</span><br><span class="line">    applyMixins(</span><br><span class="line">      instance,</span><br><span class="line">      globalMixins,</span><br><span class="line">      deferredData,</span><br><span class="line">      deferredWatch,</span><br><span class="line">      deferredProvide</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; extending a base component...</span><br><span class="line">  &#x2F;&#x2F;处理extends属性</span><br><span class="line">  if (extendsOptions) &#123;</span><br><span class="line">    applyOptions(</span><br><span class="line">      instance,</span><br><span class="line">      extendsOptions,</span><br><span class="line">      deferredData,</span><br><span class="line">      deferredWatch,</span><br><span class="line">      deferredProvide,</span><br><span class="line">      true</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; local mixins</span><br><span class="line">  &#x2F;&#x2F;处理本地mixins</span><br><span class="line">  if (mixins) &#123;</span><br><span class="line">    applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;处理inject属性</span><br><span class="line">  if (injectOptions) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理methods属性</span><br><span class="line">  if (methods) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理data属性</span><br><span class="line">  if (!asMixin) &#123;</span><br><span class="line">    if (deferredData.length) &#123;</span><br><span class="line">      deferredData.forEach(dataFn &#x3D;&gt; resolveData(instance, dataFn, publicThis))</span><br><span class="line">    &#125;</span><br><span class="line">    if (dataOptions) &#123;</span><br><span class="line">      resolveData(instance, dataOptions, publicThis)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if (dataOptions) &#123;</span><br><span class="line">    deferredData.push(dataOptions as DataFn)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理computed属性</span><br><span class="line">  if (computedOptions) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理watch属性</span><br><span class="line">  if (watchOptions) &#123;</span><br><span class="line">    deferredWatch.push(watchOptions)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;处理provide属性</span><br><span class="line">  if (provideOptions) &#123;</span><br><span class="line">    deferredProvide.push(provideOptions)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; asset options.</span><br><span class="line">  &#x2F;&#x2F; To reduce memory usage, only components with mixins or extends will have</span><br><span class="line">  &#x2F;&#x2F; resolved asset registry attached to instance.</span><br><span class="line">  &#x2F;&#x2F;处理components</span><br><span class="line">  if (asMixin) &#123;</span><br><span class="line">    if (components) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;处理directives</span><br><span class="line">    if (directives) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; lifecycle options</span><br><span class="line">  &#x2F;&#x2F;调用created生命周期</span><br><span class="line">  if (!asMixin) &#123;</span><br><span class="line">    callSyncHook(</span><br><span class="line">      &#39;created&#39;,</span><br><span class="line">      LifecycleHooks.CREATED,</span><br><span class="line">      options,</span><br><span class="line">      instance,</span><br><span class="line">      globalMixins</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理beforeMount、mount等生命周期</span><br><span class="line">  if (beforeMount) &#123;</span><br><span class="line">    onBeforeMount(beforeMount.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  if (mounted) &#123;</span><br><span class="line">    onMounted(mounted.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;兼容Vue2的expose属性</span><br><span class="line">  if (isArray(expose)) &#123;</span><br><span class="line">    if (!asMixin) &#123;</span><br><span class="line">      if (expose.length) &#123;</span><br><span class="line">        const exposed &#x3D; instance.exposed || (instance.exposed &#x3D; proxyRefs(&#123;&#125;))</span><br><span class="line">        expose.forEach(key &#x3D;&gt; &#123;</span><br><span class="line">          exposed[key] &#x3D; toRef(publicThis, key as any)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else if (!instance.exposed) &#123;</span><br><span class="line">        instance.exposed &#x3D; EMPTY_OBJ</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(&#96;The \&#96;expose\&#96; option is ignored when used in mixins.&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法主要处理Vue2的属性的兼容处理，在处理之前调用了组件的生命周期<code>beforeCreate</code>方法，处理后调用了组件的<code>created</code>方法。</p>
<h3 id="beforeCreate生命周期"><a href="#beforeCreate生命周期" class="headerlink" title="beforeCreate生命周期"></a>beforeCreate生命周期</h3><p>由上述方法<code>applyOptions</code>可得，在<code>beforeCreated</code>方法中无法访问<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>等属性，只能访问<code>props</code>、<code>attrs</code>、<code>setupState</code>等内容。</p>
<h3 id="created生命周期"><a href="#created生命周期" class="headerlink" title="created生命周期"></a>created生命周期</h3><p>当组件完成初始化并设置完成后，组件才算创建完成，调用<code>created</code>生命周期提示“组件已经创建完成”。此时可以访问除渲染过程才有的其他所有属性。</p>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul>
<li>mixin：混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（三）</title>
    <url>/post/530050501.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/%E7%BB%93%E5%90%88Vue3-demo%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89.html">结合Vue3-demo项目分析源码（二）</a>，创建完App实例，开始创建组件。接上篇<code>mountComponent()</code>方法，调用了<code>createComponentInstance</code>方法创建了一个初始化状态的组件实例<code>instance</code>，接下来就根据组件的定义设置此组件实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mountComponent: MountComponentFn &#x3D; (</span><br><span class="line">    ...</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;创建组件实例</span><br><span class="line">    const instance: ComponentInternalInstance &#x3D; (initialVNode.component &#x3D; createComponentInstance(...))</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置组件实例</span><br><span class="line">    setupComponent(instance)</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;处理setup方法</span><br><span class="line">    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense,isSVG, optimized)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="setupComponent"><a href="#setupComponent" class="headerlink" title="setupComponent()"></a>setupComponent()</h3><blockquote>
<p>创建组件实例</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/component.ts</code>第520行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function setupComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR &#x3D; false</span><br><span class="line">) &#123;</span><br><span class="line">  isInSSRComponentSetup &#x3D; isSSR</span><br><span class="line"></span><br><span class="line">  const &#123; props, children, shapeFlag &#125; &#x3D; instance.vnode</span><br><span class="line">  const isStateful &#x3D; shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT</span><br><span class="line">  &#x2F;&#x2F;初始化属性</span><br><span class="line">  initProps(instance, props, isStateful, isSSR)</span><br><span class="line">  &#x2F;&#x2F;初始化插槽</span><br><span class="line">  initSlots(instance, children)</span><br><span class="line">  &#x2F;&#x2F;处理setup函数</span><br><span class="line">  const setupResult &#x3D; isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR)</span><br><span class="line">    : undefined</span><br><span class="line">  isInSSRComponentSetup &#x3D; false</span><br><span class="line">  return setupResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="initProps"><a href="#initProps" class="headerlink" title="initProps()"></a>initProps()</h3><blockquote>
<p>初始化属性</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/componentProps.ts</code>第129行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initProps(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  rawProps: Data | null,</span><br><span class="line">  isStateful: number, &#x2F;&#x2F; result of bitwise flag comparison</span><br><span class="line">  isSSR &#x3D; false</span><br><span class="line">) &#123;</span><br><span class="line">  const props: Data &#x3D; &#123;&#125;</span><br><span class="line">  const attrs: Data &#x3D; &#123;&#125;</span><br><span class="line">  def(attrs, InternalObjectKey, 1)</span><br><span class="line">  &#x2F;&#x2F;设置属性</span><br><span class="line">  setFullProps(instance, rawProps, props, attrs)</span><br><span class="line">  &#x2F;&#x2F; validation</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    validateProps(props, instance)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  if (isStateful) &#123; &#x2F;&#x2F;普通组件</span><br><span class="line">    &#x2F;&#x2F; stateful</span><br><span class="line">    &#x2F;&#x2F;非服务端渲染时，默认将属性变成浅层响应式对象</span><br><span class="line">    instance.props &#x3D; isSSR ? props : shallowReactive(props)</span><br><span class="line">  &#125; else &#123;  &#x2F;&#x2F;Element类型和函数组件</span><br><span class="line">    &#x2F;&#x2F;如果组件没有提供属性，则把它全部attrs当作他的属性</span><br><span class="line">    if (!instance.type.props) &#123;</span><br><span class="line">      &#x2F;&#x2F; functional w&#x2F; optional props, props &#x3D;&#x3D;&#x3D; attrs</span><br><span class="line">      instance.props &#x3D; attrs</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; functional w&#x2F; declared props</span><br><span class="line">      instance.props &#x3D; props</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  instance.attrs &#x3D; attrs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="理解普通组件和其他组件（Element类型和函数组件）属性设置"><a href="#理解普通组件和其他组件（Element类型和函数组件）属性设置" class="headerlink" title="理解普通组件和其他组件（Element类型和函数组件）属性设置"></a>理解普通组件和其他组件（Element类型和函数组件）属性设置</h4><p>方法<code>initProps()</code>中；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isStateful) &#123; &#x2F;&#x2F;普通组件</span><br><span class="line">    &#x2F;&#x2F; stateful</span><br><span class="line">    &#x2F;&#x2F;非服务端渲染时，默认将属性变成浅层响应式对象</span><br><span class="line">    instance.props &#x3D; isSSR ? props : shallowReactive(props)</span><br><span class="line">&#125; else &#123;  &#x2F;&#x2F;Element类型和函数组件</span><br><span class="line">    &#x2F;&#x2F;如果组件没有提供属性，则把它全部attrs当作他的属性</span><br><span class="line">    if (!instance.type.props) &#123;</span><br><span class="line">      &#x2F;&#x2F; functional w&#x2F; optional props, props &#x3D;&#x3D;&#x3D; attrs</span><br><span class="line">      instance.props &#x3D; attrs</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; functional w&#x2F; declared props</span><br><span class="line">      instance.props &#x3D; props</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>普通组件</li>
</ol>
<p>原<code>app</code>即为普通组件，不是函数式也不是Element类型。故默认将它设置成浅层响应式对象<code>shallowReactive</code></p>
<blockquote>
<p>浅层响应式对象：只为某个对象的私有（第一层）属性创建浅层的响应式代理，不会对“属性的属性”做深层次、递归地响应式代理，而只是保留原样</p>
</blockquote>
<p>在<code>App.vue</code>添加一个属性<code>user</code>，设置其被点击就更改<code>user.name</code>字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; msg &#125;&#125;</span><br><span class="line">        &#123;&#123; testWord &#125;&#125;</span><br><span class="line">        &lt;div @click&#x3D;&quot;user.name &#x3D; &#39;aaa&#39;&quot;&gt;我是：&#123;&#123; user &amp;&amp; user.name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;app&quot;,</span><br><span class="line">    props: [&quot;msg&quot;, &quot;testWord&quot;,&quot;user&quot;],</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(&quot;this对象如上&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>并且在<code>main.js</code>文件将其改为响应式对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const app &#x3D; createApp(App, &#123; </span><br><span class="line">    msg: &quot;hello&quot;, </span><br><span class="line">    msg1: &quot;vue&quot;,</span><br><span class="line">    &quot;test-word&quot;: &quot;我是用 “-” 符号传递的属性&quot;,</span><br><span class="line">    user: reactive(&#123;name: &quot;testname&quot;&#125;)</span><br><span class="line">&#125;);&#x2F;&#x2F;渲染App组件，传递msg参数</span><br></pre></td></tr></table></figure>

<p>则通过点击，该属性的name变成了<code>aaa</code>。但此对象仅其自有属性<code>name</code>为响应式，而其属性仍为非响应式，即仅有第一层</p>
<ol start="2">
<li>Element类型及函数类型</li>
</ol>
<p>并且在<code>main.js</code>文件新增函数类型组件，并为其添加属性<code>msg</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const AppWrapper &#x3D; (props) &#x3D;&gt; &#123;&#x2F;&#x2F;函数式组件</span><br><span class="line">    return h(&quot;div&quot;,[h(App,props)]);</span><br><span class="line">&#125;;</span><br><span class="line">AppWrapper.props &#x3D; &#123;&#x2F;&#x2F;给函数式组件设置属性</span><br><span class="line">    msg: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const app &#x3D; createApp(AppWrapper, &#123; </span><br><span class="line">    msg: &quot;hello&quot;, </span><br><span class="line">    msg1: &quot;vue&quot;,</span><br><span class="line">    &quot;test-word&quot;: &quot;我是用 “-” 符号传递的属性&quot;,</span><br><span class="line">    user: reactive(&#123;name: &quot;testname&quot;&#125;)</span><br><span class="line">&#125;);&#x2F;&#x2F;渲染App组件，传递msg参数</span><br><span class="line">app.mount(&quot;#app&quot;)&#x2F;&#x2F;渲染app，将其挂载到id&#x3D;app的节点上</span><br></pre></td></tr></table></figure>

<p>则其定义的属性attr<code>msg</code>被作为prop，其他属性则被当作<code>attrs</code>传递</p>
<p><img src="https://z3.ax1x.com/2021/05/26/29vbQK.png" alt="attrs"></p>
<h3 id="setFullProps"><a href="#setFullProps" class="headerlink" title="setFullProps()"></a>setFullProps()</h3><blockquote>
<p>设置属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setFullProps(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  rawProps: Data | null,</span><br><span class="line">  props: Data,</span><br><span class="line">  attrs: Data</span><br><span class="line">) &#123;</span><br><span class="line">  const [options, needCastKeys] &#x3D; instance.propsOptions</span><br><span class="line">  if (rawProps) &#123;</span><br><span class="line">    for (const key in rawProps) &#123;</span><br><span class="line">      const value &#x3D; rawProps[key]</span><br><span class="line">      &#x2F;&#x2F; key, ref are reserved and never passed down</span><br><span class="line">      if (isReservedProp(key)) &#123;</span><br><span class="line">        continue</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; prop option names are camelized during normalization, so to support kebab -&gt; camel conversion here we need to camelize the key.</span><br><span class="line">      let camelKey</span><br><span class="line">      &#x2F;&#x2F;如果有给组件传递的参数，并在当前组件中定义了该参数。就把传递的参数传给当前组件</span><br><span class="line">      if (options &amp;&amp; hasOwn(options, (camelKey &#x3D; camelize(key)))) &#123;</span><br><span class="line">        props[camelKey] &#x3D; value</span><br><span class="line">      &#125; else if (!isEmitListener(instance.emitsOptions, key)) &#123;</span><br><span class="line">        &#x2F;&#x2F;否则把传递的属性传给attrs</span><br><span class="line">        attrs[key] &#x3D; value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;传递的属性中是否含有 - 符号定义的属性，有的话就获取该属性</span><br><span class="line">  if (needCastKeys) &#123;</span><br><span class="line">    const rawCurrentProps &#x3D; toRaw(props)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; needCastKeys.length; i++) &#123;</span><br><span class="line">      const key &#x3D; needCastKeys[i]</span><br><span class="line">      props[key] &#x3D; resolvePropValue(</span><br><span class="line">        options!,</span><br><span class="line">        rawCurrentProps,</span><br><span class="line">        key,</span><br><span class="line">        rawCurrentProps[key],</span><br><span class="line">        instance</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h4><ol>
<li>理解属性传递部分</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (options &amp;&amp; hasOwn(options, (camelKey &#x3D; camelize(key)))) &#123;</span><br><span class="line">    props[camelKey] &#x3D; value</span><br><span class="line">&#125; else if (!isEmitListener(instance.emitsOptions, key)) &#123;</span><br><span class="line">    &#x2F;&#x2F;否则把传递的属性传给attrs</span><br><span class="line">    attrs[key] &#x3D; value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即若给<code>app</code>添加两个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const app &#x3D; createApp(App, &#123; msg: &quot;hello&quot;, msg1: &quot;vue&quot; &#125;);</span><br></pre></td></tr></table></figure>

<p>此时，<code>App.vue</code>中<code>&lt;template&gt;</code>没有定义根元素，仅为<code>&lt;template&gt;&lt;/template&gt;</code>。故Vue自动帮它加了一个<code>Fragment</code>片段，故无法显示</p>
<p>当给<code>App.vue</code>加上根节点<code>&lt;div&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;app&quot;,</span><br><span class="line">    props: [&quot;msg&quot;],</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(&quot;this对象如上&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>由于在<code>&lt;script&gt;</code>仅给组件传递了参数<code>msg</code>，故<code>msg1</code>被当作属性给<code>attrs</code></p>
<p><img src="https://z3.ax1x.com/2021/05/26/29qxmj.png" alt="29qxmj.png"></p>
<ol start="2">
<li>理解“-”符号定义的属性部分</li>
</ol>
<p>含有“-”符号定义的属性即在<code>App.vue</code>中定义的类似于<code>testWord</code>含有大写的驼峰命名法定义的属性。在被挂载到app上时，会被命名为<code>test-word</code>。故需要对类似的属性进行处理</p>
<h3 id="initSlots"><a href="#initSlots" class="headerlink" title="initSlots()"></a>initSlots()</h3><blockquote>
<p>初始化插槽</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/componentSlots.ts</code>第109行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const initSlots &#x3D; (</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  children: VNodeNormalizedChildren</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;创建节点时传递的children为对象时</span><br><span class="line">  if (instance.vnode.shapeFlag &amp; ShapeFlags.SLOTS_CHILDREN) &#123;</span><br><span class="line">    const type &#x3D; (children as RawSlots)._</span><br><span class="line">    if (type) &#123;</span><br><span class="line">      instance.slots &#x3D; children as InternalSlots</span><br><span class="line">      &#x2F;&#x2F; make compiler marker non-enumerable</span><br><span class="line">      def(children as InternalSlots, &#39;_&#39;, type)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      normalizeObjectSlots(children as RawSlots, (instance.slots &#x3D; &#123;&#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;&#x2F;&#x2F;当传递的children为数组时，直接在slots里暴露一下default方法</span><br><span class="line">    instance.slots &#x3D; &#123;&#125;</span><br><span class="line">    if (children) &#123;</span><br><span class="line">      normalizeVNodeSlots(instance, children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def(instance.slots, InternalObjectKey, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有状态组件vs无状态组件"><a href="#有状态组件vs无状态组件" class="headerlink" title="有状态组件vs无状态组件"></a>有状态组件vs无状态组件</h4><ul>
<li><p>有状态组件：需要维护内部状态的组件。通常被称为容器container，通常会包含若干无状态组件。如<code>App.vue</code>此类<code>SFC</code>组件，可以利用<code>data</code>或<code>setup</code>方法定义自己的状态</p>
</li>
<li><p>无状态组件：不需要维护状态的组件，自己没有数据，要么是纯渲染的html内容，要么数据都是来自上层结构。如上面的函数组件<code>AppWrapper</code> </p>
</li>
</ul>
<p>查看文件<code>vue-next/vue-next/packages/shared/src/shapeFlags.ts</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const enum ShapeFlags &#123;</span><br><span class="line">  &#x2F;&#x2F;无状态组件</span><br><span class="line">  ELEMENT &#x3D; 1,  &#x2F;&#x2F;dom元素类型，如div、span等普通dom标签</span><br><span class="line">  FUNCTIONAL_COMPONENT &#x3D; 1 &lt;&lt; 1,  &#x2F;&#x2F;函数式类型，如AppWrapper</span><br><span class="line">  &#x2F;&#x2F;有状态组件 </span><br><span class="line">  STATEFUL_COMPONENT &#x3D; 1 &lt;&lt; 2,  &#x2F;&#x2F;静态类型，如svg标签</span><br><span class="line">  TEXT_CHILDREN &#x3D; 1 &lt;&lt; 3, &#x2F;&#x2F;文本节点类型</span><br><span class="line">  ARRAY_CHILDREN &#x3D; 1 &lt;&lt; 4,  &#x2F;&#x2F;创建节点时传递的子节点是数组时</span><br><span class="line">  SLOTS_CHILDREN &#x3D; 1 &lt;&lt; 5,  &#x2F;&#x2F;创建节点时传递的子节点是对象时</span><br><span class="line">  TELEPORT &#x3D; 1 &lt;&lt; 6,  &#x2F;&#x2F;TELEPORT组件</span><br><span class="line">  SUSPENSE &#x3D; 1 &lt;&lt; 7,  &#x2F;&#x2F;SUSPENSE组件</span><br><span class="line">  COMPONENT_SHOULD_KEEP_ALIVE &#x3D; 1 &lt;&lt; 8, &#x2F;&#x2F;keep-alive组件的子组件</span><br><span class="line">  COMPONENT_KEPT_ALIVE &#x3D; 1 &lt;&lt; 9,  &#x2F;&#x2F;keep-alive组件</span><br><span class="line">  COMPONENT &#x3D; ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setupStatefulComponent"><a href="#setupStatefulComponent" class="headerlink" title="setupStatefulComponent()"></a>setupStatefulComponent()</h3><blockquote>
<p>设置有状态组件</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/component.ts</code>第538行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setupStatefulComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const Component &#x3D; instance.type as ComponentOptions</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 0. create render proxy property access cache</span><br><span class="line">  instance.accessCache &#x3D; Object.create(null)</span><br><span class="line">  &#x2F;&#x2F; 1. create public instance &#x2F; render proxy also mark it raw so it&#39;s never observed</span><br><span class="line">  &#x2F;&#x2F;创建当前组件实例的代理对象，即demo项目打印出的this对象</span><br><span class="line">  instance.proxy &#x3D; new Proxy(instance.ctx, PublicInstanceProxyHandlers)</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 2. call setup()</span><br><span class="line">  const &#123; setup &#125; &#x3D; Component</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当通过<code>Proxy</code>访问<code>instance</code>属性时，需要经过方法<code>PublicInstanceProxyHandlers</code></p>
<h3 id="PublicInstanceProxyHandlers"><a href="#PublicInstanceProxyHandlers" class="headerlink" title="PublicInstanceProxyHandlers"></a>PublicInstanceProxyHandlers</h3><p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/componentPublicInstance.ts</code>第243行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const PublicInstanceProxyHandlers: ProxyHandler&lt;any&gt; &#x3D; &#123;</span><br><span class="line">  get(&#123; _: instance &#125;: ComponentRenderContext, key: string) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;当使用组件用this访问不带’$‘的属性时</span><br><span class="line">    if (key[0] !&#x3D;&#x3D; &#39;$&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F;查看缓存中是否存在</span><br><span class="line">      const n &#x3D; accessCache![key]</span><br><span class="line">      &#x2F;&#x2F;缓存中存在，按顺序获取</span><br><span class="line">      if (n !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        switch (n) &#123;</span><br><span class="line">          &#x2F;&#x2F;1.从setupState中获取</span><br><span class="line">          case AccessTypes.SETUP:</span><br><span class="line">            return setupState[key]</span><br><span class="line">          &#x2F;&#x2F;2.从data中获取</span><br><span class="line">          case AccessTypes.DATA:</span><br><span class="line">            return data[key]</span><br><span class="line">          &#x2F;&#x2F;3.从组件上下文对象中获取</span><br><span class="line">          case AccessTypes.CONTEXT:</span><br><span class="line">            return ctx[key]</span><br><span class="line">          &#x2F;&#x2F;4.从组件属性里获取</span><br><span class="line">          case AccessTypes.PROPS:</span><br><span class="line">            return props![key]</span><br><span class="line">          &#x2F;&#x2F; default: just fallthrough</span><br><span class="line">        &#125;</span><br><span class="line">      &#x2F;&#x2F;缓存中不存在，则按以下顺序获取</span><br><span class="line">      &#125; else if (setupState !&#x3D;&#x3D; EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) &#123; </span><br><span class="line">        &#x2F;&#x2F;1.从setupState中获取，并存入缓存</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.SETUP</span><br><span class="line">        return setupState[key]</span><br><span class="line">      &#125; else if (data !&#x3D;&#x3D; EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        &#x2F;&#x2F;2.从data中获取，并存入缓存</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.DATA</span><br><span class="line">        return data[key]</span><br><span class="line">      &#125; else if (</span><br><span class="line">        &#x2F;&#x2F; only cache other properties when instance has declared (thus stable)</span><br><span class="line">        &#x2F;&#x2F; props</span><br><span class="line">        (normalizedProps &#x3D; instance.propsOptions[0]) &amp;&amp;</span><br><span class="line">        hasOwn(normalizedProps, key)</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F;3.从组件属性props中获取，并存入缓存</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.PROPS</span><br><span class="line">        return props![key]</span><br><span class="line">      &#125; else if (ctx !&#x3D;&#x3D; EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">        &#x2F;&#x2F;4.最后从组件上下文对象中获取，并存入缓存</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.CONTEXT</span><br><span class="line">        return ctx[key]</span><br><span class="line">      &#125; else if (!__FEATURE_OPTIONS_API__ || !isInBeforeCreate) &#123;</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.OTHER</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    const publicGetter &#x3D; publicPropertiesMap[key]</span><br><span class="line">    let cssModule, globalProperties</span><br><span class="line">    &#x2F;&#x2F; public $xxx properties</span><br><span class="line">    &#x2F;&#x2F;获取带‘$‘的公共属性，如$el、$data、$props等</span><br><span class="line">    if (publicGetter) &#123;</span><br><span class="line">      if (key &#x3D;&#x3D;&#x3D; &#39;$attrs&#39;) &#123;</span><br><span class="line">        track(instance, TrackOpTypes.GET, key)</span><br><span class="line">        __DEV__ &amp;&amp; markAttrsAccessed()</span><br><span class="line">      &#125;</span><br><span class="line">      return publicGetter(instance)</span><br><span class="line">    &#125; else if (</span><br><span class="line">      &#x2F;&#x2F; css module (injected by vue-loader)</span><br><span class="line">      (cssModule &#x3D; type.__cssModules) &amp;&amp;</span><br><span class="line">      (cssModule &#x3D; cssModule[key])</span><br><span class="line">    ) &#123;</span><br><span class="line">      return cssModule</span><br><span class="line">    &#125; else if (ctx !&#x3D;&#x3D; EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">      &#x2F;&#x2F; user may set custom properties to &#96;this&#96; that start with &#96;$&#96;</span><br><span class="line">      accessCache![key] &#x3D; AccessTypes.CONTEXT</span><br><span class="line">      return ctx[key]</span><br><span class="line">    &#125; else if (</span><br><span class="line">      &#x2F;&#x2F;前面方法都找不到则到app全局对象中找</span><br><span class="line">      &#x2F;&#x2F; global properties</span><br><span class="line">      ((globalProperties &#x3D; appContext.config.globalProperties),</span><br><span class="line">      hasOwn(globalProperties, key))</span><br><span class="line">    ) &#123;</span><br><span class="line">      return globalProperties[key]</span><br><span class="line">    &#125; else if (</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      currentRenderingInstance &amp;&amp;</span><br><span class="line">      (!isString(key) ||</span><br><span class="line">        &#x2F;&#x2F; #1091 avoid internal isRef&#x2F;isVNode checks on component instance leading</span><br><span class="line">        &#x2F;&#x2F; to infinite warning loop</span><br><span class="line">        key.indexOf(&#39;__v&#39;) !&#x3D;&#x3D; 0)</span><br><span class="line">    ) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Vue3新增的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else if (</span><br><span class="line">    &#x2F;&#x2F;前面方法都找不到则到app全局对象中找</span><br><span class="line">    &#x2F;&#x2F; global properties</span><br><span class="line">    ((globalProperties &#x3D; appContext.config.globalProperties), hasOwn(globalProperties, key))</span><br><span class="line">    ) &#123;</span><br><span class="line">      return globalProperties[key]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Vue3不再以一个Vue对象的形式创建组件，而使用组合式API，故不能在Vue原形上绑定一些全局的属性，但Vue3在app对象上暴露了<code>globalProperties</code>供使用。</p>
<p>在定义全局<code>api</code>时，建议使用<code>$</code>来定义，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js文件添加一个全局的 $showSuccuessDialog 方法</span><br><span class="line">app.config.globalProperties.$showSuccuessDialog &#x3D; function (msg) &#123;</span><br><span class="line">  alert(msg);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; App.vue文件中调用全局的方法</span><br><span class="line">this.$showSuccuessDialog(&quot;我是全局的 showSuccuessDialog 方法&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由方法<code>PublicInstanceProxyHandlers</code>得知，当获取<code>$</code>开头的属性时，可以绕过<code>setState</code>、<code>data</code>、<code>prop</code>等前置条件，可以更快的取到全局属性，从而提升性能效率。</p>
</blockquote>
<h2 id="附录-Vue3流程图"><a href="#附录-Vue3流程图" class="headerlink" title="附录-Vue3流程图"></a>附录-Vue3流程图</h2><p><img src="https://z3.ax1x.com/2021/05/26/2pvc1f.md.jpg" alt="vue流程图"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（二）</title>
    <url>/post/1384730263.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/%E7%BB%93%E5%90%88Vue3-demo%E9%A1%B9%E7%9B%AE%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89.html">结合Vue3-demo项目分析源码（一）</a>，创建完App组件，开始使用<code>mount</code>方法渲染app</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="mount"><a href="#mount" class="headerlink" title="mount()"></a>mount()</h3><blockquote>
<p>渲染app</p>
</blockquote>
<p>查看源码项目<code>vue-next/packages/runtime-dom/src/index.ts</code>中<code>createApp()</code>，其中<code>app.mount</code>被重写了。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.mount &#x3D; (containerOrSelector: Element | string): any &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;根据传递的选择器获取dom元素</span><br><span class="line">    const container &#x3D; normalizeContainer(containerOrSelector)</span><br><span class="line">    if (!container) return</span><br><span class="line">    const component &#x3D; app._component    &#x2F;&#x2F;若不存在，使用app根组件</span><br><span class="line">    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">      component.template &#x3D; container.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; clear content before mounting</span><br><span class="line">    container.innerHTML &#x3D; &#39;&#39;</span><br><span class="line">    &#x2F;&#x2F;调用app对象原始mount方法，传递给当前根节点元素</span><br><span class="line">    const proxy &#x3D; mount(container)</span><br><span class="line">    container.removeAttribute(&#39;v-cloak&#39;)</span><br><span class="line">    container.setAttribute(&#39;data-v-app&#39;, &#39;&#39;)</span><br><span class="line">    return proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，重写的<code>mount()</code>根据传递的选择器找到dom元素，调用原始<code>mount</code>方法，传递给当前根节点元素。</p>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/apiCreateApp.ts</code>第227行原始<code>mount</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount(rootContainer: HostElement, isHydrate?: boolean): any &#123;</span><br><span class="line">if (!isMounted) &#123;&#x2F;&#x2F;第一次渲染</span><br><span class="line">    &#x2F;&#x2F;创建Vnode节点</span><br><span class="line">    const vnode &#x3D; createVNode(</span><br><span class="line">        rootComponent as ConcreteComponent,</span><br><span class="line">        rootProps</span><br><span class="line">    )</span><br><span class="line">    &#x2F;&#x2F; store app context on the root VNode.</span><br><span class="line">    &#x2F;&#x2F; this will be set on the root instance on initial mount.</span><br><span class="line">    vnode.appContext &#x3D; context&#x2F;&#x2F;节点上下文为根节点上下文</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; HMR root reload</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">        context.reload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            render(cloneVNode(vnode), rootContainer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;支持自定义渲染</span><br><span class="line">    if (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">        &#x2F;&#x2F;自定义渲染</span><br><span class="line">        hydrate(vnode as VNode&lt;Node, Element&gt;, rootContainer as any)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;默认渲染</span><br><span class="line">        render(vnode, rootContainer)</span><br><span class="line">    &#125;</span><br><span class="line">    isMounted &#x3D; true</span><br><span class="line">    app._container &#x3D; rootContainer</span><br><span class="line">    &#x2F;&#x2F; for devtools and telemetry</span><br><span class="line">    ;(rootContainer as any).__vue_app__ &#x3D; app</span><br><span class="line"></span><br><span class="line">    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">        devtoolsInitApp(app, version)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return vnode.component!.proxy</span><br><span class="line">&#125; else if (__DEV__) &#123;</span><br><span class="line">    &#x2F;&#x2F;多次调用mount方法报错</span><br><span class="line">    warn(</span><br><span class="line">    &#96;App has already been mounted.\n&#96; +</span><br><span class="line">        &#96;If you want to remount the same app, move your app creation logic &#96; +</span><br><span class="line">        &#96;into a factory function and create fresh app instances for each &#96; +</span><br><span class="line">        &#96;mount - e.g. \&#96;const createMyApp &#x3D; () &#x3D;&gt; createApp(App)\&#96;&#96;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始<code>mount</code>方法主要创建一个<code>vnode</code>节点，调用<code>render()</code>方法渲染。</p>
<h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><blockquote>
<p>渲染节点</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/renderer.ts</code>第2182行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const render: RootRenderFunction &#x3D; (vnode, container) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;若当前节点为null，则卸载节点</span><br><span class="line">    if (vnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (container._vnode) &#123;</span><br><span class="line">            unmount(container._vnode, null, null, true)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;使用patch方法对比新老节点</span><br><span class="line">        patch(container._vnode || null, vnode, container)</span><br><span class="line">    &#125;</span><br><span class="line">    flushPostFlushCbs()</span><br><span class="line">    container._vnode &#x3D; vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="patch"><a href="#patch" class="headerlink" title="patch()"></a>patch()</h3><blockquote>
<p>对比新老节点，根据节点类型的不同做不同处理</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/renderer.ts</code>第448行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const patch: PatchFn &#x3D; (</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    anchor &#x3D; null,</span><br><span class="line">    parentComponent &#x3D; null,</span><br><span class="line">    parentSuspense &#x3D; null,</span><br><span class="line">    isSVG &#x3D; false,</span><br><span class="line">    optimized &#x3D; false</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; patching &amp; not same type, unmount old tree</span><br><span class="line">    &#x2F;&#x2F;对比新老节点，若类型一样，则卸载老节点</span><br><span class="line">    if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">        anchor &#x3D; getNextHostNode(n1)</span><br><span class="line">        &#x2F;&#x2F;卸载老节点</span><br><span class="line">        unmount(n1, parentComponent, parentSuspense, true)</span><br><span class="line">        n1 &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (n2.patchFlag &#x3D;&#x3D;&#x3D; PatchFlags.BAIL) &#123;</span><br><span class="line">        optimized &#x3D; false</span><br><span class="line">        n2.dynamicChildren &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const &#123; type, ref, shapeFlag &#125; &#x3D; n2</span><br><span class="line">    &#x2F;&#x2F;根据当前节点类型不同做不同处理</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case Text:  &#x2F;&#x2F;文本节点TextNode</span><br><span class="line">            processText(n1, n2, container, anchor)</span><br><span class="line">            break</span><br><span class="line">        case Comment:   &#x2F;&#x2F; 文档注释节点</span><br><span class="line">            processCommentNode(n1, n2, container, anchor)</span><br><span class="line">            break</span><br><span class="line">        case Static:    &#x2F;&#x2F;svg等静态节点</span><br><span class="line">            if (n1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mountStaticNode(n2, container, anchor, isSVG)</span><br><span class="line">            &#125; else if (__DEV__) &#123;</span><br><span class="line">                patchStaticNode(n1, n2, container, isSVG)</span><br><span class="line">            &#125;</span><br><span class="line">            break</span><br><span class="line">      case Fragment:    &#x2F;&#x2F;片段节点</span><br><span class="line">        processFragment(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized</span><br><span class="line">        )</span><br><span class="line">        break</span><br><span class="line">      default: </span><br><span class="line">        &#x2F;&#x2F;普通的dom节点-div、span等</span><br><span class="line">        if (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">            processElement(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized</span><br><span class="line">            )</span><br><span class="line">        &#125; else if (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;&#x2F;&#x2F;Vue组件</span><br><span class="line">            processComponent(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized</span><br><span class="line">            )</span><br><span class="line">        &#125; else if (shapeFlag &amp; ShapeFlags.TELEPORT) &#123;&#x2F;&#x2F;TELEPORT类型</span><br><span class="line">            ;(type as typeof TeleportImpl).process(</span><br><span class="line">            n1 as TeleportVNode,</span><br><span class="line">            n2 as TeleportVNode,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized,</span><br><span class="line">            internals</span><br><span class="line">            )</span><br><span class="line">        &#125; else if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (__DEV__) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; set ref</span><br><span class="line">    if (ref !&#x3D; null &amp;&amp; parentComponent) &#123;</span><br><span class="line">        setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<code>main.js</code>中代码得知，<code>app</code>为<code>vue</code>组件节点，故下一步到<code>processComponent()</code>方法</p>
<h3 id="processComponent"><a href="#processComponent" class="headerlink" title="processComponent()"></a>processComponent()</h3><p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/renderer.ts</code>第1185行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const processComponent &#x3D; (</span><br><span class="line">    n1: VNode | null,</span><br><span class="line">    n2: VNode,</span><br><span class="line">    container: RendererElement,</span><br><span class="line">    anchor: RendererNode | null,</span><br><span class="line">    parentComponent: ComponentInternalInstance | null,</span><br><span class="line">    parentSuspense: SuspenseBoundary | null,</span><br><span class="line">    isSVG: boolean,</span><br><span class="line">    optimized: boolean</span><br><span class="line">  ) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;老节点是否为null(第一次进来的老节点一定是null)</span><br><span class="line">    if (n1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否是COMPONENT_KEPT_ALIVE类型的节点</span><br><span class="line">        if (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) &#123;</span><br><span class="line">            ;(parentComponent!.ctx as KeepAliveContext).activate(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                isSVG,</span><br><span class="line">                optimized</span><br><span class="line">            )</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;普通组件</span><br><span class="line">            mountComponent(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                parentComponent,</span><br><span class="line">                parentSuspense,</span><br><span class="line">                isSVG,</span><br><span class="line">                optimized</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F;若老节点不为空，更新组件</span><br><span class="line">        updateComponent(n1, n2, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>app为首次渲染为null且为普通组件，故调用<code>mountomponent()</code>方法</p>
<h3 id="mountomponent"><a href="#mountomponent" class="headerlink" title="mountomponent()"></a>mountomponent()</h3><p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/renderer.ts</code>第1220行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mountComponent: MountComponentFn &#x3D; (</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;创建组件实例</span><br><span class="line">    const instance: ComponentInternalInstance &#x3D; (initialVNode.component &#x3D; createComponentInstance(</span><br><span class="line">        initialVNode,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense</span><br><span class="line">    ))</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置组件实例</span><br><span class="line">    setupComponent(instance)</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;处理setup方法</span><br><span class="line">    setupRenderEffect(</span><br><span class="line">        instance,</span><br><span class="line">        initialVNode,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createComponentInstance"><a href="#createComponentInstance" class="headerlink" title="createComponentInstance()"></a>createComponentInstance()</h4><blockquote>
<p>创建组件实例</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/component.ts</code>第405行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createComponentInstance(</span><br><span class="line">  vnode: VNode,</span><br><span class="line">  parent: ComponentInternalInstance | null,</span><br><span class="line">  suspense: SuspenseBoundary | null</span><br><span class="line">) &#123;</span><br><span class="line">  const type &#x3D; vnode.type as ConcreteComponent</span><br><span class="line">  &#x2F;&#x2F; inherit parent app context - or - if root, adopt from root vnode</span><br><span class="line">  const appContext &#x3D;</span><br><span class="line">    (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><br><span class="line"></span><br><span class="line">  const instance: ComponentInternalInstance &#x3D; &#123;</span><br><span class="line">    uid: uid++, &#x2F;&#x2F;唯一标识</span><br><span class="line">    vnode,  &#x2F;&#x2F;当前组件的vnode节点</span><br><span class="line">    type,   &#x2F;&#x2F;组件类型</span><br><span class="line">    parent, &#x2F;&#x2F;父组件</span><br><span class="line">    appContext, &#x2F;&#x2F;app上下文</span><br><span class="line">    root: null!, &#x2F;&#x2F; to be immediately set</span><br><span class="line">    next: null,</span><br><span class="line">    subTree: null!, &#x2F;&#x2F; will be set synchronously right after creation</span><br><span class="line">    update: null!, &#x2F;&#x2F; will be set synchronously right after creation</span><br><span class="line">    render: null,</span><br><span class="line">    proxy: null,    &#x2F;&#x2F;组件实例代理对象（组件里用this访问的即为此对象</span><br><span class="line">    exposed: null,</span><br><span class="line">    withProxy: null,</span><br><span class="line">    effects: null,</span><br><span class="line">    provides: parent ? parent.provides : Object.create(appContext.provides),</span><br><span class="line">    accessCache: null!,</span><br><span class="line">    renderCache: [],</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; local resovled assets</span><br><span class="line">    components: null,</span><br><span class="line">    directives: null,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; resolved props and emits options</span><br><span class="line">    propsOptions: normalizePropsOptions(type, appContext),</span><br><span class="line">    emitsOptions: normalizeEmitsOptions(type, appContext),</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; emit</span><br><span class="line">    emit: null as any, &#x2F;&#x2F; to be set immediately</span><br><span class="line">    emitted: null,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; state</span><br><span class="line">    ctx: EMPTY_OBJ,</span><br><span class="line">    data: EMPTY_OBJ,</span><br><span class="line">    props: EMPTY_OBJ,</span><br><span class="line">    attrs: EMPTY_OBJ,</span><br><span class="line">    slots: EMPTY_OBJ,</span><br><span class="line">    refs: EMPTY_OBJ,</span><br><span class="line">    setupState: EMPTY_OBJ,</span><br><span class="line">    setupContext: null,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; suspense related</span><br><span class="line">    suspense,</span><br><span class="line">    suspenseId: suspense ? suspense.pendingId : 0,</span><br><span class="line">    asyncDep: null,</span><br><span class="line">    asyncResolved: false,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; lifecycle hooks</span><br><span class="line">    &#x2F;&#x2F; not using enums here because it results in computed properties</span><br><span class="line">    isMounted: false,</span><br><span class="line">    isUnmounted: false,</span><br><span class="line">    isDeactivated: false,</span><br><span class="line">    bc: null,</span><br><span class="line">    c: null,</span><br><span class="line">    bm: null,</span><br><span class="line">    m: null,</span><br><span class="line">    bu: null,</span><br><span class="line">    u: null,</span><br><span class="line">    um: null,</span><br><span class="line">    bum: null,</span><br><span class="line">    da: null,</span><br><span class="line">    a: null,</span><br><span class="line">    rtg: null,</span><br><span class="line">    rtc: null,</span><br><span class="line">    ec: null</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  instance.root &#x3D; parent ? parent.root : instance</span><br><span class="line">  instance.emit &#x3D; emit.bind(null, instance)</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;返回实例</span><br><span class="line">  return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件实例中<code>proxy</code>即为在组件里用<code>this</code>访问的对象。Vue只暴露组件实例的一部分属性供访问，这些属性只能通过代理对象<code>proxy</code>获取。</p>
<p>在<code>App.vue</code>中加入代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;app&quot;,</span><br><span class="line">    props: [&quot;msg&quot;],</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(&quot;this对象如上&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>则在浏览其中可看到：</p>
<p><img src="https://z3.ax1x.com/2021/05/26/29INWQ.png" alt="this对象"></p>
<h2 id="附录-Vue3流程图"><a href="#附录-Vue3流程图" class="headerlink" title="附录-Vue3流程图"></a>附录-Vue3流程图</h2><p><img src="https://z3.ax1x.com/2021/05/26/2pvc1f.md.jpg" alt="vue流程图"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（一）</title>
    <url>/post/1654628943.html</url>
    <content><![CDATA[<p>Vue3-demo项目即为先前<a href="https://awesolynn.me/%E4%BB%8E0%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93vue3%E9%A1%B9%E7%9B%AE.html">从0搭建简易vue3项目</a>中搭建的demo</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>入口文件<code>main.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;;&#x2F;&#x2F;引入Vue3源码</span><br><span class="line">import App from &quot;.&#x2F;App&quot;;&#x2F;&#x2F;引入App.vue组件</span><br><span class="line">const app &#x3D; createApp(App,&#123;msg:&quot;Hello Vue&quot;&#125;)&#x2F;&#x2F;创建App组件，传递msg参数</span><br><span class="line"></span><br><span class="line">app.mount(&quot;#app&quot;)&#x2F;&#x2F;渲染app，将其挂载到id&#x3D;app的节点上</span><br></pre></td></tr></table></figure>

<p>通过在浏览器上不同位置打断点，可以按步骤流程分析Vue源码的实现流程。</p>
<a id="more"></a>

<p><img src="https://z3.ax1x.com/2021/05/26/29Iz0P.png" alt="断点"></p>
<h3 id="创建app应用实例"><a href="#创建app应用实例" class="headerlink" title="创建app应用实例"></a>创建app应用实例</h3><h4 id="createApp"><a href="#createApp" class="headerlink" title="createApp()"></a>createApp()</h4><blockquote>
<p>创建app对象，即应用实例</p>
</blockquote>
<p>查看源码项目<code>vue-next/packages/runtime-dom/src/index.ts</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const createApp &#x3D; ((...args) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;创建app对象</span><br><span class="line">  const app &#x3D; ensureRenderer().createApp(...args)</span><br><span class="line"></span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    injectNativeTagCheck(app)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const &#123; mount &#125; &#x3D; app</span><br><span class="line">  &#x2F;&#x2F;重写app的mount方法</span><br><span class="line">  app.mount &#x3D; (containerOrSelector: Element | string): any &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;根据传递的选择器获取dom元素</span><br><span class="line">    const container &#x3D; normalizeContainer(containerOrSelector)</span><br><span class="line">    if (!container) return</span><br><span class="line">    const component &#x3D; app._component</span><br><span class="line">    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">      component.template &#x3D; container.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; clear content before mounting</span><br><span class="line">    container.innerHTML &#x3D; &#39;&#39;</span><br><span class="line">    const proxy &#x3D; mount(container)</span><br><span class="line">    container.removeAttribute(&#39;v-cloak&#39;)</span><br><span class="line">    container.setAttribute(&#39;data-v-app&#39;, &#39;&#39;)</span><br><span class="line">    return proxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return app</span><br><span class="line">&#125;) as CreateAppFunction&lt;Element&gt;</span><br></pre></td></tr></table></figure>

<p>其中，创建app的代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建app对象</span><br><span class="line">const app &#x3D; ensureRenderer().createApp(...args)</span><br></pre></td></tr></table></figure>

<p>查看<code>ensureRenderer()</code>方法定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ensureRenderer() &#123;</span><br><span class="line">  return renderer || (renderer &#x3D; createRenderer&lt;Node, Element&gt;(rendererOptions))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>ensureRenderer()</code>通过使用<code>createRenderer&lt;Node, Element&gt;(rendererOptions)</code>方法创建app。</p>
<blockquote>
<p>renderer负责Vue3中节点的渲染、对比、更新。</p>
</blockquote>
<h3 id="createRenderer"><a href="#createRenderer" class="headerlink" title="createRenderer()"></a>createRenderer()</h3><blockquote>
<p>创建并返回一个节点渲染引擎</p>
</blockquote>
<p>查看<code>vue-next/packages/runtime-core/src/renderer.ts</code>中391行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createRenderer&lt;</span><br><span class="line">  HostNode &#x3D; RendererNode,</span><br><span class="line">  HostElement &#x3D; RendererElement</span><br><span class="line">&gt;(options: RendererOptions&lt;HostNode, HostElement&gt;) &#123;</span><br><span class="line">  return baseCreateRenderer&lt;HostNode, HostElement&gt;(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用了<code>baseCreateRenderer()</code>方法，查看其定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;用到的一些定义</span><br><span class="line">type PatchFn &#x3D; (</span><br><span class="line">  n1: VNode | null, &#x2F;&#x2F; null means this is a mount</span><br><span class="line">  n2: VNode,</span><br><span class="line">  container: RendererElement,</span><br><span class="line">  anchor?: RendererNode | null,</span><br><span class="line">  parentComponent?: ComponentInternalInstance | null,</span><br><span class="line">  parentSuspense?: SuspenseBoundary | null,</span><br><span class="line">  isSVG?: boolean,</span><br><span class="line">  optimized?: boolean</span><br><span class="line">) &#x3D;&gt; void</span><br><span class="line"></span><br><span class="line">export type MountComponentFn &#x3D; (</span><br><span class="line">  initialVNode: VNode,</span><br><span class="line">  container: RendererElement,</span><br><span class="line">  anchor: RendererNode | null,</span><br><span class="line">  parentComponent: ComponentInternalInstance | null,</span><br><span class="line">  parentSuspense: SuspenseBoundary | null,</span><br><span class="line">  isSVG: boolean,</span><br><span class="line">  optimized: boolean</span><br><span class="line">) &#x3D;&gt; void</span><br><span class="line"></span><br><span class="line">export type RootRenderFunction&lt;HostElement &#x3D; RendererElement&gt; &#x3D; (</span><br><span class="line">  vnode: VNode | null,</span><br><span class="line">  container: HostElement</span><br><span class="line">) &#x3D;&gt; void</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;baseCreateRenderer方法定义</span><br><span class="line">function baseCreateRenderer(</span><br><span class="line">  options: RendererOptions,</span><br><span class="line">  createHydrationFns?: typeof createHydrationFunctions</span><br><span class="line">): any &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;对比两个节点</span><br><span class="line">    const patch: PatchFn &#x3D; (</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    anchor &#x3D; null,</span><br><span class="line">    parentComponent &#x3D; null,</span><br><span class="line">    parentSuspense &#x3D; null,</span><br><span class="line">    isSVG &#x3D; false,</span><br><span class="line">    optimized &#x3D; false</span><br><span class="line">  ) &#x3D;&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;渲染组件</span><br><span class="line">  const mountComponent: MountComponentFn &#x3D; (</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">  ) &#x3D;&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;更新组件</span><br><span class="line">  const updateComponent &#x3D; (n1: VNode, n2: VNode, optimized: boolean) &#x3D;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;卸载组件</span><br><span class="line">  const unmountComponent &#x3D; (</span><br><span class="line">    instance: ComponentInternalInstance,</span><br><span class="line">    parentSuspense: SuspenseBoundary | null,</span><br><span class="line">    doRemove?: boolean</span><br><span class="line">  ) &#x3D;&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;渲染组件</span><br><span class="line">  const render: RootRenderFunction &#x3D; (vnode, container) &#x3D;&gt; &#123;</span><br><span class="line">    if (vnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (container._vnode) &#123;</span><br><span class="line">        unmount(container._vnode, null, null, true)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      patch(container._vnode || null, vnode, container)</span><br><span class="line">    &#125;</span><br><span class="line">    flushPostFlushCbs()</span><br><span class="line">    container._vnode &#x3D; vnode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;返回renderer对象</span><br><span class="line">  return &#123;</span><br><span class="line">    render,</span><br><span class="line">    hydrate,</span><br><span class="line">    createApp: createAppAPI(render, hydrate)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从最后<code>return</code>可看出，最终的app是使用<code>createAppAPI()</code>方法得出。</p>
<h3 id="createAppAPI"><a href="#createAppAPI" class="headerlink" title="createAppAPI()"></a>createAppAPI()</h3><blockquote>
<p>创建并返回一个app实例</p>
</blockquote>
<p>查看文件<code>vue-next/vue-next/packages/runtime-core/src/apiCreateApp.ts</code>第123行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createAppAPI&lt;HostElement&gt;(</span><br><span class="line">  render: RootRenderFunction,</span><br><span class="line">  hydrate?: RootHydrateFunction</span><br><span class="line">): CreateAppFunction&lt;HostElement&gt; &#123;</span><br><span class="line">  return function createApp(rootComponent, rootProps &#x3D; null) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建应用上下文</span><br><span class="line">    const context &#x3D; createAppContext()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;app为方法createApp()最后的返回值，即需要的app实例</span><br><span class="line">    const app: App &#x3D; (context.app &#x3D; &#123;</span><br><span class="line">      _uid: uid++,      &#x2F;&#x2F;唯一标识</span><br><span class="line">      _component: rootComponent as ConcreteComponent,   &#x2F;&#x2F;根组件</span><br><span class="line">      _props: rootProps,    &#x2F;&#x2F;根属性</span><br><span class="line">      _container: null,     &#x2F;&#x2F;根节点</span><br><span class="line">      _context: context,    &#x2F;&#x2F;上下文</span><br><span class="line"></span><br><span class="line">      version,      &#x2F;&#x2F;vue版本号</span><br><span class="line"></span><br><span class="line">      get config() &#123;        &#x2F;&#x2F;获取当前应用的config对象</span><br><span class="line">        return context.config</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      set config(v) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局插件注册-同webpack.config.js中webpack-chain配置use使用</span><br><span class="line">      use(plugin: Plugin, ...options: any[]) &#123;</span><br><span class="line">        if (installedPlugins.has(plugin)) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125; else if (plugin &amp;&amp; isFunction(plugin.install)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin.install(app, ...options)</span><br><span class="line">        &#125; else if (isFunction(plugin)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin(app, ...options)</span><br><span class="line">        &#125; else if (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            &#96;A plugin must either be a function or an object with an &quot;install&quot; &#96; +</span><br><span class="line">              &#96;function.&#96;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局mixin注册</span><br><span class="line">      mixin(mixin: ComponentOptions) &#123;</span><br><span class="line">        ...</span><br><span class="line">        context.mixins.push(mixin)</span><br><span class="line">        ...</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局组件注册</span><br><span class="line">      component(name: string, component?: Component): any &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (!component) &#123;</span><br><span class="line">          return context.components[name]</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        context.components[name] &#x3D; component</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局指令注册</span><br><span class="line">      directive(name: string, directive?: Directive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        context.directives[name] &#x3D; directive</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;渲染当前app</span><br><span class="line">      mount(rootContainer: HostElement, isHydrate?: boolean): any &#123;</span><br><span class="line">        if (!isMounted) &#123;</span><br><span class="line">          const vnode &#x3D; createVNode(</span><br><span class="line">            rootComponent as ConcreteComponent,</span><br><span class="line">            rootProps</span><br><span class="line">          )</span><br><span class="line">          &#x2F;&#x2F; store app context on the root VNode.</span><br><span class="line">          &#x2F;&#x2F; this will be set on the root instance on initial mount.</span><br><span class="line">          vnode.appContext &#x3D; context</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; HMR root reload</span><br><span class="line">          if (__DEV__) &#123;</span><br><span class="line">            context.reload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">              render(cloneVNode(vnode), rootContainer)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">            hydrate(vnode as VNode&lt;Node, Element&gt;, rootContainer as any)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            render(vnode, rootContainer)</span><br><span class="line">          &#125;</span><br><span class="line">          isMounted &#x3D; true</span><br><span class="line">          app._container &#x3D; rootContainer</span><br><span class="line">          &#x2F;&#x2F; for devtools and telemetry</span><br><span class="line">          ;(rootContainer as any).__vue_app__ &#x3D; app</span><br><span class="line"></span><br><span class="line">          if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">            devtoolsInitApp(app, version)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return vnode.component!.proxy</span><br><span class="line">        &#125; else if (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            &#96;App has already been mounted.\n&#96; +</span><br><span class="line">              &#96;If you want to remount the same app, move your app creation logic &#96; +</span><br><span class="line">              &#96;into a factory function and create fresh app instances for each &#96; +</span><br><span class="line">              &#96;mount - e.g. \&#96;const createMyApp &#x3D; () &#x3D;&gt; createApp(App)\&#96;&#96;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;卸载当前app</span><br><span class="line">      unmount() &#123;</span><br><span class="line">        ...</span><br><span class="line">        render(null, app._container)</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局provide注册</span><br><span class="line">      provide(key, value) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; TypeScript doesn&#39;t allow symbols as index type</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;TypeScript&#x2F;issues&#x2F;24587</span><br><span class="line">        context.provides[key as string] &#x3D; value</span><br><span class="line">        return app</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F;返回app对象</span><br><span class="line">    return app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可得，最终返回的app组成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface App&lt;HostElement &#x3D; any&gt; &#123;</span><br><span class="line">  version: string   &#x2F;&#x2F;vue版本</span><br><span class="line">  config: AppConfig &#x2F;&#x2F;全局配置</span><br><span class="line">  use(plugin: Plugin, ...options: any[]): this  &#x2F;&#x2F;全局插件注册</span><br><span class="line">  mixin(mixin: ComponentOptions): this      &#x2F;&#x2F;全局mixin注册</span><br><span class="line">  component(name: string): Component | undefined    &#x2F;&#x2F;全局组件注册</span><br><span class="line">  component(name: string, component: Component): this</span><br><span class="line">  directive(name: string): Directive | undefined    &#x2F;&#x2F;全局指令注册</span><br><span class="line">  directive(name: string, directive: Directive): this</span><br><span class="line">  mount(    &#x2F;&#x2F;渲染app方法</span><br><span class="line">    rootContainer: HostElement | string,</span><br><span class="line">    isHydrate?: boolean</span><br><span class="line">  ): ComponentPublicInstance</span><br><span class="line">  unmount(rootContainer: HostElement | string): void    &#x2F;&#x2F;卸载组件方法</span><br><span class="line">  provide&lt;T&gt;(key: InjectionKey&lt;T&gt; | string, value: T): this &#x2F;&#x2F;全局provide注册</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; internal, but we need to expose these for the server-renderer and devtools</span><br><span class="line">  _uid: number  &#x2F;&#x2F;唯一标识</span><br><span class="line">  _component: ConcreteComponent &#x2F;&#x2F;根组件</span><br><span class="line">  _props: Data | null   &#x2F;&#x2F;根属性</span><br><span class="line">  _container: HostElement | null    &#x2F;&#x2F;根节点</span><br><span class="line">  _context: AppContext  &#x2F;&#x2F;上下文节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故回到<code>main.js</code>文件，创建完app实例，则调用了app的<code>mount</code>方法开始渲染对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;;</span><br><span class="line">import App from &quot;.&#x2F;App&quot;; &#x2F;&#x2F; 引入 App.vue 组件</span><br><span class="line">const app &#x3D; createApp(App, &#123; msg: &quot;hello Vue 3&quot; &#125;); &#x2F;&#x2F; 创建 App 根组件</span><br><span class="line">app.mount(&quot;#app&quot;); &#x2F;&#x2F; 渲染 App</span><br></pre></td></tr></table></figure>

<h2 id="附录-Vue3流程图"><a href="#附录-Vue3流程图" class="headerlink" title="附录-Vue3流程图"></a>附录-Vue3流程图</h2><p><img src="https://z3.ax1x.com/2021/05/26/2pvc1f.md.jpg" alt="vue流程图"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>从0搭建简易vue3项目</title>
    <url>/post/876416960.html</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>创建目录，使用<code>npm init -y</code>初始化项目</p>
</li>
<li><p>使用<code>npm install -D xxx ...</code>命令安装webpack相关依赖</p>
<ul>
<li><p>webpack：webpack编译打包核心库</p>
</li>
<li><p>webpack-cli：webpack指令库</p>
</li>
<li><p>webpack-dev-server：webpack开发者服务框架</p>
</li>
<li><p>webpack-chain：webpack配置工具</p>
</li>
</ul>
</li>
<li><p>创建webpack配置文件<code>webpack.config.js</code></p>
</li>
</ol>
<a id="more"></a>

<ol start="4">
<li>在<code>package.json</code>的<code>scripts</code>字段声明<code>build</code>和<code>dev</code>脚本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;build&quot;: &quot;rimraf dist &amp;&amp; webpack --mode&#x3D;production&quot;,</span><br><span class="line">&quot;dev&quot;: &quot;webpack serve --mode&#x3D;development&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>创建<code>src</code>目录和入口文件<code>src/main.js</code></p>
</li>
<li><p>配置<code>webpack.config.js</code></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line">const config &#x3D; new (require(&quot;webpack-chain&quot;))();</span><br><span class="line">config</span><br><span class="line">.context(path.resolve(__dirname, &quot;.&quot;)) &#x2F;&#x2F; webpack 上下文目录为项目根目录</span><br><span class="line">.entry(&quot;app&quot;) &#x2F;&#x2F; 入口文件名称为 app</span><br><span class="line">.add(&quot;.&#x2F;src&#x2F;main.js&quot;) &#x2F;&#x2F; 入口文件为 .&#x2F;src&#x2F;main.js</span><br><span class="line">.end()</span><br><span class="line">.output.path(path.join(__dirname, &quot;.&#x2F;dist&quot;)) &#x2F;&#x2F; webpack 输出的目录为根目录的 dist 目录</span><br><span class="line">.filename(&quot;[name].[hash:8].js&quot;) &#x2F;&#x2F; 打包出来的 bundle 名称为 &quot;[name].[hash:8].js&quot;</span><br><span class="line">.publicPath(&quot;&#x2F;&quot;) &#x2F;&#x2F; publicpath 配置为 &quot;&#x2F;&quot;</span><br><span class="line">.end();</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>安装Vue3相关依赖</p>
<ul>
<li><p>vue：Vue3源码</p>
</li>
<li><p>vue-loader：.vue文件webpack加载器</p>
</li>
<li><p>@vue/compiler-sfc：vue-loader用来解析sfc（Single File Component）插件</p>
</li>
<li><p>html-webpack-plugin：webpack插件用来自动注入chunks到模版html文件</p>
</li>
</ul>
</li>
<li><p>创建公共目录<code>public</code>和项目入口页面<code>public/index.html</code></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;noscript&gt;your browser should support javascript!&lt;&#x2F;noscript&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- html-webpack-plugin 将自动引入入口文件 --&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>在<code>webpack.config.js</code>文件中配置vue工具(<code>webpack.config.js</code>最终文件见文末附录)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">.resolve.extensions.add(&quot;.js&quot;)</span><br><span class="line">.add(&quot;.vue&quot;) &#x2F;&#x2F; 配置以 .js 等结尾的文件当模块使用的时候都可以省略后缀</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.module.rule(&quot;vue&quot;) &#x2F;&#x2F; vue-loader 相关配置</span><br><span class="line">.test(&#x2F;\.vue$&#x2F;) &#x2F;&#x2F; 匹配 .vue 文件</span><br><span class="line">.use(&quot;vue-loader&quot;)</span><br><span class="line">.loader(&quot;vue-loader&quot;)</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.plugin(&quot;vue-loader-plugin&quot;) &#x2F;&#x2F; vue-loader 必须要添加 vue-loader-plugin</span><br><span class="line">.use(require(&quot;vue-loader&quot;).VueLoaderPlugin, [])</span><br><span class="line">.end()</span><br><span class="line">.plugin(&quot;html&quot;) &#x2F;&#x2F; 添加 html-webpack-plugin 插件</span><br><span class="line">.use(require(&quot;html-webpack-plugin&quot;), [</span><br><span class="line">&#123;</span><br><span class="line">    template: path.resolve(__dirname, &quot;.&#x2F;public&#x2F;index.html&quot;), &#x2F;&#x2F; 指定模版文件</span><br><span class="line">    chunks: [&quot;app&quot;], &#x2F;&#x2F; 指定需要加载的 chunk</span><br><span class="line">    inject: &quot;body&quot;, &#x2F;&#x2F; 指定 script 脚本注入的位置为 body</span><br><span class="line">&#125;,</span><br><span class="line">])</span><br><span class="line">.end()</span><br><span class="line">.devServer.host(&quot;0.0.0.0&quot;) &#x2F;&#x2F; 服务器外部可访问</span><br><span class="line">.disableHostCheck(true) &#x2F;&#x2F; 关闭白名单校验</span><br><span class="line">.contentBase(path.resolve(__dirname, &quot;.&#x2F;public&quot;)) &#x2F;&#x2F; 设置一个 express 静态目录</span><br><span class="line">.historyApiFallback(&#123;</span><br><span class="line">disableDotRule: true, &#x2F;&#x2F; 禁止在链接中使用 &quot;.&quot; 符号</span><br><span class="line">rewrites: [</span><br><span class="line">    &#123; from: &#x2F;^\&#x2F;$&#x2F;, to: &quot;&#x2F;index.html&quot; &#125;, &#x2F;&#x2F; 将所有的 404 响应重定向到 index.html 页面</span><br><span class="line">],</span><br><span class="line">&#125;)</span><br><span class="line">.port(8080) &#x2F;&#x2F; 当前端口号</span><br><span class="line">.hot(true) &#x2F;&#x2F; 打开页面热载功能</span><br><span class="line">.sockPort(&quot;location&quot;) &#x2F;&#x2F; 设置成平台自己的端口</span><br><span class="line">.open(true);</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>创建sfc组件<code>src/App.vue</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &#123;&#123; msg &#125;&#125;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;app&quot;,</span><br><span class="line">  props: [&quot;msg&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>在入口文件<code>src/main.js</code>中引入<code>App.vue</code>组件，并将其挂载到<code>id=app</code>的节点上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;; &#x2F;&#x2F; 引入 Vue 3 源码</span><br><span class="line">import App from &quot;.&#x2F;App&quot;; &#x2F;&#x2F; 引入 App.vue 组件</span><br><span class="line">const app &#x3D; createApp(App, &#123; msg: &quot;hello Vue 3&quot; &#125;); &#x2F;&#x2F; 渲染 App 组件，并传递 msg 参数 “hello Vue”</span><br><span class="line">app.mount(&quot;#app&quot;); &#x2F;&#x2F; 渲染 App</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>使用命令<code>npm run dev</code>运行项目</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/26/2pH9aV.png" alt="运行项目"></p>
<ol start="13">
<li>下载Vue3源码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue-next.git</span><br></pre></td></tr></table></figure>

<p>目录：</p>
<p><img src="https://i.loli.net/2021/05/19/saSrTKyNbRA41B8.png" alt="总目录"></p>
<p><img src="https://i.loli.net/2021/05/19/5G7fRioLh9ZBm1k.png" alt="package目录"></p>
<ol start="14">
<li>安装Vue3依赖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd vue-next &amp;&amp; yarn --registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<ol start="15">
<li><p>使用命令<code>yarn build</code>编译Vue3源码并打包</p>
</li>
<li><p>使用命令<code>yarn dev --s</code>启动源码开发环境</p>
</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/26/2pH6Ln.png" alt="启动源码"></p>
<ol start="17">
<li>修改vue的<code>demo</code>项目<code>webpack.config.js</code>文件，引入vue源码文件<code>vue-next/packages/vue/dist/vue.global.js</code>。(<code>webpack.config.js</code>最终文件见文末附录)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">.devServer.host(&quot;0.0.0.0&quot;) &#x2F;&#x2F; 服务器外部可访问</span><br><span class="line">.disableHostCheck(true) &#x2F;&#x2F; 关闭白名单校验</span><br><span class="line">.contentBase([</span><br><span class="line">path.resolve(__dirname, &quot;.&#x2F;public&quot;),</span><br><span class="line">path.resolve(__dirname, &quot;..&#x2F;vue-next&quot;),</span><br><span class="line">]) &#x2F;&#x2F; 设置一个 express 静态目录</span><br><span class="line">.historyApiFallback(&#123;</span><br><span class="line">disableDotRule: true, &#x2F;&#x2F; 禁止在链接中使用 &quot;.&quot; 符号</span><br><span class="line">rewrites: [</span><br><span class="line">    &#123; from: &#x2F;^\&#x2F;$&#x2F;, to: &quot;&#x2F;index.html&quot; &#125;, &#x2F;&#x2F; 将所有的 404 响应重定向到 index.html 页面</span><br><span class="line">],</span><br><span class="line">&#125;)</span><br><span class="line">.port(8080) &#x2F;&#x2F; 当前端口号</span><br><span class="line">.hot(true) &#x2F;&#x2F; 打开页面热载功能</span><br><span class="line">.sockPort(&quot;location&quot;) &#x2F;&#x2F; 设置成平台自己的端口</span><br><span class="line">.open(true);</span><br><span class="line"></span><br><span class="line">config.externals(&#123;</span><br><span class="line">vue: &quot;Vue&quot;, &#x2F;&#x2F; 告诉 webpack，让它在加载 vue 模块的时候去 CDN 全局变量里面找 Vue</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="18">
<li>启动demo项目，在url后添加<code>/packages/vue/dist/vue.global.js</code>查看源码文件（可使用同样方法输入其他文件相对路径查看）</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/26/2pqfv4.png" alt="源码文件"></p>
<ol start="19">
<li>在demo项目<code>public/index.html</code>中以<code>CDN</code>形式导入本地vue3源码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;!-- 以 CDN 形式导入我们本地的 Vue 3 源码 --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;packages&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;noscript&gt;your browser should support javascript!&lt;&#x2F;noscript&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- html-webpack-plugin 将自动引入入口文件 --&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ol start="20">
<li>启动后可在浏览器开发者工具中查看源码进行断点调试。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/26/2pL1RU.png" alt="源码调试"></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="webpack-config-js文件"><a href="#webpack-config-js文件" class="headerlink" title="webpack.config.js文件"></a>webpack.config.js文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config &#x3D; new (require(&quot;webpack-chain&quot;))</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line">&#x2F;&#x2F; const isDev &#x3D; !!process.env.WEBPACK_DEV_SERVER; &#x2F;&#x2F; 判断是否是开发环境</span><br><span class="line"></span><br><span class="line">config</span><br><span class="line">.context(path.resolve(__dirname,&quot;.&quot;))&#x2F;&#x2F;上下文目录</span><br><span class="line">.entry(&quot;app&quot;)&#x2F;&#x2F;入口文件名称</span><br><span class="line">.add(&quot;.&#x2F;src&#x2F;main.js&quot;)&#x2F;&#x2F;入口文件为.&#x2F;src&#x2F;main.js</span><br><span class="line">.end()</span><br><span class="line">.output.path(path.join(__dirname,&quot;.&#x2F;dist&quot;))&#x2F;&#x2F;输出目录为dist</span><br><span class="line">.filename(&quot;[name].[hash:8].js&quot;)&#x2F;&#x2F;打包出的bundle名称</span><br><span class="line">.publicPath(&quot;&#x2F;&quot;)&#x2F;&#x2F;公共目录</span><br><span class="line">.end()</span><br><span class="line">.resolve.extensions.add(&quot;.js&quot;)</span><br><span class="line">.add(&quot;.vue&quot;)</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.module.rule(&quot;vue&quot;)</span><br><span class="line">.test(&#x2F;\.vue$&#x2F;)</span><br><span class="line">.use(&quot;vue-loader&quot;)</span><br><span class="line">.loader(&quot;vue-loader&quot;)</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.plugin(&quot;vue-loader-plugin&quot;)</span><br><span class="line">.use(require(&quot;vue-loader&quot;).VueLoaderPlugin,[])</span><br><span class="line">.end()</span><br><span class="line">.plugin(&quot;html&quot;)</span><br><span class="line">.use(require(&quot;html-webpack-plugin&quot;),[</span><br><span class="line">    &#123;</span><br><span class="line">        template: path.resolve(__dirname,&quot;.&#x2F;public&#x2F;index.html&quot;),&#x2F;&#x2F;指定模版文件</span><br><span class="line">        chunks: [&quot;app&quot;],&#x2F;&#x2F;指定需要加在的chunk</span><br><span class="line">        inject: &quot;body&quot;&#x2F;&#x2F;指定script脚本注入的位置为body</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line">.end()</span><br><span class="line">.devServer.disableHostCheck(true)</span><br><span class="line">.contentBase(</span><br><span class="line">    [</span><br><span class="line">        path.resolve(__dirname,&quot;.&#x2F;public&quot;),</span><br><span class="line">        path.resolve(__dirname,&quot;..&#x2F;vue-next&#x2F;vue-next&quot;)</span><br><span class="line">    ]</span><br><span class="line">)&#x2F;&#x2F;设置express静态目录</span><br><span class="line">.historyApiFallback(&#123;</span><br><span class="line">    disableDotRule: true,</span><br><span class="line">    rewrites:[</span><br><span class="line">        &#123;</span><br><span class="line">            from: &#x2F;ˆ\&#x2F;$&#x2F;,</span><br><span class="line">            to: &quot;index.html&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br><span class="line">.port(8080)</span><br><span class="line">.hot(true)</span><br><span class="line">.sockPort(&quot;location&quot;)</span><br><span class="line">.open(true)</span><br><span class="line">.end()</span><br><span class="line">.devtool(&#39;eval-source-map&#39;);</span><br><span class="line"></span><br><span class="line">config.externals(&#123;</span><br><span class="line">    vue: &quot;Vue&quot;,&#x2F;&#x2F;告诉webpack，在加载vue模块时去CDN全局变量里找Vue</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; config.when(</span><br><span class="line">&#x2F;&#x2F;     !isDev,</span><br><span class="line">&#x2F;&#x2F;     ()&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;         &#x2F;&#x2F; 生产环境配置</span><br><span class="line">&#x2F;&#x2F;         config.devtool(null) &#x2F;&#x2F; 生产不生成 source-map，默认行为</span><br><span class="line">&#x2F;&#x2F;     &#125;,</span><br><span class="line">&#x2F;&#x2F;     ()&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;         &#x2F;&#x2F; 开发环境配置</span><br><span class="line">&#x2F;&#x2F;         config.devtool(&#39;eval-source-map&#39;) &#x2F;&#x2F; 获取完整的 source-map，并且用 eval 函数执行</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F; );</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; config.toConfig();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>近期问题分析及解决</title>
    <url>/post/900994060.html</url>
    <content><![CDATA[<h2 id="使用命令npm-run-dev运行时提示报错Cannot-find-module-39-webpack-cli-bin-config-yargs"><a href="#使用命令npm-run-dev运行时提示报错Cannot-find-module-39-webpack-cli-bin-config-yargs" class="headerlink" title="使用命令npm run dev运行时提示报错Cannot find module &#39;webpack-cli/bin/config-yargs"></a>使用命令<code>npm run dev</code>运行时提示报错<code>Cannot find module &#39;webpack-cli/bin/config-yargs</code></h2><p>本地package版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;webpack&quot;: &quot;^5.37.1&quot;,</span><br><span class="line">&quot;webpack-chain&quot;: &quot;^6.5.1&quot;,</span><br><span class="line">&quot;webpack-cli&quot;: &quot;^4.7.0&quot;,</span><br><span class="line">&quot;webpack-dev-server&quot;: &quot;^3.11.2&quot;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>webpack-cli的新版本对webpack-dev-server版本不兼容，卸载后重装webpack-cli提示和webpack有冲突，需要全部重装合适版本，很麻烦。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>将<code>package.json</code>中<code>dev</code>的命令由<code>webpack-dev-server --mode=development --progess</code>改为<code>webpack serve --mode=development</code>后，运行<code>npm run dev</code>成功。</p>
<h2 id="webpack配置外部扩展externals"><a href="#webpack配置外部扩展externals" class="headerlink" title="webpack配置外部扩展externals"></a>webpack配置外部扩展externals</h2><h2 id="ES6字符串模版语法-和’"><a href="#ES6字符串模版语法-和’" class="headerlink" title="ES6字符串模版语法`和’"></a>ES6字符串模版语法`和’</h2>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
        <tag>debug</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-dev-server搭建简易mock服务器</title>
    <url>/post/328527238.html</url>
    <content><![CDATA[<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><blockquote>
<p>用来快速开发应用，仅用于development环境</p>
</blockquote>
<p>webpack-dev-server是第三方依赖库，依赖<code>webpack-dev-middleware</code>（负责把webpack打包后的文件存放在内存中供外界访问）。</p>
<p>下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -D webpack-dev-server --registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><blockquote>
<p>对象，webpack的一个配置选项，主要为<code>webpack-dev-server</code>的参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, &#39;dist&#39;),</span><br><span class="line">    compress: true, &#x2F;&#x2F; 该选项为 true，如果访问服务器的文件，将压缩 dist 目录底下的所有文件给到访问者</span><br><span class="line">    port: 8888,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>host: 指定一个host，默认为<code>localhost</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    host: &#39;0.0.0.0&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><p>port: 设置服务器的端口，默认为<code>8080</code></p>
</li>
<li><p>allowedHost: 字符串数组，用于添加白名单，允许开发服务器访问</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    host: &quot;0.0.0.0&quot;, &#x2F;&#x2F; 如果你希望服务器外部可访问</span><br><span class="line">    allowedHosts: [</span><br><span class="line">        &quot;www.baidu.com&quot; &#x2F;&#x2F; 添加白名单</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>disableHostCheck: 是否关闭白名单校验，默认为<code>false</code>，此项设为<code>true</code>则不需要设置<code>allowedHost</code></p>
</li>
<li><p>before: function，在服务其他中间件之前，提供执行自定义中间件的功能，可以用来配置自定义处理程序</p>
</li>
<li><p>after: function，用法与<code>before</code>一致，表示在服务其他中间件之后执行自定义中间件的功能</p>
</li>
<li><p>compress: 默认为<code>false</code>，用于对服务器的文件和处理结果的压缩</p>
</li>
<li><p>contentBase: 默认为<code>process.cwd()</code>，<code>express</code>的功能，利用express指定某目录为静态目录</p>
</li>
<li><p>contentBasePublicPath: 表示静态公共目录的访问path</p>
</li>
<li><p>historyApiFallback: 当后端路由没有命中，就会自动重定向到<code>index.html</code></p>
</li>
<li><p>hot: 默认为<code>false</code>，启用webpack的模块热替换功能</p>
<ul>
<li><p>hot reload: 热载入，需要打开hot生效，即当webpack监听到文件变化，打包编译后通知<code>webpack-dev-server</code>,客户端收到<code>webpack-dev-server</code>消息后更新局部模块。</p>
</li>
<li><p>live load: 实时更新，webpack-dev-server默认开启，即客户端刷新整个页面。</p>
</li>
</ul>
</li>
<li><p>open: 字符串或对象，默认<code>false</code>禁用。告诉dev-server在server启动后打开浏览器</p>
</li>
<li><p>overlay: <code>boolean</code>或对象形式，默认为<code>false</code>。将webpack报错信息显示到浏览器</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    ...</span><br><span class="line">    overlay: true, &#x2F;&#x2F; 把 webpack 的报错和警告信息显示在浏览器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或分开显示error和warning</span><br><span class="line">overlay: &#123;</span><br><span class="line">  warnings: true, &#x2F;&#x2F; 是否显示 warnings</span><br><span class="line">  errors: true &#x2F;&#x2F; 是否显示 errors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搭建mock服务器"><a href="#搭建mock服务器" class="headerlink" title="搭建mock服务器"></a>搭建mock服务器</h2><ol>
<li><p>新建mock目录</p>
</li>
<li><p>编写mock接口函数</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; function (req,res,next)&#123;</span><br><span class="line">    const &#123; name &#125; &#x3D; req.query; &#x2F;&#x2F;接受参数name  </span><br><span class="line">    let result &#x3D; &#96;$&#123;name&#125;，请回应我～&#96;; &#x2F;&#x2F;返回result</span><br><span class="line">    res.json(&#123; msg: result &#125;); &#x2F;&#x2F;json格式返回result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改<code>webpack.config.js</code>文件用<code>webpack-dev-server</code>加载此函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">        disableHostCheck: true, &#x2F;&#x2F;关闭白名单校验</span><br><span class="line">        before(app, devServer, compiler)&#123;</span><br><span class="line">            const glob &#x3D; require(&quot;glob&quot;);</span><br><span class="line">            const mockPaths &#x3D; &#96;$&#123;path.join(__dirname,&#39;.&#x2F;mock&#39;)&#125;&#x2F;*.js&#96;;&#x2F;&#x2F;获取所有mock函数</span><br><span class="line">            glob(mockPaths,function(er,files)&#123;</span><br><span class="line">                files.forEach((mockFile) &#x3D;&gt; &#123;&#x2F;&#x2F; 遍历所有mock函数</span><br><span class="line">                    const mockFunc &#x3D; require(mockFile); &#x2F;&#x2F; 获取当前mock函数</span><br><span class="line">                    const methodName &#x3D; path.basename(mockFile).split(&quot;.&quot;)[0];&#x2F;&#x2F;获取当前mock名称</span><br><span class="line">                    app.all(&quot;&#x2F;&quot; + methodName, mockFunc); &#x2F;&#x2F; 添加mock函数到服务器</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用命令<code>npx webpack-dev-server</code>启动，访问链接<code>http://localhost:8080/responseByName?name=lynn</code>查看效果</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/25/gzQEZR.png" alt="mock回应"></p>
<ol start="5">
<li>编写对接接口并处理返回值渲染页面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;入口文件src&#x2F;index.js</span><br><span class="line">import &#123;webpackSay&#125; from &quot;..&#x2F;library&quot;; &#x2F;&#x2F;引入 library 的 webpackSay 方法</span><br><span class="line">import Vue from &quot;vue&quot;; &#x2F;&#x2F;导入vue</span><br><span class="line">import noticeWebpack from &quot;$NOTICE&quot;; &#x2F;&#x2F;导入noticeWebpack组件</span><br><span class="line"></span><br><span class="line">document.write(&quot;hello webpack!&quot;);</span><br><span class="line">&#x2F;&#x2F;按需引入demo.js文件</span><br><span class="line">import(&quot;.&#x2F;demo&quot;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">    result.default();</span><br><span class="line">    webpackSay(); &#x2F;&#x2F;执行 webpackSay方法</span><br><span class="line">    &#x2F;&#x2F; 通知webpack函数</span><br><span class="line">    function renderNotice()&#123;</span><br><span class="line">        const noticeRootEle &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">        document.body.append(noticeRootEle);</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            render: (h) &#x3D;&gt; h(noticeWebpack)</span><br><span class="line">        &#125;).$mount(noticeRootEle);</span><br><span class="line">    &#125;</span><br><span class="line">    renderNotice();</span><br><span class="line">    &#x2F;&#x2F; mock服务器对接接口，渲染页面</span><br><span class="line">    responseMsg(&#39;Lynn&#39;).then((msg) &#x3D;&gt; &#123;</span><br><span class="line">        writeToPage(&#96;喂喂喂： $&#123;msg&#125;&#96;);</span><br><span class="line">    &#125;).catch((e) &#x3D;&gt;&#123;</span><br><span class="line">        writeToPage(&#39;喂喂喂，听不到我嘛～&#39;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * 对话函数</span><br><span class="line"> * @param name</span><br><span class="line"> *&#x2F;</span><br><span class="line">function responseMsg(name)&#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt;&#123;</span><br><span class="line">        const request &#x3D; new XMLHttpRequest();</span><br><span class="line">        request.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            if(request.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; request.status &#x3D;&#x3D;&#x3D; 200)&#123;</span><br><span class="line">                const result &#x3D; JSON.parse(request.responseText);</span><br><span class="line">                resolve(result.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        request.onerror &#x3D; (error) &#x3D;&gt; &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;;</span><br><span class="line">        request.open(&#39;GET&#39;,&#96;&#x2F;responseByName?name&#x3D;$&#123;name&#125;&#96;);</span><br><span class="line">        request.setRequestHeader(&#39;accept&#39;, &#39;application&#x2F;json&#39;); &#x2F;&#x2F; 添加请求头 accept 为 application&#x2F;json</span><br><span class="line">        request.send(null);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * 打印msg到页面</span><br><span class="line"> * @param msg</span><br><span class="line"> *&#x2F;</span><br><span class="line">function writeToPage(msg)&#123;</span><br><span class="line">    const ele &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">    ele.innerText &#x3D; msg;</span><br><span class="line">    document.body.append(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用命令<code>npx webpack-dev-server</code>启动，查看效果</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/25/gzw8gA.png" alt="mock效果"></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-配置参数解析（下）</title>
    <url>/post/2741042691.html</url>
    <content><![CDATA[<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><blockquote>
<p>选项<code>resolve</code>可设置模块如何被解析</p>
</blockquote>
<h3 id="resolve-alias"><a href="#resolve-alias" class="headerlink" title="resolve.alias"></a>resolve.alias</h3><blockquote>
<p>创建<code>import</code>或<code>require</code>中间<code>request</code>的别名</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用alias前</span><br><span class="line">import noticewebpack from &#39;.&#x2F;notice-webpack.vue&#39;; &#x2F;&#x2F; 导入 noticewebpack 组件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置module中resolve</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &#39;$NOTICE&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#x2F;notice-webpack.vue&#39;) &#x2F;&#x2F; 设置一个别名替换 .&#x2F;src&#x2F;notice-webpack.vue 文件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置后</span><br><span class="line">import noticewebpack from &#39;$NOTICE&#39;; &#x2F;&#x2F; 导入 noticewebpack 组件</span><br></pre></td></tr></table></figure>

<h3 id="resolve-mainFields"><a href="#resolve-mainFields" class="headerlink" title="resolve.mainFields"></a>resolve.mainFields</h3><blockquote>
<p>当从<code>npm</code>包中导入模块时，<code>mainFields</code>决定在<code>package.json</code>中使用哪个字段导入模块。根据webpack配置中指定的<code>target</code>不同，默认值也不同</p>
</blockquote>
<ul>
<li>当<code>target</code>为：<code>webworker</code>、<code>web</code>或没有指定时，默认值为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;main&#39;], &#x2F;&#x2F; 顺序从左到右加载</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他<code>target</code>，默认值为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    mainFields: [&#39;module&#39;, &#39;main&#39;], &#x2F;&#x2F; 顺序从左到右加载</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h3><blockquote>
<p>自动解析确定的扩展，即确定在加载模块时能省略后缀的文件，默认值为<code>[&#39;.wasm&#39;,&#39;.mjs&#39;,&#39;.js&#39;,&#39;.json&#39;]</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;配置前</span><br><span class="line">import noticewebpack from &#39;.&#x2F;notice-webpack.vue&#39;; &#x2F;&#x2F; 导入 noticewebpack 组件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置extensions参数</span><br><span class="line"> ...</span><br><span class="line"> resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &#39;$NOTICE&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#x2F;notice-webpack.vue&#39;)</span><br><span class="line">        &#125;,</span><br><span class="line">        extensions: [&#39;.wasm&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.vue&#39;] &#x2F;&#x2F; 配置后缀自动解析</span><br><span class="line">    &#125;,</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 配置后</span><br><span class="line">import noticewebpack from &#39;.&#x2F;notice-webpack&#39;; &#x2F;&#x2F; 导入 noticewebpack 组件</span><br></pre></td></tr></table></figure>

<h3 id="resolve-enforceExtension"><a href="#resolve-enforceExtension" class="headerlink" title="resolve.enforceExtension"></a>resolve.enforceExtension</h3><p>若设置为<code>true</code>则不允许有无扩展名的文件</p>
<h3 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a>resolve.modules</h3><blockquote>
<p>告知webpack解析模块时应该搜索的目录，绝对路径和相对路径均可使用</p>
</blockquote>
<p>添加一个目录到模块搜索目录，此目录优先于<code>node_modules/</code>目录进行搜索的话，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modules: [path.resolve(__dirname, &#39;src&#39;), &#39;node_modules&#39;];</span><br></pre></td></tr></table></figure>

<p>此时引入src/xxx文件，即<code>import(&quot;./demo&quot;).then()</code>可以省略<code>.</code>，直接使用<code>import(&quot;demo&quot;).then()</code>引入</p>
<h3 id="resolveLoader"><a href="#resolveLoader" class="headerlink" title="resolveLoader"></a>resolveLoader</h3><blockquote>
<p>用于解析webpack的loader包</p>
</blockquote>
<p>默认值为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  modules: [ &#39;node_modules&#39; ], &#x2F;&#x2F; 默认的 loader 搜索目录</span><br><span class="line">  extensions: [ &#39;.js&#39;, &#39;.json&#39; ], &#x2F;&#x2F; 默认的 loader 后缀自动解析</span><br><span class="line">  mainFields: [ &#39;loader&#39;, &#39;main&#39; ] &#x2F;&#x2F; 默认的 loader 模块入口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><blockquote>
<p>插件可以时一个<code>object</code>或<code>function</code>，故plugins为<code>object</code>或<code>function</code>的集合</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins: [new (require(&#39;vue-loader&#39;).VueLoaderPlugin)()];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-配置参数解析（中）</title>
    <url>/post/641273569.html</url>
    <content><![CDATA[<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><blockquote>
<p>webpack中用<code>require</code>或<code>import</code>引入的都叫module，通过对module选项的配置可以让loader加载对应的模块</p>
</blockquote>
<h3 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h3><p>当使用commonjs模块生成，修改src/index.js文件引入library</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; webpackSay &#125; from &#39;..&#x2F;library&#39;; &#x2F;&#x2F; 引入 library 的 webpackSay 方法</span><br><span class="line"></span><br><span class="line">document.write(&#39;fall in love with webpack！&#39;);</span><br><span class="line">&#x2F;&#x2F; 按需引入 girl.js 文件</span><br><span class="line">import(&#39;.&#x2F;girl&#39;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  result.default();</span><br><span class="line">  webpackSay(); &#x2F;&#x2F; 执行 webpackSay 方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时打包编译，代码用<code>import</code>或<code>require</code>导入时，webpack会再编译一遍<code>library</code>，严重影响性能，故可以使用<code>module.noParse</code>忽略对library模块的再次编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  mode: &#39;development&#39;, &#x2F;&#x2F; 测试环境</span><br><span class="line">  context: path.resolve(__dirname, &#39;.&#x2F;src&#39;), &#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">  entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt; resolve(&#39;.&#x2F;index.js&#39;)), &#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;.&#x2F;lib&#39;), &#x2F;&#x2F; 修改输出路径为 “sy_webpack-config&#x2F;lib”</span><br><span class="line">    publicPath: &#39;.&#x2F;lib&#x2F;&#39;, &#x2F;&#x2F; 配置公共路径</span><br><span class="line">    filename: &quot;[name].js&quot;, &#x2F;&#x2F;配置入口最后生成输出文件名称</span><br><span class="line">    chunkFilename: &quot;[name].[chunkhash:8].js&quot; &#x2F;&#x2F;让它的组成为 &#96;名称.8位内容的hash值.js&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">  module:&#123;</span><br><span class="line">      noParse: &#x2F;(library)&#x2F;,&#x2F;&#x2F;过滤掉library模块</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><blockquote>
<p>模块rule的集合。当创建模块时，匹配请求的rule数组，修改模块的创建方式，并对模块应用选择对应的loader或修改解析器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">      ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        noParse: &#x2F;(library)&#x2F;, &#x2F;&#x2F; 过滤掉 library 模块</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;.vue$&#x2F;, &#x2F;&#x2F; 设置当前模块的规则</span><br><span class="line">                use: &#39;vue-loader&#39;, &#x2F;&#x2F; 设置当前模块的加载器</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.(sass|scss)$&#x2F;, &#x2F;&#x2F; 设置当前模块的规则</span><br><span class="line">                use: [ &#x2F;&#x2F; 设置当前模块的加载器</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &quot;css-loader&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;postcss-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            ident: &quot;postcss&quot;,</span><br><span class="line">                            config: &#123;</span><br><span class="line">                                path: path.resolve(__dirname,&quot;.&#x2F;postcss.config.js&quot;)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;sass-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="条件Condition"><a href="#条件Condition" class="headerlink" title="条件Condition"></a>条件Condition</h4><p>有两种输入值:</p>
<ol>
<li><p>resource：请求文件的绝对路径,属性<code>test</code>、<code>include</code>、<code>exclude</code>、<code>resource</code>对<code>resource</code>匹配</p>
</li>
<li><p>issuer：被请求资源模块文件的绝对路径，代表导入时的模块路径。属性<code>issuer</code>对<code>issuer</code>匹配</p>
</li>
</ol>
<p>如：从<code>app.js</code>导入<code>./style.css</code>模块，则<code>resource</code>为<code>./style.css</code>，<code>issuer</code>为<code>app.js</code></p>
<h5 id="Rule-test"><a href="#Rule-test" class="headerlink" title="Rule.test"></a>Rule.test</h5><blockquote>
<p>为<code>Rule.resource.test</code>的简写。提供了<code>Rule.test</code>就不能再提供<code>Rule.resource</code></p>
</blockquote>
<ul>
<li>字符串：匹配输入必须以提供的字符串开始，目录绝对路径或文件绝对路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: path.resolve(__dirname,&#39;.&#x2F;src&#x2F;notice-webpack.vue&#39;), &#x2F;&#x2F; 字符串匹配一个文件，绝对路径</span><br><span class="line">    use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>正则表达式，使用test来验证输入的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">  use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>函数：调用输入的函数，必须返回一个真值匹配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: resource &#x3D;&gt; &#x2F;\.vue$&#x2F;.test(resource),</span><br><span class="line">    use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>条件数组：至少有一个匹配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: [ &#x2F;\.vue$&#x2F; ],</span><br><span class="line">    use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>对象：匹配所有属性，每个属性都有一个定义行为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">      test: &#x2F;\.vue$&#x2F;</span><br><span class="line">    &#125;,</span><br><span class="line">    use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>当webpack加载到不支持的文件，在执行<code>module.build</code>时会到<code>module.rule</code>中找可以解析此文件的<code>loader</code>。当在<code>webpack.config.js</code>中配置了此loader，webpack就会利用以上的形式找到它，以此来加载此文件。</p>
<h5 id="Rule-issuer"><a href="#Rule-issuer" class="headerlink" title="Rule.issuer"></a>Rule.issuer</h5><blockquote>
<p>用来与发布者的request对应的模块项匹配，其用法与<code>Rule.test</code>一致</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;只需要用 vue-loader 加载 sy_webpack-config&#x2F;src&#x2F;index.js 下的 notice-webpack.vue 文件</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">issuer: [</span><br><span class="line">    &#x2F;&#x2F; 发布者 issuer 是 index.js 或 notice-webpack.vue 的时候才让加载器加载</span><br><span class="line">    path.resolve(__dirname,&quot;.&#x2F;src&#x2F;index.js&quot;),</span><br><span class="line">    path.resolve(__dirname,&quot;.&#x2F;src&#x2F;notice-webpack.vue&quot;),</span><br><span class="line">],</span><br><span class="line">use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Rule-resourceQuery"><a href="#Rule-resourceQuery" class="headerlink" title="Rule.resourceQuery"></a>Rule.resourceQuery</h5><blockquote>
<p>webpack 加载获取加载器的时候，会用当前模块来匹配<code>resourceQuery</code>条件，表示一个请求资源的参数，用法跟<code>Rule.test</code>一样。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当 resourceQuery 有值的时候才匹配 vue-loader</span><br><span class="line">&#123;</span><br><span class="line">     test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">     use: &#39;vue-loader&#39;,</span><br><span class="line">     resourceQuery: (query)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(query)</span><br><span class="line">        return true;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#x2F;&#x2F;同时修改入口文件</span><br><span class="line">import noticewebpack from &#39;.&#x2F;notice-webpack.vue?inline&#39;; &#x2F;&#x2F; 导入noticewebpack组件，inline即为resourceQuery</span><br></pre></td></tr></table></figure>

<h5 id="Rule-use"><a href="#Rule-use" class="headerlink" title="Rule.use"></a>Rule.use</h5><blockquote>
<p>利用<code>use</code>指定当前加载器</p>
</blockquote>
<p>可配置的值与<code>Rule.test</code>一致</p>
<ul>
<li><p>字符串形式</p>
</li>
<li><p>对象形式：当loader需要传递参数时使用</p>
</li>
<li><p>数组形式：当需要多个loader加载时使用</p>
</li>
<li><p>方法形式：当需要获取某些信息当作参数时使用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">   use: (info)&#x3D;&gt;[</span><br><span class="line">     &#123;</span><br><span class="line">       loader: &#39;vue-loader&#39;, &#x2F;&#x2F; 使用 vue-loader 去加载</span><br><span class="line">          options: &#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>其中，info可以写为：</p>
<ul>
<li><p>compiler：当前webpack的compiler对象</p>
</li>
<li><p>issuer：当前模块发布者的路径</p>
</li>
<li><p>realResource：当前module的绝对路径</p>
</li>
<li><p>resource：当前module的路径</p>
</li>
</ul>
<h5 id="Rule-loader-amp-Rule-options"><a href="#Rule-loader-amp-Rule-options" class="headerlink" title="Rule.loader &amp; Rule.options"></a>Rule.loader &amp; Rule.options</h5><blockquote>
<p>配置<code>Rule.loader</code>是<code>Rule.use: [ { loader } ]</code>的简写。</p>
</blockquote>
<p>参数<code>Rule.use</code>跟<code>Rule.loader</code>关系就像是<code>Rule.test</code>跟<code>Rule.resource</code>关系一样</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-配置参数解析（上）</title>
    <url>/post/467442022.html</url>
    <content><![CDATA[<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><blockquote>
<p>入口对象<code>entry</code>用于webpack查找开始构建<code>bundle</code>的地方，配置方法有多种形式</p>
</blockquote>
<p>默认为：<code>./src/index.js</code></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;配置入口</span><br><span class="line">    &#x2F;&#x2F;字符串形式</span><br><span class="line">    entry: &quot;.&#x2F;src&#x2F;index.js&quot;,    </span><br><span class="line">    &#x2F;&#x2F;字符串数组形式</span><br><span class="line">    entry: [&#39;.&#x2F;src&#x2F;index.js&#39;],</span><br><span class="line">    &#x2F;&#x2F;对象形式</span><br><span class="line">    entry: &#123;</span><br><span class="line">         main: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    &#125;,  </span><br><span class="line">    &#x2F;&#x2F;多入口形式</span><br><span class="line">    entry:&#123;                  </span><br><span class="line">         main: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">         main2: &#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;动态入口</span><br><span class="line">    &#x2F;* 当需要根据请求来编译文件做到懒加载打包输出，则使用动态入口*&#x2F;</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt; resolve(&#39;.&#x2F;src&#x2F;index.js&#39;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><blockquote>
<p>上下文<code>context</code>配置webpack的基础目录，用于从配置中解析入口起点和<code>loader</code></p>
</blockquote>
<p>默认为：<code>process.cwd()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><blockquote>
<p>选项<code>mode</code>告知webpack使用相应环境。可能的值：<code>none</code>、<code>development</code>、<code>production</code>（默认）</p>
</blockquote>
<h3 id="生产配置Production"><a href="#生产配置Production" class="headerlink" title="生产配置Production"></a>生产配置Production</h3><blockquote>
<p>生产模式用于项目上线发布，打包后生成的dist/main.js文件无法被识别，压缩代码，关闭输出<code>Console</code>、<code>Debugger</code>，设置<code>process.env.NODE_ENV</code>为<code>production</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;production&#39;,&#x2F;&#x2F;默认模式</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包后dist/main.js文件：</p>
<p><img src="https://i.loli.net/2021/05/24/6xeFbakX4DQlypZ.png" alt="production模式"></p>
<h3 id="开发配置Development"><a href="#开发配置Development" class="headerlink" title="开发配置Development"></a>开发配置Development</h3><blockquote>
<p>开发模式用于日常开发调试，打包后生成的dist/main.js文件代码清晰并添加了<code>sourcemap</code>，不考虑加载速度等，设置<code>process.env.NODE_ENV</code>为<code>development</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;development&#39;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包后dist/main.js文件：</p>
<p><img src="https://i.loli.net/2021/05/24/IgRNyl3fV61iocu.png" alt="development模式"></p>
<h3 id="不使用webpack默认mode配置None"><a href="#不使用webpack默认mode配置None" class="headerlink" title="不使用webpack默认mode配置None"></a>不使用webpack默认mode配置None</h3><blockquote>
<p>将mode设置为none则不实用webpack的默认mode配置，生成的dist/main.js文件与development模式相比少了<code>sourcemap</code>的生成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;none&#39;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包后dist/main.js文件：</p>
<p><img src="https://i.loli.net/2021/05/24/IgRNyl3fV61iocu.png" alt="development模式"></p>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><blockquote>
<p>配置output包含一组选项，指示webpack如何输出及在哪输出<code>bundle</code>、<code>asset</code>和其他导报webpack载入的内容</p>
</blockquote>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><blockquote>
<p>path为文件输出目录，对应一个绝对路径</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;production&#39;,&#x2F;&#x2F;默认模式</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,&#39;.&#x2F;lib&#39;),&#x2F;&#x2F;修改输出路径为 “webpack_demo&#x2F;lib”</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="pathinfo"><a href="#pathinfo" class="headerlink" title="pathinfo"></a>pathinfo</h3><blockquote>
<p>pathinfo告知webpack在<code>bundle</code>中引入所包含模块信息的相关注释，在<code>development</code>模式中默认为<code>true</code>，在<code>production</code>模式中默认为<code>false</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;production&#39;,&#x2F;&#x2F;默认模式</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,&#39;.&#x2F;lib&#39;),&#x2F;&#x2F;修改输出路径为 “webpack_demo&#x2F;lib”</span><br><span class="line">        pathinfo: true,&#x2F;&#x2F;打开pathinfo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注释为：</p>
<p><img src="https://i.loli.net/2021/05/24/yvkopAL8uqJRxHO.png" alt="pathinfo"></p>
<p>在分析<code>bundle</code>包时查看此注释可以了解当前<code>module</code>的依赖组成</p>
<h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><blockquote>
<p>当需要按需加载或加载外部资源，使用<code>publicPath</code>指定外部资源的路径</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  mode: &#39;development&#39;, &#x2F;&#x2F; 测试环境</span><br><span class="line">  context: path.resolve(__dirname, &#39;.&#x2F;src&#39;), &#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">  entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt; resolve(&#39;.&#x2F;index.js&#39;)), &#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;.&#x2F;lib&#39;), &#x2F;&#x2F; 修改输出路径为 “sy_webpack-config&#x2F;lib”</span><br><span class="line">    publicPath: &#39;.&#x2F;lib&#x2F;&#39;, &#x2F;&#x2F; 配置公共路径</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以在入口文件使用运行时的变量__webpack_public_path__指定</span><br><span class="line">document.write(&#39;hello webpack！&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态设置 webpack 的 publicpath 路径</span><br><span class="line">__webpack_public_path__ &#x3D; &#39;.&#x2F;lib&#x2F;&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 按需引入 girl.js 文件</span><br><span class="line">import(&#39;.&#x2F;demo&#39;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  result.default(); &#x2F;&#x2F; 满足 demo 的需求</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h3><blockquote>
<p>选项filename用于修改输出文件的名称</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;production&#39;,&#x2F;&#x2F;默认模式</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,&#39;.&#x2F;lib&#39;),&#x2F;&#x2F;修改输出路径为 “webpack_demo&#x2F;lib”</span><br><span class="line">        pathinfo: true,&#x2F;&#x2F;打开pathinfo</span><br><span class="line">        filename: &#39;oubput.js&#39;,&#x2F;&#x2F;单入口文件配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;多入口文件配置</span><br><span class="line">filename: &#39;[name].js&#39;,&#x2F;&#x2F;输出文件为main1.js，main2.js，name默认为当前module文件名</span><br></pre></td></tr></table></figure>

<h3 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h3><blockquote>
<p>选项<code>chunkFilename</code>决定非入口chunk文件的名称，不能配置为方法，其他与filename一致</p>
</blockquote>
<h3 id="library"><a href="#library" class="headerlink" title="library"></a>library</h3><blockquote>
<p>用于封装自己的函数库或ui库或二次封装并暴露给外界使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  mode: &#39;production&#39;,</span><br><span class="line">  context: path.resolve(__dirname, &#39;.&#39;),</span><br><span class="line">  entry: &#39;.&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;.&#x2F;lib&#39;),</span><br><span class="line">    library: &#39;webpackSay&#39;,</span><br><span class="line">    libraryExport: &#39;default&#39;,</span><br><span class="line">    libraryTarget: &#39;var&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>library：封装后打包的名字</p>
</li>
<li><p>libraryTarget: 配置暴露给外界的方式，即输出的格式</p>
<ul>
<li><p>生成一个变量</p>
<ul>
<li><p>var：libraryTarget的默认值，将库入口的返回值生成一个变量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出main.js为</span><br><span class="line">var webpackSay&#x3D;function(e)&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>assign：产生一个隐含的全局变量。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpackSay&#x3D;function(e)&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>生成对象的属性 </p>
<ul>
<li><p>this：将生成的变量赋值给this对象，作为它的属性</p>
</li>
<li><p>window：返回值赋值为window的一个属性</p>
</li>
<li><p>global：返回值赋值给global的一个属性</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this[&#39;webpackSay&#39;]&#x3D;function(e)&#123;...&#125;</span><br><span class="line">window[&#39;webpackSay&#39;]&#x3D;function(e)&#123;...&#125;</span><br><span class="line">global[&#39;webpackSay&#39;]&#x3D;function(e)&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>按不同模块生成</p>
<ul>
<li><p>commonjs/commonjs2：暴露为CommonJS模块</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;commonjs</span><br><span class="line">exports[&#39;webpackSay&#39;] &#x3D; function(e)&#123; ... &#125;</span><br><span class="line">&#x2F;&#x2F;commonjs2，该方式会直接忽略library的值</span><br><span class="line">module.exports &#x3D; function(e)&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>amd：暴露为amd模块，需要指定library</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&#39;webpackSay&#39;, [], function()&#123;</span><br><span class="line">    return function(e)&#123; ... &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>umd：暴露为所有模块定义下都可运行的方式，需要指定library</p>
</li>
</ul>
</li>
<li><p>生成为JSONP：将返回值封装到一个JSONP容器中</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpackSay(function(e)&#123; ... &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>libraryExport：默认要导出模块的哪个部分</p>
</li>
</ul>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack源码分析-编译的seal和emit阶段</title>
    <url>/post/769148052.html</url>
    <content><![CDATA[<blockquote>
<p>webpack的编译分几个阶段进行，分别为创建对象阶段run、解析获取module阶段make、module分包阶段seal、输出打包后文件阶段emit</p>
</blockquote>
<h2 id="seal阶段"><a href="#seal阶段" class="headerlink" title="seal阶段"></a>seal阶段</h2><blockquote>
<p>seal阶段主要对<code>modules</code>做分拣、拆包、封装。</p>
</blockquote>
<p>查看文件<code>/node_modules/webpack/lib/Compiler.js</code>第675行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; make 阶段开始</span><br><span class="line">    this.hooks.make.callAsync(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">        if (err) return callback(err);</span><br><span class="line">        &#x2F;&#x2F; make 阶段结束</span><br><span class="line">        compilation.finish(err &#x3D;&gt; &#123;</span><br><span class="line">            if (err) return callback(err);</span><br><span class="line">            &#x2F;&#x2F; seal 阶段开始</span><br><span class="line">            compilation.seal(err &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="分包优化"><a href="#分包优化" class="headerlink" title="分包优化"></a>分包优化</h3><p>查看文件<code>/node_modules/webpack/lib/Compilation.js</code>中第1283行seal方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">seal(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 开始进行分包优化操作</span><br><span class="line">    this.hooks.optimize.call();</span><br><span class="line">    &#x2F;&#x2F; 一系列的分包优化操作...</span><br><span class="line">    while (</span><br><span class="line">        this.hooks.optimizeModulesBasic.call(this.modules) ||</span><br><span class="line">        this.hooks.optimizeModules.call(this.modules) ||</span><br><span class="line">        this.hooks.optimizeModulesAdvanced.call(this.modules)</span><br><span class="line">    ) &#123;</span><br><span class="line">        &#x2F;* empty *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    this.hooks.afterOptimizeModules.call(this.modules);</span><br><span class="line"></span><br><span class="line">    while (</span><br><span class="line">        this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) ||</span><br><span class="line">        this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) ||</span><br><span class="line">        this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)</span><br><span class="line">    ) &#123;</span><br><span class="line">        &#x2F;* empty *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);</span><br><span class="line"></span><br><span class="line">    this.hooks.optimizeTree.callAsync(this.chunks, this.modules, err &#x3D;&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return callback(err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.hooks.afterOptimizeTree.call(this.chunks, this.modules);</span><br><span class="line"></span><br><span class="line">        while (</span><br><span class="line">            this.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) ||</span><br><span class="line">            this.hooks.optimizeChunkModules.call(this.chunks, this.modules) ||</span><br><span class="line">            this.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules)</span><br><span class="line">        ) &#123;</span><br><span class="line">            &#x2F;* empty *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);</span><br><span class="line"></span><br><span class="line">        const shouldRecord &#x3D; this.hooks.shouldRecord.call() !&#x3D;&#x3D; false;</span><br><span class="line"></span><br><span class="line">        this.hooks.reviveModules.call(this.modules, this.records);</span><br><span class="line">        this.hooks.optimizeModuleOrder.call(this.modules);</span><br><span class="line">        this.hooks.advancedOptimizeModuleOrder.call(this.modules);</span><br><span class="line">        this.hooks.beforeModuleIds.call(this.modules);</span><br><span class="line">        this.hooks.moduleIds.call(this.modules);</span><br><span class="line">        this.applyModuleIds();</span><br><span class="line">        this.hooks.optimizeModuleIds.call(this.modules);</span><br><span class="line">        this.hooks.afterOptimizeModuleIds.call(this.modules);</span><br><span class="line"></span><br><span class="line">        this.sortItemsWithModuleIds();</span><br><span class="line"></span><br><span class="line">        this.hooks.reviveChunks.call(this.chunks, this.records);</span><br><span class="line">        this.hooks.optimizeChunkOrder.call(this.chunks);</span><br><span class="line">        this.hooks.beforeChunkIds.call(this.chunks);</span><br><span class="line">        this.applyChunkIds();</span><br><span class="line">        this.hooks.optimizeChunkIds.call(this.chunks);</span><br><span class="line">        this.hooks.afterOptimizeChunkIds.call(this.chunks);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="compilation调用createModuleAssets方法"><a href="#compilation调用createModuleAssets方法" class="headerlink" title="compilation调用createModuleAssets方法"></a>compilation调用createModuleAssets方法</h3><p>webpack调用<code>createModuleAssets</code>方法来提取资产文件最后输出到<code>dist</code>目录中，如css中引入的图片等，<code>css-loader</code>会将图片当成一个个<code>module</code>，用<code>url-loader</code>或<code>file-loader</code>提取出来当成css模块中资产文件输出到dist</p>
<h3 id="compilation调用createChunkAssets方法"><a href="#compilation调用createChunkAssets方法" class="headerlink" title="compilation调用createChunkAssets方法"></a>compilation调用createChunkAssets方法</h3><p>查看文件<code>/node_modules/webpack/lib/Compilation.js</code>中第1395行seal方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">seal(callback) &#123;</span><br><span class="line">        &#x2F;&#x2F; 分包优化操作</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 开始分拣 module 中的资产文件</span><br><span class="line">        this.createModuleAssets();</span><br><span class="line">        ...</span><br><span class="line">        if (this.hooks.shouldGenerateChunkAssets.call() !&#x3D;&#x3D; false) &#123;</span><br><span class="line">            this.hooks.beforeChunkAssets.call();</span><br><span class="line">            &#x2F;&#x2F; 开始分拣当前 chunk 中的资产文件</span><br><span class="line">            this.createChunkAssets();</span><br><span class="line">            ...</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>createChunkAssets</code>用来分拣<code>dist/main.js</code>中的资产文件</p>
<h3 id="判断Chunk是否包含runtime代码"><a href="#判断Chunk是否包含runtime代码" class="headerlink" title="判断Chunk是否包含runtime代码"></a>判断Chunk是否包含runtime代码</h3><p>查看文件<code>/node_modules/webpack/lib/Compilation.js</code>中第2111行createChunkAssets方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createChunkAssets() &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历所有的 chunk</span><br><span class="line">    for (let i &#x3D; 0; i &lt; this.chunks.length; i++) &#123;</span><br><span class="line">        const chunk &#x3D; this.chunks[i];</span><br><span class="line">        chunk.files &#x3D; [];</span><br><span class="line">        let source;</span><br><span class="line">        let file;</span><br><span class="line">        let filenameTemplate;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断 chunk 是否包含 runtime 代码并获取 chunk 模版</span><br><span class="line">            const template &#x3D; chunk.hasRuntime()</span><br><span class="line">                ? this.mainTemplate</span><br><span class="line">                : this.chunkTemplate;</span><br><span class="line">            &#x2F;&#x2F; 调用 chunk 模版的 getRenderManifest 方法获取当前 chunk 的所有资产文件</span><br><span class="line">            const manifest &#x3D; template.getRenderManifest(&#123;</span><br><span class="line">                chunk,</span><br><span class="line">                hash: this.hash,</span><br><span class="line">                fullHash: this.fullHash,</span><br><span class="line">                outputOptions,</span><br><span class="line">                moduleTemplates: this.moduleTemplates,</span><br><span class="line">                dependencyTemplates: this.dependencyTemplates</span><br><span class="line">            &#125;); &#x2F;&#x2F; [&#123; render(), filenameTemplate, pathOptions, identifier, hash &#125;]</span><br><span class="line">            &#x2F;&#x2F; 遍历所有的资产清单</span><br><span class="line">            for (const fileManifest of manifest) &#123;</span><br><span class="line">                ...</span><br><span class="line">                &#x2F;&#x2F; 开始执行渲染，获取最后能被浏览器识别的代码</span><br><span class="line">                source &#x3D; fileManifest.render();</span><br><span class="line">                ...</span><br><span class="line">                &#x2F;&#x2F; 开始提交最终打包完毕的资产信息</span><br><span class="line">                this.emitAsset(file, source, assetInfo);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack判断<code>chunk</code>是否是<code>runtime</code>，即webpack启动代码（最终能被浏览器识别的<code>import</code>、<code>require</code>、<code>export</code>，默认为<code>webpackjsonp</code>）。</p>
<p>如果包含<code>runtime</code>则用<code>mainTemplate</code>生成最终代码，不包含则用<code>chunkTemplate</code>生成。</p>
<p>二者区别仅为是否包含<code>runtime</code>代码</p>
<p>至此，<code>seal</code>阶段结束。</p>
<h2 id="emit阶段"><a href="#emit阶段" class="headerlink" title="emit阶段"></a>emit阶段</h2><blockquote>
<p>emit阶段根据配置输出文件</p>
</blockquote>
<p>seal阶段结束，代码回到<code>/node_modules/webpack/lib/Compiler.js</code>660行<code>run</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile(callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; seal 阶段开始</span><br><span class="line">    compilation.seal(err &#x3D;&gt; &#123;</span><br><span class="line">        if (err) return callback(err);</span><br><span class="line">        &#x2F;&#x2F; seal 阶段结束</span><br><span class="line">        this.hooks.afterCompile.callAsync(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">            if (err) return callback(err);</span><br><span class="line">            &#x2F;&#x2F; 回到 run方法</span><br><span class="line">            return callback(null, compilation);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;run方法</span><br><span class="line">run(callback) &#123;const onCompiled &#x3D; (err, compilation) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; seal 结束后回到了 run 方法，并准备执行 emitAssets</span><br><span class="line">        this.emitAssets(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="compiler-emitAssets输出打包过后文件"><a href="#compiler-emitAssets输出打包过后文件" class="headerlink" title="compiler.emitAssets输出打包过后文件"></a>compiler.emitAssets输出打包过后文件</h3><p>查看文件<code>/node_modules/webpack/lib/Compiler.js</code>的<code>emitAssets</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emitAssets(compilation, callback) &#123;</span><br><span class="line">    let outputPath; &#x2F;&#x2F; 输出目录地址</span><br><span class="line">    const emitFiles &#x3D; err &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 遍历所有的资产文件</span><br><span class="line">        asyncLib.forEachLimit(</span><br><span class="line">            compilation.getAssets(),</span><br><span class="line">            15,</span><br><span class="line">            (&#123; name: file, source &#125;, callback) &#x3D;&gt; &#123;</span><br><span class="line">                let targetFile &#x3D; file;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 使用 webpack 的文件输出系统开始写文件到 outputPath</span><br><span class="line">            this.outputFileSystem.writeFile(targetPath, content, err &#x3D;&gt; &#123;</span><br><span class="line">                if (err) return callback(err);</span><br><span class="line">                this.hooks.assetEmitted.callAsync(file, content, callback);</span><br><span class="line">            &#125;);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>emit</code>阶段结束</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack源码分析-编译的run和make阶段</title>
    <url>/post/2637109507.html</url>
    <content><![CDATA[<blockquote>
<p>webpack的编译分几个阶段进行，分别为创建对象阶段run、解析获取module阶段make、module分包阶段seal、输出打包后文件阶段emit</p>
</blockquote>
<h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul>
<li><p>module：webpack中用<code>require</code>或<code>import</code>引入的都叫module</p>
</li>
<li><p>chunk：module的一个集合，入口文件就算一个chunk</p>
</li>
<li><p>dependency：包含一个模块的基本信息，用来创建<code>module</code></p>
</li>
<li><p>moduleFactory：创建<code>module</code>对象的工厂类</p>
</li>
<li><p>assets：最后输出的资产文件</p>
</li>
</ul>
<a id="more"></a>

<h2 id="webpack流程图"><a href="#webpack流程图" class="headerlink" title="webpack流程图"></a>webpack流程图</h2><p><img src="https://i.loli.net/2021/05/22/OtqX5seK1fT6guZ.png" alt="webpack流程图"></p>
<h2 id="执行compiler-run方法"><a href="#执行compiler-run方法" class="headerlink" title="执行compiler.run方法"></a>执行compiler.run方法</h2><p>查看文件<code>node_modules/webpack/lib/Compiler.js</code>第247行</p>
<!--more-->

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    webpack 开始工作</span><br><span class="line">*&#x2F;</span><br><span class="line">run(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 开始执行 beforerun 钩子函数</span><br><span class="line">    this.hooks.beforeRun.callAsync(this, err &#x3D;&gt; &#123;</span><br><span class="line">        if (err) return finalCallback(err);</span><br><span class="line">        &#x2F;&#x2F; 开始执行 run 钩子函数</span><br><span class="line">        this.hooks.run.callAsync(this, err &#x3D;&gt; &#123;</span><br><span class="line">            if (err) return finalCallback(err);</span><br><span class="line">            &#x2F;&#x2F; 开始读取记录</span><br><span class="line">            this.readRecords(err &#x3D;&gt; &#123;</span><br><span class="line">                if (err) return finalCallback(err);</span><br><span class="line">                &#x2F;&#x2F; 开始编译</span><br><span class="line">                this.compile(onCompiled);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>run</code>最后执行了<code>compile</code>方法，即在<code>compiler</code>方法执行时，说明<code>run</code>阶段已经开始了。</p>
<h2 id="compile方法定义"><a href="#compile方法定义" class="headerlink" title="compile方法定义"></a>compile方法定义</h2><p>在文件660行查看<code>compile</code>方法的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    webpack 开始编译</span><br><span class="line">*&#x2F;</span><br><span class="line">compile(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建编译器参数</span><br><span class="line">    const params &#x3D; this.newCompilationParams();</span><br><span class="line">    &#x2F;&#x2F; 调用 beforeCompile 钩子函数</span><br><span class="line">    this.hooks.beforeCompile.callAsync(params, err &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用 compile 钩子函数</span><br><span class="line">        this.hooks.compile.call(params);</span><br><span class="line">        &#x2F;&#x2F; 创建编译器对象</span><br><span class="line">        const compilation &#x3D; this.newCompilation(params);</span><br><span class="line">        &#x2F;&#x2F; 调用 compiler 的 make 钩子函数</span><br><span class="line">        this.hooks.make.callAsync(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">            if (err) return callback(err);</span><br><span class="line">            &#x2F;&#x2F; 调用 finishModules 钩子函数</span><br><span class="line">            compilation.finish(err &#x3D;&gt; &#123;</span><br><span class="line">                if (err) return callback(err);</span><br><span class="line">                &#x2F;&#x2F; 开始对所有的 modules 进行封装</span><br><span class="line">                compilation.seal(err &#x3D;&gt; &#123;</span><br><span class="line">                    if (err) return callback(err);</span><br><span class="line">                    &#x2F;&#x2F; 调用 afterCompile 钩子函数</span><br><span class="line">                    this.hooks.afterCompile.callAsync(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">                        if (err) return callback(err);</span><br><span class="line">                        &#x2F;&#x2F; webpack 编译结束</span><br><span class="line">                        return callback(null, compilation);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="run阶段"><a href="#run阶段" class="headerlink" title="run阶段"></a>run阶段</h2><blockquote>
<p>由<code>compiler.run</code>方法得知<code>compiler</code>方法执行时，说明<code>run</code>阶段已经开始</p>
</blockquote>
<h3 id="创建NormalModuleFactory和ContextModuleFactory"><a href="#创建NormalModuleFactory和ContextModuleFactory" class="headerlink" title="创建NormalModuleFactory和ContextModuleFactory"></a>创建NormalModuleFactory和ContextModuleFactory</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    webpack 开始编译</span><br><span class="line">*&#x2F;</span><br><span class="line">compile(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建编译器参数</span><br><span class="line">    const params &#x3D; this.newCompilationParams();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">    使用方法newCompilationParams()</span><br><span class="line">    创建 NormalModuleFactory 和 ContextModuleFactory</span><br><span class="line">*&#x2F;</span><br><span class="line">newCompilationParams() &#123;</span><br><span class="line">    const params &#x3D; &#123;</span><br><span class="line">        normalModuleFactory: this.createNormalModuleFactory(), &#x2F;&#x2F; NormalModule 的工厂类</span><br><span class="line">        contextModuleFactory: this.createContextModuleFactory(), &#x2F;&#x2F; ContextModules 的工厂类</span><br><span class="line">        compilationDependencies: new Set()</span><br><span class="line">    &#125;;</span><br><span class="line">    return params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Compilation对象"><a href="#创建Compilation对象" class="headerlink" title="创建Compilation对象"></a>创建Compilation对象</h3><blockquote>
<p>对象<code>Compilation</code>对象是webpack的编译器核心对象，被<code>Compiler</code>用来创建新的编译或构建。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    webpack 开始编译</span><br><span class="line">*&#x2F;</span><br><span class="line">compile(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建编译器参数</span><br><span class="line">    const params &#x3D; this.newCompilationParams();</span><br><span class="line">    &#x2F;&#x2F; 调用 beforeCompile 钩子函数</span><br><span class="line">    this.hooks.beforeCompile.callAsync(params, err &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用 compile 钩子函数</span><br><span class="line">        this.hooks.compile.call(params);</span><br><span class="line">        &#x2F;&#x2F; 创建编译器对象</span><br><span class="line">        const compilation &#x3D; this.newCompilation(params);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">    创建 Compilation 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">newCompilation(params) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 Compilation 对象</span><br><span class="line">    const compilation &#x3D; this.createCompilation();</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 调用 thisCompilation 钩子函数</span><br><span class="line">    this.hooks.thisCompilation.call(compilation, params);</span><br><span class="line">    &#x2F;&#x2F; 调用 compilation 钩子函数</span><br><span class="line">    this.hooks.compilation.call(compilation, params);</span><br><span class="line">    return compilation;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;**</span><br><span class="line">     创建并返回 Compilation 对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">createCompilation() &#123;</span><br><span class="line">    return new Compilation(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，webpack的<code>run</code>阶段结束</p>
<h2 id="make阶段"><a href="#make阶段" class="headerlink" title="make阶段"></a>make阶段</h2><p>由<code>compile</code>方法得知，<code>make</code>阶段开始调用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用 compiler 的 make 钩子函数</span><br><span class="line">this.hooks.make.callAsync(compilation, err &#x3D;&gt; &#123;</span><br></pre></td></tr></table></figure>

<p>在初始化过程中得知，钩子函数<code>make</code>在<code>SingleEntryPlugin</code>处被监听，等待make操作的执行。</p>
<h3 id="添加入口文件entry"><a href="#添加入口文件entry" class="headerlink" title="添加入口文件entry"></a>添加入口文件entry</h3><p>查看文件<code>node_modules/webpack/lib/SingleEntryPlugin.js</code>第46行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 监听 compiler 对象的 make 操作</span><br><span class="line">compiler.hooks.make.tapAsync(&#39;SingleEntryPlugin&#39;, (compilation, callback) &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; entry, name, context &#125; &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 创建一个 dependency</span><br><span class="line">  const dep &#x3D; SingleEntryPlugin.createDependency(entry, name);</span><br><span class="line">  &#x2F;&#x2F;添加 entry（入口），并将 dependency 添加到 compilation 对象</span><br><span class="line">  compilation.addEntry(context, dep, name, callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>查看文件<code>node_modules/webpack/lib/Compilation.js</code>第1142行<code>addEntry</code>方法的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">addEntry(context, entry, name, callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; context：默认是我们的工程目录</span><br><span class="line">    &#x2F;&#x2F; entry：是包含工程目录中的 “&#x2F;src&#x2F;index.js” 文件的 “dependency” 对象</span><br><span class="line">    &#x2F;&#x2F; name：默认是 “main”</span><br><span class="line">    this._addModuleChain( &#x2F;&#x2F; 通过 dependency 创建 module 并添加至 compilation 对象</span><br><span class="line">        context,</span><br><span class="line">        entry,</span><br><span class="line">        module &#x3D;&gt; &#123;</span><br><span class="line">            this.entries.push(module);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err, module) &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 成功后回到 SingleEntryPlugin 插件</span><br><span class="line">            return callback(null, module);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>_addModuleChain</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    根据 dependency 添加 module 对象至 compilation 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">_addModuleChain(context, dependency, onModule, callback) &#123;</span><br><span class="line">    const Dep &#x3D; &#x2F;** @type &#123;DepConstructor&#125; *&#x2F; (dependency.constructor);</span><br><span class="line">    &#x2F;&#x2F; 获取模块工厂对象</span><br><span class="line">    const moduleFactory &#x3D; this.dependencyFactories.get(Dep);</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 通过模块工厂创建对应的 module 对象</span><br><span class="line">        moduleFactory.create(</span><br><span class="line">            &#123;</span><br><span class="line">                contextInfo: &#123;</span><br><span class="line">                    issuer: &quot;&quot;,</span><br><span class="line">                    compiler: this.compiler.name</span><br><span class="line">                &#125;,</span><br><span class="line">                context: context,</span><br><span class="line">                dependencies: [dependency]</span><br><span class="line">            &#125;,</span><br><span class="line">            (err, module) &#x3D;&gt; &#123;</span><br><span class="line">                ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用<code>moduleFactory</code>的<code>create</code>方法创建<code>module</code>对象</p>
<p>若没有定义<code>moduleFactory</code>，则webpack默认使用<code>NormalModuleFactory</code>创建<code>NormalModule</code></p>
<h3 id="触发ModuleFactory的create方法"><a href="#触发ModuleFactory的create方法" class="headerlink" title="触发ModuleFactory的create方法"></a>触发ModuleFactory的create方法</h3><p>之前的基础用法demo中没有自定义<code>module</code>和<code>ModuleFactory</code>，故webpack使用<code>NormalModuleFactory</code>的<code>create</code>方法创建，查看文件<code>/node_modules/webpack/lib/NormalModuleFactory.js</code>的373行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    创建 NormalModule 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">create(data, callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 dependencies</span><br><span class="line">    const dependencies &#x3D; data.dependencies;</span><br><span class="line">    &#x2F;&#x2F; 获取上下文目录</span><br><span class="line">    const context &#x3D; data.context || this.context;</span><br><span class="line">    &#x2F;&#x2F; 获取 dependency 的文件地址，也就是“项目名&#x2F;src&#x2F;index.js”</span><br><span class="line">    const request &#x3D; dependencies[0].request;</span><br><span class="line">    &#x2F;&#x2F; 执行 beforeResolve 钩子函数</span><br><span class="line">    this.hooks.beforeResolve.callAsync(</span><br><span class="line">        &#123;</span><br><span class="line">            contextInfo,</span><br><span class="line">            resolveOptions,</span><br><span class="line">            context,</span><br><span class="line">            request,</span><br><span class="line">            dependencies</span><br><span class="line">        &#125;,</span><br><span class="line">        (err, result) &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="触发ModuleFactory的resolver方法"><a href="#触发ModuleFactory的resolver方法" class="headerlink" title="触发ModuleFactory的resolver方法"></a>触发ModuleFactory的resolver方法</h3><blockquote>
<p>方法<code>resolver</code>负责根据传入的<code>dependency</code>对象获取模块中的基本信息，根据这些信息返回模块的<code>loaders</code>(能处理当前<code>module</code>的一个loader集合)、<code>hash值</code>、<code>query</code>(请求参数)等，用于构建<code>module</code>对象的信息，并<code>new</code>一个<code>NormalModule</code>对象</p>
</blockquote>
<p>查看文件<code>/node_modules/webpack/lib/NormalModuleFactory.js</code>的123行中<code>resolver</code>方法的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.hooks.factory.tap(&quot;NormalModuleFactory&quot;, () &#x3D;&gt; (result, callback) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用 resolver 钩子函数获取 resolver 方法</span><br><span class="line">    let resolver &#x3D; this.hooks.resolver.call(null);</span><br><span class="line">    &#x2F;&#x2F; 直接调用 resolver 方法</span><br><span class="line">    resolver(result, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">        this.hooks.afterResolve.callAsync(data, (err, result) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用 createModule 钩子函数</span><br><span class="line">            let createdModule &#x3D; this.hooks.createModule.call(result);</span><br><span class="line">            if (!createdModule) &#123;</span><br><span class="line">                if (!result.request) &#123;</span><br><span class="line">                    return callback(new Error(&quot;Empty dependency (no request)&quot;));</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 创建 NormalModule 对象</span><br><span class="line">                createdModule &#x3D; new NormalModule(result);</span><br><span class="line">            &#125;</span><br><span class="line">            createdModule &#x3D; this.hooks.module.call(createdModule, result);</span><br><span class="line">            return callback(null, createdModule);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 注册 resolver 钩子函数监听</span><br><span class="line">this.hooks.resolver.tap(&quot;NormalModuleFactory&quot;, () &#x3D;&gt; (data, callback) &#x3D;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 返回 resolve 方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="compilateion触发addModule方法"><a href="#compilateion触发addModule方法" class="headerlink" title="compilateion触发addModule方法"></a>compilateion触发addModule方法</h3><p>工厂<code>NormalModuleFactory</code>创建完<code>NormalModule</code>对象后回到<code>Compilation</code>的<code>_addModuleChain</code>方法，开始添加module</p>
<p>查看文件<code>node_modules/webpack/lib/Compilation.js</code>第1085行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    根据 dependency 添加 module 对象至 compilation 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">_addModuleChain(context, dependency, onModule, callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 添加 module 至 compilation</span><br><span class="line">   const addModuleResult &#x3D; this.addModule(module);</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;*</span><br><span class="line">     添加 module</span><br><span class="line"> *&#x2F;</span><br><span class="line"> addModule(module, cacheGroup) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加 module 至 compilation 的 modules 集合中</span><br><span class="line">    ...</span><br><span class="line">    this.modules.push(module);</span><br><span class="line">    return &#123;</span><br><span class="line">        module: module,</span><br><span class="line">        issuer: true,</span><br><span class="line">        build: true,</span><br><span class="line">        dependencies: true</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>_addModuleChain</code>直接调用<code>addModule</code>方法将<code>module</code>对象添加到<code>Compilation</code>的<code>module</code>集合中</p>
<h3 id="Compilation触发buildModule构建模块"><a href="#Compilation触发buildModule构建模块" class="headerlink" title="Compilation触发buildModule构建模块"></a>Compilation触发buildModule构建模块</h3><p>查看文件<code>node_modules/webpack/lib/Compilation.js</code>第1111行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    根据 dependency 添加 module 对象至 compilation 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">_addModuleChain(context, dependency, onModule, callback) &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 开始构建当前 module 对象</span><br><span class="line">   this.buildModule(module, false, null, null, err &#x3D;&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;*</span><br><span class="line">     构建模块</span><br><span class="line"> *&#x2F;</span><br><span class="line"> buildModule(module, optional, origin, dependencies, thisCallback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接调用 module 的 build 方法构建</span><br><span class="line">    module.build(</span><br><span class="line">        this.options,</span><br><span class="line">        this,</span><br><span class="line">        this.resolverFactory.get(&quot;normal&quot;, module.resolveOptions),</span><br><span class="line">        this.inputFileSystem,</span><br><span class="line">        error &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 构建完毕后回到再次 _addModuleChain 方法</span><br><span class="line">            return callback();</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由构建模块可看出，<code>buildModule</code>方法执行的是每个<code>module</code>对象的<code>build</code>方法。在基础使用demo中，则为之前创建的<code>NormalModule</code>，查看文件<code>/node_modules/webpack/lib/NormalModule.js</code>文件第427行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build(options, compilation, resolver, fs, callback) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 直接调用 dobuild 方法</span><br><span class="line">  return this.doBuild(options, compilation, resolver, fs, err &#x3D;&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">    执行所有的 loader 获取返回结果，根据返回结果创建 loader 加载过后的 source 源码</span><br><span class="line">*&#x2F;</span><br><span class="line">doBuild(options, compilation, resolver, fs, callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建执行 loader 的上下文对象</span><br><span class="line">    const loaderContext &#x3D; this.createLoaderContext(</span><br><span class="line">        resolver,</span><br><span class="line">        options,</span><br><span class="line">        compilation,</span><br><span class="line">        fs</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F; 执行所有的 loader</span><br><span class="line">    runLoaders(</span><br><span class="line">        &#123;</span><br><span class="line">            resource: this.resource,</span><br><span class="line">            loaders: this.loaders,</span><br><span class="line">            context: loaderContext,</span><br><span class="line">            readResource: fs.readFile.bind(fs)</span><br><span class="line">        &#125;,</span><br><span class="line">        (err, result) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据返回的结果创建 source 源码对象</span><br><span class="line">            this._source &#x3D; this.createSource(</span><br><span class="line">                this.binary ? asBuffer(source) : asString(source),</span><br><span class="line">                resourceBuffer,</span><br><span class="line">                sourceMap</span><br><span class="line">            );</span><br><span class="line">            this._sourceSize &#x3D; null;</span><br><span class="line">            this._ast &#x3D;</span><br><span class="line">                typeof extraInfo &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp;</span><br><span class="line">                extraInfo !&#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                extraInfo.webpackAST !&#x3D;&#x3D; undefined</span><br><span class="line">                    ? extraInfo.webpackAST</span><br><span class="line">                    : null;</span><br><span class="line">            &#x2F;&#x2F; 返回到 buildModule 方法</span><br><span class="line">            return callback();</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述<code>doBuild</code>方法中使用的<code>runLoaders</code>方法是单独由第三方库<code>loader-runner</code>提供，用来执行所有的<code>loader</code>并返回执行后的结果。根据此结果创建<code>source</code>对象</p>
<h3 id="执行parse方法解析源码"><a href="#执行parse方法解析源码" class="headerlink" title="执行parse方法解析源码"></a>执行parse方法解析源码</h3><p>查看文件<code>/node_modules/webpack/lib/NormalModule.js</code>文件第482行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build(options, compilation, resolver, fs, callback) &#123;</span><br><span class="line">  ...</span><br><span class="line">  return this.doBuild(options, compilation, resolver, fs, err &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 开始解析 loader 处理过后的源码</span><br><span class="line">    const result &#x3D; this.parser.parse(</span><br><span class="line">        this._ast || this._source.source(),</span><br><span class="line">        &#123;</span><br><span class="line">            current: this,</span><br><span class="line">            module: this,</span><br><span class="line">            compilation: compilation,</span><br><span class="line">            options: options</span><br><span class="line">        &#125;,</span><br><span class="line">        (err, result) &#x3D;&gt; &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                handleParseError(err);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                handleParseResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack默认支持<code>JSON</code>、<code>JavaScript</code>代码解析，<code>JavaScript</code>解析默认使用<code>Acorn</code>框架，<code>parse</code>方法主要用来解析代码中的模块定义、获取代码中的模块引用、转换alias、转换自定义变量方法等。</p>
<h3 id="addModuleDependencies编译模块中关联的依赖"><a href="#addModuleDependencies编译模块中关联的依赖" class="headerlink" title="addModuleDependencies编译模块中关联的依赖"></a>addModuleDependencies编译模块中关联的依赖</h3><p>解析后，<code>compilation</code>的<code>buildModule</code>结束，开始编译<code>module</code>中关联的依赖，查看文件<code>node_modules/webpack/lib/Compilation.js</code>第1093行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_addModuleChain(context, dependency, onModule, callback) &#123;</span><br><span class="line">   ...</span><br><span class="line">    const afterBuild &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if (addModuleResult.dependencies) &#123;</span><br><span class="line">            &#x2F;&#x2F;开始编译模块中关联的依赖</span><br><span class="line">            this.processModuleDependencies(module, err &#x3D;&gt; &#123;</span><br><span class="line">                if (err) return callback(err);</span><br><span class="line">                callback(null, module);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return callback(null, module);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processModuleDependencies(module, callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;addModuleDependencies方法用来编译模块中关联的依赖，与_addModuleChain类似</span><br><span class="line">    this.addModuleDependencies(</span><br><span class="line">			module,</span><br><span class="line">			sortedDependencies,</span><br><span class="line">			this.bail,</span><br><span class="line">			null,</span><br><span class="line">			true,</span><br><span class="line">			callback</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，webpack的<code>make</code>阶段结束。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack源码分析-初始化过程</title>
    <url>/post/4111585367.html</url>
    <content><![CDATA[<blockquote>
<p>webpack是现代<code>JavaScript</code>应用程序的静态模块打包器。通过递归地构建依赖关系图，将应用程序需要的每个模块打包成一个或多个bundle</p>
</blockquote>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><ol>
<li><p>使用<code>npm init</code>命令初始化工程</p>
</li>
<li><p>在src目录创建入口文件index.js</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import $ from &#39;jquery&#39;; &#x2F;&#x2F; 引入 jquery 第三方库</span><br><span class="line">$(&#39;#app&#39;).text(&#39;hello webpack!&#39;); &#x2F;&#x2F; 使用 jquery 输出 hello webpack</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol start="3">
<li><p>使用<code>npm install jquery --registry https://registry.npm.taobao.org</code>安装jquery</p>
</li>
<li><p>使用<code>npm install -D webpack@4.44.1 webpack-cli --registry https://registry.npm.taobao.org</code>安装webpack</p>
</li>
<li><p>使用<code>npx webpack</code>编译打包。可看到目录中生成了<code>dist/main.js</code>文件</p>
</li>
<li><p>创建浏览器入口index.html文件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;webpack基础用法&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 创建挂载点 --&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 引入入口js文件 --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;.&#x2F;dist&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>可在编译器浏览index.html文件输出的hello webpack</li>
</ol>
<h2 id="webpack-cli"><a href="#webpack-cli" class="headerlink" title="webpack-cli"></a>webpack-cli</h2><p>在基础用法第5步，使用命令<code>npx webpack</code>编译打包，node会自动执行<code>/node_modules/webpack/bin/webpack.js</code>文件，从<code>133行</code>到<code>149行</code>看出<code>webpack</code>是最后交给<code>webpack-cli</code>命令来执行，即执行<code>npx webpack</code>和<code>npx webpack-cli</code>的结果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断是否安装了 webpack-cli，如果没有安装就引导安装，确保存在 webpack-cli</span><br><span class="line">const packageName &#x3D; &#39;webpack-cli&#39;;</span><br><span class="line">&#x2F;&#x2F; 执行 webpack-cli</span><br><span class="line">runCommand(packageManager, installOptions.concat(packageName))</span><br><span class="line">  .then(() &#x3D;&gt; &#123;</span><br><span class="line">    require(packageName); &#x2F;&#x2F; eslint-disable-line</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) &#x3D;&gt; &#123;</span><br><span class="line">    console.error(error);</span><br><span class="line">    process.exitCode &#x3D; 1;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>分析<code>node_modules/webpack-cli/bin/cli.js</code>文件可发现<code>webpack-cli</code>负责接受用户输入的命令，获取自定义配置文件<code>webpack.config,js</code>或<code>webpackfile.js</code>。创建一个webpack编译器对象<code>compiler</code>并执行<code>compiler</code>对象的<code>run</code>方法。</p>
<h2 id="webpack流程图"><a href="#webpack流程图" class="headerlink" title="webpack流程图"></a>webpack流程图</h2><p><img src="https://i.loli.net/2021/05/22/OtqX5seK1fT6guZ.png" alt="webpack流程图"></p>
<h2 id="分析webpack初始化过程"><a href="#分析webpack初始化过程" class="headerlink" title="分析webpack初始化过程"></a>分析webpack初始化过程</h2><p>在<code>node_modules/webpack-cli/bin/cli.js</code>文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   const webpack &#x3D; require(&quot;webpack&quot;); &#x2F;&#x2F; 引入 webpack</span><br><span class="line">   compiler &#x3D; webpack(options); &#x2F;&#x2F; 创建 webpack 编译器对象 compiler</span><br><span class="line">&#125; catch (err) &#123;......&#125;</span><br></pre></td></tr></table></figure>

<p>引入webpack，并返回webpack编译器对象compiler</p>
<p>查看文件<code>node_modules/webpack/lib/webpack.js</code>第25行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 加载 webpack 默认配置</span><br><span class="line">  options &#x3D; new webpackOptionsDefaulter().process(options);</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 编译器对象 compiler</span><br><span class="line">        compiler &#x3D; new Compiler(options.context);</span><br><span class="line">        compiler.options &#x3D; options;</span><br><span class="line">        &#x2F;&#x2F; 初始化 webpack 的 log 系统、watch 系统、file 系统</span><br><span class="line">        new NodeEnvironmentPlugin(&#123;</span><br><span class="line">            infrastructureLogging: options.infrastructureLogging</span><br><span class="line">        &#125;).apply(compiler);</span><br><span class="line">        &#x2F;&#x2F; 开始加载插件</span><br><span class="line">        if (options.plugins &amp;&amp; Array.isArray(options.plugins)) &#123;</span><br><span class="line">            for (const plugin of options.plugins) &#123;</span><br><span class="line">                if (typeof plugin &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">                    plugin.call(compiler, compiler);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    plugin.apply(compiler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        compiler.hooks.environment.call();</span><br><span class="line">        compiler.hooks.afterEnvironment.call();</span><br><span class="line">        &#x2F;&#x2F;根据 wbepack 的默认配置做 webpack 的初始化操作</span><br><span class="line">        compiler.options &#x3D; new webpackOptionsApply().process(options, compiler);</span><br><span class="line">  if (callback) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 开始编译</span><br><span class="line">        compiler.run(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回编译器对象</span><br><span class="line">    return compiler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载默认配置webpackOptionsDefaulter"><a href="#加载默认配置webpackOptionsDefaulter" class="headerlink" title="加载默认配置webpackOptionsDefaulter"></a>加载默认配置webpackOptionsDefaulter</h3><p>查看<code>node_modules/webpack/lib/webpackOptionsDefaulter.js</code>文件第30行，查看<code>webpackOptionsDefaulter</code>定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class webpackOptionsDefaulter extends OptionsDefaulter &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        &#x2F;&#x2F; 设置默认的入口文件为 “src&#x2F;index.js” 文件</span><br><span class="line">        this.set(&quot;entry&quot;, &quot;.&#x2F;src&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置默认的开发模式为：测试环境 “eval” 生产环境 “false”</span><br><span class="line">        this.set(&quot;devtool&quot;, &quot;make&quot;, options &#x3D;&gt;</span><br><span class="line">            options.mode &#x3D;&#x3D;&#x3D; &quot;development&quot; ? &quot;eval&quot; : false</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; 设置默认上下文目录为 process.cwd()</span><br><span class="line">        this.set(&quot;context&quot;, process.cwd());</span><br><span class="line">        &#x2F;&#x2F; 设置 webpack 的默认 target 为 “web”</span><br><span class="line">        this.set(&quot;target&quot;, &quot;web&quot;);</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 设置 webpack 的默认输出路径为 “dist” 目录</span><br><span class="line">        this.set(&quot;output.path&quot;, path.join(process.cwd(), &quot;dist&quot;));</span><br><span class="line"></span><br><span class="line">        .........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上看出，当没有对webpack做任何配置时，webpack会读取默认配置信息，即默认入口文件<code>src/index.js</code>，默认开发环境、上下文目录、默认target、默认输出路径。</p>
<p>即在基础使用中，没有做任何配置，故webpack默认读取<code>src/index.js</code>文件打包输出到<code>dist</code>目录</p>
<h3 id="创建Compiler对象"><a href="#创建Compiler对象" class="headerlink" title="创建Compiler对象"></a>创建Compiler对象</h3><blockquote>
<p>对象<code>Compiler</code>类似<code>webpack</code>的司机，控制webpack使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建 webpack 编译器对象 compiler</span><br><span class="line">  compiler &#x3D; new Compiler(options.context);</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的方法有</p>
<ol>
<li><p>run：启动编译</p>
</li>
<li><p>newCompilation：创建编译器</p>
</li>
<li><p>emitAssets：处理编译后结果。</p>
</li>
</ol>
<h3 id="创建node环境"><a href="#创建node环境" class="headerlink" title="创建node环境"></a>创建node环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 初始化 webpack 的 log 系统、watch 系统、file 系统</span><br><span class="line">    new NodeEnvironmentPlugin(&#123;</span><br><span class="line">        infrastructureLogging: options.infrastructureLogging</span><br><span class="line">    &#125;).apply(compiler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>node_modules/webpack/lib/node/NodeEnvironmentPlugin.js</code>文件第14行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NodeEnvironmentPlugin &#123;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 中的 log 系统</span><br><span class="line">        compiler.infrastructureLogger &#x3D; createConsoleLogger(</span><br><span class="line">            Object.assign(</span><br><span class="line">                &#123;</span><br><span class="line">                    level: &quot;info&quot;,</span><br><span class="line">                    debug: false,</span><br><span class="line">                    console: nodeConsole</span><br><span class="line">                &#125;,</span><br><span class="line">                this.options.infrastructureLogging</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 中的 file 读取系统</span><br><span class="line">        compiler.inputFileSystem &#x3D; new CachedInputFileSystem(</span><br><span class="line">            new NodeJsInputFileSystem(),</span><br><span class="line">            60000</span><br><span class="line">        );</span><br><span class="line">        const inputFileSystem &#x3D; compiler.inputFileSystem;</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 中的 file 输出系统</span><br><span class="line">        compiler.outputFileSystem &#x3D; new NodeOutputFileSystem();</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 中的 watch 监听文件系统</span><br><span class="line">        compiler.watchFileSystem &#x3D; new NodeWatchFileSystem(</span><br><span class="line">            compiler.inputFileSystem</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>NodeEnvironmentPlugin</code>创建文件系统，使<code>webpack</code>可以读取、编译、输出文件，同时输出一些log文件</p>
<h3 id="加载plugins"><a href="#加载plugins" class="headerlink" title="加载plugins"></a>加载plugins</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 开始加载插件</span><br><span class="line">    if (options.plugins &amp;&amp; Array.isArray(options.plugins)) &#123;</span><br><span class="line">        for (const plugin of options.plugins) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果插件是一个方法</span><br><span class="line">            if (typeof plugin &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">                plugin.call(compiler, compiler);</span><br><span class="line">            &#x2F;&#x2F; 插件为一个对象的时候</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                plugin.apply(compiler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h4><ol>
<li>提供配置文件<code>webpack.config.js</code>给<code>webpack</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建配置文件</span><br><span class="line">touch webpack.config.js</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>导入一个对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建plugins目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir plugins</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在plugins目录中创建文件function-webpack-plugin.js</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch plugins&#x2F;function-webpack-plugin.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件内容</span><br><span class="line">module.exports &#x3D; function (compiler) &#123;</span><br><span class="line">  &#x2F;&#x2F; 利用 webpack 的 log 系统输出一句话</span><br><span class="line">  compiler.infrastructureLogger(&#39;Customer&#39;, &#39;error&#39;, [</span><br><span class="line">    &#39;我是自定义Function插件&#39;,</span><br><span class="line">  ]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在plugins目录中创建文件object-webpack-plugin.js</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ObjectwebpackPlugin &#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    &#x2F;&#x2F; 同样利用 webpack 的 log 系统输出一句话</span><br><span class="line">    compiler.infrastructureLogger(&#39;Customer&#39;, &#39;error&#39;, [</span><br><span class="line">      &#39;我是自定义Object插件&#39;,</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; ObjectwebpackPlugin;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在webpack.config.js使用4、5中插件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&#39;.&#x2F;plugins&#x2F;function-webpack-plugin&#39;), &#x2F;&#x2F; 引用 function 方式插件</span><br><span class="line">    new (require(&#39;.&#x2F;plugins&#x2F;object-webpack-plugin&#39;))(), &#x2F;&#x2F; 引用 object 方式插件</span><br><span class="line">  ],</span><br><span class="line">  infrastructureLogging: &#123;</span><br><span class="line">    debug: true, &#x2F;&#x2F; 开启 webpack 的 log 系统</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>执行命令<code>npx webpack</code></li>
</ol>
<p><img src="https://i.loli.net/2021/05/22/XolRx52HTQWpPwy.png" alt="结果"></p>
<h3 id="根据默认配置初始化webpack"><a href="#根据默认配置初始化webpack" class="headerlink" title="根据默认配置初始化webpack"></a>根据默认配置初始化webpack</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpackOptionsApply &#x3D; require(&quot;.&#x2F;webpackOptionsApply&quot;);</span><br><span class="line">...</span><br><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 根据默认配置初始化 webpack</span><br><span class="line">  compiler.options &#x3D; new webpackOptionsApply().process(options, compiler);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看文件<code>node_modules/webpack/lib/webpackOptionsApply.js</code>第55行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">process(options, compiler) &#123;</span><br><span class="line">    let ExternalsPlugin;</span><br><span class="line">    &#x2F;&#x2F; 初始化 webpack 的输出路径</span><br><span class="line">    compiler.outputPath &#x3D; options.output.path;</span><br><span class="line">    &#x2F;&#x2F; 初始化 webpack 的 records 路径</span><br><span class="line">    compiler.recordsInputPath &#x3D; options.recordsInputPath || options.recordsPath;</span><br><span class="line">    compiler.recordsOutputPath &#x3D;</span><br><span class="line">        options.recordsOutputPath || options.recordsPath;</span><br><span class="line">    &#x2F;&#x2F; 设置当前编译器的 name</span><br><span class="line">    compiler.name &#x3D; options.name;</span><br><span class="line">        switch (options.target) &#123;</span><br><span class="line">            case &quot;web&quot;:</span><br><span class="line">                &#x2F;&#x2F; 添加浏览器环境的模块生成器模版</span><br><span class="line">                JsonpTemplatePlugin &#x3D; require(&quot;.&#x2F;web&#x2F;JsonpTemplatePlugin&quot;);</span><br><span class="line">                NodeSourcePlugin &#x3D; require(&quot;.&#x2F;node&#x2F;NodeSourcePlugin&quot;);</span><br><span class="line">                new JsonpTemplatePlugin().apply(compiler);</span><br><span class="line">                new FetchCompileWasmTemplatePlugin(&#123;</span><br><span class="line">                    mangleImports: options.optimization.mangleWasmImports</span><br><span class="line">                &#125;).apply(compiler);</span><br><span class="line">                &#x2F;&#x2F; 将模块到一个方法中的模版</span><br><span class="line">                new FunctionModulePlugin().apply(compiler);</span><br><span class="line">                new NodeSourcePlugin(options.node).apply(compiler);</span><br><span class="line">                new LoaderTargetPlugin(options.target).apply(compiler);</span><br><span class="line">                break;</span><br><span class="line">      ...</span><br><span class="line">    &#x2F;&#x2F; 入口文件加载插件</span><br><span class="line">    new EntryOptionPlugin().apply(compiler);</span><br><span class="line">    &#x2F;&#x2F; 执行 compiler 对象中的 entryOption 钩子函数</span><br><span class="line">    compiler.hooks.entryOption.call(options.context, options.entry);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>webpackOptionsApply的责任为根据webapck的配置信息加载一些插件。</p>
</blockquote>
<p>如上代码中<code>入口文件加载插件</code>到<code>执行compiler对象中的entryOption钩子函数</code>部分，这里执行了<code>compiler</code>对象中的<code>entryOption</code>钩子函数。</p>
<p>查看文件<code>node_modules/webpack/lib/EntryOptionPlugin.js</code>第20行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const itemToPlugin &#x3D; (context, item, name) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 多入口的时候</span><br><span class="line">    if (Array.isArray(item)) &#123;</span><br><span class="line">        return new MultiEntryPlugin(context, item, name);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 单入口的时候</span><br><span class="line">    return new SingleEntryPlugin(context, item, name);</span><br><span class="line">&#125;;</span><br><span class="line">module.exports &#x3D; class EntryOptionPlugin &#123;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        &#x2F;&#x2F; 监听 compiler 对象中的 entryOption 钩子函数</span><br><span class="line">        compiler.hooks.entryOption.tap(&quot;EntryOptionPlugin&quot;, (context, entry) &#x3D;&gt; &#123;</span><br><span class="line">             &#x2F;&#x2F; entry 可以为一个 string 或数组，名称默认为 “main”</span><br><span class="line">            if (typeof entry &#x3D;&#x3D;&#x3D; &quot;string&quot; || Array.isArray(entry)) &#123;</span><br><span class="line">                itemToPlugin(context, entry, &quot;main&quot;).apply(compiler);</span><br><span class="line">            &#125; else if (typeof entry &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123; &#x2F;&#x2F; entry 可以为一个 object</span><br><span class="line">                for (const name of Object.keys(entry)) &#123;</span><br><span class="line">                    itemToPlugin(context, entry[name], name).apply(compiler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (typeof entry &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123; &#x2F;&#x2F; entry 还可以为一个方法</span><br><span class="line">                new DynamicEntryPlugin(context, entry).apply(compiler);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>EntryOptionPlugin监听<code>compiler</code>对象中的<code>entryOption</code>钩子函数的执行</p>
<p>原基础应用使用的是单入口项目，故在此使用的是SIngleEntryPlugin插件，查看文件<code>node_modules/webpack/lib/SingleEntryPlugin.js</code>第40行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SingleEntryPlugin &#123;</span><br><span class="line">    constructor(context, entry, name) &#123;</span><br><span class="line">        this.context &#x3D; context; &#x2F;&#x2F; 当前 webpack 的上下文目录</span><br><span class="line">        this.entry &#x3D; entry; &#x2F;&#x2F; 入口文件</span><br><span class="line">        this.name &#x3D; name; &#x2F;&#x2F; 入口文件的名称</span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">    ...</span><br><span class="line">        &#x2F;&#x2F; 监听 compiler 对象的 make 操作</span><br><span class="line">        compiler.hooks.make.tapAsync(</span><br><span class="line">            &quot;SingleEntryPlugin&quot;,</span><br><span class="line">            (compilation, callback) &#x3D;&gt; &#123;</span><br><span class="line">                const &#123; entry, name, context &#125; &#x3D; this;</span><br><span class="line">                const dep &#x3D; SingleEntryPlugin.createDependency(entry, name);</span><br><span class="line">                &#x2F;&#x2F; 把入口文件当成一个 dependency 添加到 webpack 进行编译</span><br><span class="line">                compilation.addEntry(context, dep, name, callback);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">module.exports &#x3D; SingleEntryPlugin;</span><br></pre></td></tr></table></figure>

<p>到此，webpack的初始化过程结束。<code>webpack</code>在<code>SingleEntryPlugin</code>停止运行等待<code>compiler</code>的<code>make</code>操作的执行，即webpack编译的开始。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue动态切换页签缓存页面内容</title>
    <url>/post/2684937453.html</url>
    <content><![CDATA[<p>之前在上家公司自己建系统的时候出现过切换页签，但切换后上个页面的内容没有被缓存，而是重新渲染了。</p>
<p>正好学习Vue3时看到了解决方法。</p>
<p>（之前因为赶工作进度，学习Vue2时没有用心看&lt;–要改正的问题</p>
<p>使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>将切换的组件包裹起来即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件通信</title>
    <url>/post/943587192.html</url>
    <content><![CDATA[<blockquote>
<p>Vue组件实例的作用域相互独立，不同组件之间的数据无法相互引用</p>
</blockquote>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><blockquote>
<p>参数<code>props</code>用于父组件向子组件传递数据</p>
</blockquote>
<p>父组件调用子组件，在子组件的<code>props</code>写入需要的属性。传递时，在父组件内调用的子组件中直接使用。</p>
<p>可以传入静态的值：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">const app &#x3D; Vue.createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;title&#39;],</span><br><span class="line">  template: &#96;&lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h4&gt;&#96;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(&#39;#blog-post-demo&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;blog-post title&#x3D;&quot;My journey with Vue&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br></pre></td></tr></table></figure>


<p>也可以通过<code>v-bind</code>或简写<code>:</code>动态赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;blog-post :title&#x3D;&quot;post.title&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;blog-post :title&#x3D;&quot;post.title + &#39;by&#39; + post.author.name &quot;&gt;&lt;&#x2F;blog-post&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除传递静态string值外，传入数据、布尔值、数组、对象等，即使传递静态数据也要使用<code>v-bind</code>告诉Vue。即<code>&lt;blog-post :like=&quot;42&quot;&gt;&lt;/blog-post&gt;</code></p>
</blockquote>
<p>所有props均为单项数据流，即父级prop的更新会向下流动到子组件，无法由子组件传递给父组件。</p>
<h3 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h3><blockquote>
<p>emit用于子组件向父组件传递数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&#x2F;&#x2F;需要子组件提供postFontSize的值更新字体大小</span><br><span class="line">&lt;div :style&#x3D;&quot;&#123;fontSize: postFontSize + &#39;em&#39;&#125;&quot;&gt;</span><br><span class="line">    &lt;!--父组件通过@&#x2F;v-on监听子组件实例的enlarge-text事件将字体大小增大0.1，当子组件事件触发，则父组件通过此监听器接收到事件并更新需要的postFontSize值--&gt;</span><br><span class="line">    &lt;blog-post</span><br><span class="line">        v-for&#x3D;&quot;post in posts&quot;</span><br><span class="line">        :key &#x3D; &quot;post.id&quot;</span><br><span class="line">        :title&#x3D;&quot;post.title&quot;</span><br><span class="line">        @enlarge-text&#x3D;&quot;postFontSize +&#x3D; 0.1&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;&#x2F;blog-post&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">app.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;title&#39;],</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div class&#x3D;&quot;blog-post&quot;&gt;</span><br><span class="line">      &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;!--子组件通过调用$emit方法传入事件名称enlargeText来触发事件--&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;$emit(&#39;enlargeText&#39;)&quot;&gt;</span><br><span class="line">        Enlarge text</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>$emit:</p>
<pre><code>参数：{string}```eventName```, ```[...args]```

触发当前实例上的事件```eventName```，附加参数```args```会传给监听器回调</code></pre><h3 id="使用事件监听子组件"><a href="#使用事件监听子组件" class="headerlink" title="使用事件监听子组件"></a>使用事件监听子组件</h3><blockquote>
<p>使用<code>$emit</code>的附加参数提供特定的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">&lt;button @click&#x3D;&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&#x2F;&#x2F;通过$event访问被抛出的附加参数</span><br><span class="line">&lt;blog-post ... @enlarge-text&#x3D;&quot;postFontSize +&#x3D; $event&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若事件处理函数是一个方法，则此抛出的附加参数会作为方法的第一个参数传入</span><br><span class="line">&lt;blog-post ... @enlarge-text&#x3D;&quot;onEnlargeText&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  onEnlargeText(enlargeAmount) &#123;</span><br><span class="line">    this.postFontSize +&#x3D; enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h3 id="provide-amp-amp-inject"><a href="#provide-amp-amp-inject" class="headerlink" title="provide&amp;&amp;inject"></a>provide&amp;&amp;inject</h3>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue事件处理修饰符</title>
    <url>/post/2636759885.html</url>
    <content><![CDATA[<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><blockquote>
<p>在事件处理程序中调用<code>event.preventDefault()</code>或<code>event.stopPropagation()</code>是非常常见的需求。因此推荐使用事件修饰符处理。尽管可以在方法中实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理<code>DOM</code>事件细节。</p>
</blockquote>
<p>修饰符是由点开头的指令后缀来表示的。使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a @click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form @submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a @click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form @submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div @click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div @click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a @click.once&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发--&gt;</span><br><span class="line">&lt;!-- 而不会等待 &#96;onScroll&#96; 完成--&gt;</span><br><span class="line">&lt;!-- 这其中包含 &#96;event.preventDefault()&#96; 的情况--&gt;</span><br><span class="line">&lt;!-- .passive和.prevent不要一起使用，.prevent会被忽略--&gt;</span><br><span class="line">&lt;div @scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><blockquote>
<p>用于监听键盘事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只有在 &#96;key&#96; 是 &#96;Enter&#96; 时调用 &#96;vm.submit()&#96; --&gt;</span><br><span class="line">&lt;input @keyup.enter&#x3D;&quot;submit&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;input @keyup.page-down&#x3D;&quot;onPageDown&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="按键别名"><a href="#按键别名" class="headerlink" title="按键别名"></a>按键别名</h4><ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete (捕获“删除”和“退格”键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
<h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><blockquote>
<p>实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p>
</blockquote>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Alt + Enter --&gt;</span><br><span class="line">&lt;input @keyup.alt.enter&#x3D;&quot;clear&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Ctrl + Click --&gt;</span><br><span class="line">&lt;div @click.ctrl&#x3D;&quot;doSomething&quot;&gt;Do something&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>.exact</code>修饰符允许控制由精确的系统修饰符组合触发的事件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>鼠标按钮修饰符</p>
</blockquote>
<ul>
<li>.left</li>
<li>.right</li>
<li>.middle</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue条件渲染区分</title>
    <url>/post/4085137225.html</url>
    <content><![CDATA[<ol>
<li><code>v-if</code>在初始渲染时判断条件，若为假，则不进行渲染。只有当条件为真时才开始渲染条件块。确保在切换过程中条件块内的事件监听器和子组件被适当的销毁和重建。</li>
<li><code>v-show</code>无论初始判断条件是真或假，均会进行渲染。即只是切换元素的CSS Property <code>display</code>。</li>
<li><code>v-show</code>不支持<code>&lt;template&gt;</code>和<code>v-else</code></li>
</ol>
<blockquote>
<p>使用<code>v-if</code>有更高的切换开销，若运行时条件很少改变，则选择<code>v-if</code>。<code>v-show</code>有更高的初始开销，若需要频繁的切换，则使用<code>v-show</code>更好。</p>
</blockquote>
<a id="more"></a>

<h3 id="v-if和v-for不要同时用在同一元素上"><a href="#v-if和v-for不要同时用在同一元素上" class="headerlink" title="v-if和v-for不要同时用在同一元素上"></a>v-if和v-for不要同时用在同一元素上</h3><blockquote>
<p>参数<code>v-for</code>的优先级比<code>v-if</code>高</p>
</blockquote>
<ol>
<li><p>过滤列表中的项目，优先将过滤的项目替换为计算属性，使其返回过滤后的列表进行v-for</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">        v-if&#x3D;&quot;user.isActive&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p> 无论列表数据量有多大，筛选后的列表有没有变化，都会在每次重新渲染时遍历整个列表。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;改写后</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in activeUsers&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    activeUsers() &#123;</span><br><span class="line">        return this.users.filter(user &#x3D;&gt; user.isActive)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 改写后，过滤列表只会在筛选后列表发生变化时才会重新计算，过滤更高效。且在<code>v-for</code>遍历时，只会遍历选后的列表，渲染更高效。解耦渲染层的逻辑，可维护性更强。</p>
</li>
<li><p>避免渲染需要被隐藏的列表，将v-if移动到容器元素上。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;改写前</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">        v-if&#x3D;&quot;shouldShowUsers&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;改写后</span><br><span class="line">&lt;ul v-if&#x3D;&quot;shouldShowUsers&quot;&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p> 改写后不需要对列表内每个用户都检查是否应该显示，而只检查一次，且不会<code>v-for</code>不应该显示的用户。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS真值Truthy和假值Falsy</title>
    <url>/post/3652898665.html</url>
    <content><![CDATA[<p>假值Falsy：<code>false</code>,<code>0</code>,<code>&quot;&quot;</code>,<code>null</code>,<code>undefined</code>,<code>NaN</code></p>
<p>真值Truthy：除假值外均为真值。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;真值Truthy,以下均会被当作true执行if内的代码</span><br><span class="line">if (true)</span><br><span class="line">if (&#123;&#125;)</span><br><span class="line">if (42)</span><br><span class="line">if (&quot;foo&quot;)</span><br><span class="line">if (new Date())</span><br><span class="line">if (-Infinity)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;假值Falsy，以下均会被当作false跳过if内的代码</span><br><span class="line">if (false)</span><br><span class="line">if (null)</span><br><span class="line">if (undefined)</span><br><span class="line">if (0)</span><br><span class="line">if (0n)</span><br><span class="line">if (NaN)</span><br><span class="line">if (&#39;&#39;)</span><br><span class="line">if (&quot;&quot;)</span><br><span class="line">if (&#96;&#96;)</span><br><span class="line">if (document.all)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue计算属性</title>
    <url>/post/2394451147.html</url>
    <content><![CDATA[<blockquote>
<p>不要在模版中放入太多的逻辑。模版最好是简单和声明性的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        book:&#123;</span><br><span class="line">            author: &#39;xxx&#39;,</span><br><span class="line">            borrower: [</span><br><span class="line">                &#39;aaa&#39;,</span><br><span class="line">                &#39;bbb&#39;,</span><br><span class="line">                &#39;ccc&#39;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;This book has been borrowed?&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; book.borrower.length &gt; 0 ? &#39;yes&#39; : &#39;no&#39; &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<blockquote>
<p>对于包含响应式数据的复杂逻辑，应使用计算属性<code>computed</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        book:&#123;</span><br><span class="line">            author: &#39;xxx&#39;,</span><br><span class="line">            borrower: [</span><br><span class="line">                &#39;aaa&#39;,</span><br><span class="line">                &#39;bbb&#39;,</span><br><span class="line">                &#39;ccc&#39;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">    &#x2F;&#x2F;计算属性的getter</span><br><span class="line">    borrowedMessage()&#123;</span><br><span class="line">        &#x2F;&#x2F;this指向vm实例</span><br><span class="line">        return this.book.borrower.length &gt; 0 ? &#39;yes&#39; : &#39;no&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;This book has been borrowed?&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; borrowedMessage &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在表达式中调用方法同样可以达成一样的效果"><a href="#在表达式中调用方法同样可以达成一样的效果" class="headerlink" title="在表达式中调用方法同样可以达成一样的效果"></a>在表达式中调用方法同样可以达成一样的效果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        book:&#123;</span><br><span class="line">            author: &#39;xxx&#39;,</span><br><span class="line">            borrower: [</span><br><span class="line">                &#39;aaa&#39;,</span><br><span class="line">                &#39;bbb&#39;,</span><br><span class="line">                &#39;ccc&#39;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    borrowedMessage()&#123;</span><br><span class="line">        &#x2F;&#x2F;this指向vm实例</span><br><span class="line">        return this.book.borrower.length &gt; 0 ? &#39;yes&#39; : &#39;no&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;This book has been borrowed?&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;!--调用方法--&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; borrowedMessage() &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ol>
<li><p>计算属性基于依赖关系缓存。即<code>vm.borrowedMessage</code>依赖<code>vm.book.borrower</code>。故当<code>vm.book.borrower</code>改变，所有依赖<code>vm.borrowedMessage</code>的绑定都会更新，若<code>vm.book.borrower</code>没有改变，则多次访问<code>vm.borrowedMessage</code>均返回之前的结果，不会再次执行函数。</p>
</li>
<li><p>调用方法不会有缓存，每次触发重新渲染都会再次执行函数。即<code>Date.now()</code>在<code>methods</code>中调用可以每次渲染更新数值，但在<code>computed</code>中则不会被更新。</p>
</li>
</ol>
<blockquote>
<p>若出现性能开销大的计算属性，需要缓存来节省开销则使用<code>computed</code>，若程序不想要缓存，则使用<code>methods</code>替代计算属性</p>
</blockquote>
<h3 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    fullName:&#123;</span><br><span class="line">        &#x2F;&#x2F;getter</span><br><span class="line">        get()&#123;</span><br><span class="line">            return this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;setter</span><br><span class="line">        set(newValue)&#123;</span><br><span class="line">            const names &#x3D; newValue.split(&#39; &#39;)</span><br><span class="line">            this.firstName &#x3D; names[0]</span><br><span class="line">            this.lastName &#x3D; names[names.length - 1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听器watch"><a href="#监听器watch" class="headerlink" title="监听器watch"></a>监听器watch</h3><blockquote>
<p>当需要在数据变化时执行异步操作或者开销比较大的操作时，使用watch监听数据的变化。当数据有变化时才执行下一步操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;template</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;question:&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;question&quot; &#x2F;&gt; </span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;script</span><br><span class="line">watch:&#123;</span><br><span class="line">    question(new,old)&#123;</span><br><span class="line">        if(new.indexOf(&#39;?&#39;)&gt;-1)&#123;</span><br><span class="line">            this.getAnswer()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    getAnswer()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-data及methods</title>
    <url>/post/2526449992.html</url>
    <content><![CDATA[<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>组件的<code>data</code>是一个<code>函数</code>，调用它返回一个<code>对象</code>，被vue封装后，以<code>$data</code>的形式存储在组件实例中</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        example: [2,3,1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>组件的<code>methods</code>是一个包含方法的<code>对象</code>，自动绑定<code>this</code>，始终指向组件实例。定义时避免使用箭头函数，会影响<code>this</code>的指向</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    exampleFuction()&#123;</span><br><span class="line">        example[2] &#x3D; 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以在组件模版中被访问</span><br><span class="line">&lt;button @click&#x3D;&quot;exampleFuction&quot;&gt;Change example&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue运行单文件</title>
    <url>/post/944781666.html</url>
    <content><![CDATA[<ol>
<li><p>安装依赖<code>npm install -g @vue/cli-service-global</code></p>
</li>
<li><p>创建文件<code>xxx.vue</code></p>
</li>
<li><p>在文件目录运行<code>vue serve xxx.vue</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>新坑</title>
    <url>/post/3726999768.html</url>
    <content><![CDATA[<p>最近打算重写个人网站了，想想可以把之前练手的前端设计的个站、gist网站、还有当前的个站整合在一起，还要加一些作品集展示区。<br>本事一般想法挺大。感觉又要重学一遍了。<br>这周末再怎么犹豫也要把离职提了，做点自己喜欢的吧。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>咕咕咕</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-2D光随鼠标移动转变方向</title>
    <url>/post/1739481233.html</url>
    <content><![CDATA[<h2 id="2D光随鼠标移动转变方向"><a href="#2D光随鼠标移动转变方向" class="headerlink" title="2D光随鼠标移动转变方向"></a>2D光随鼠标移动转变方向</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Update () &#123;</span><br><span class="line">&#x2F;&#x2F;获取鼠标的坐标，鼠标是屏幕坐标，Z轴为0，这里不做转换  </span><br><span class="line">Vector3 mouse &#x3D; Input.mousePosition;</span><br><span class="line">&#x2F;&#x2F;获取物体坐标，物体坐标是世界坐标，将其转换成屏幕坐标，和鼠标一直  </span><br><span class="line">Vector3 obj &#x3D; Camera.main.WorldToScreenPoint(transform.position);</span><br><span class="line">&#x2F;&#x2F;屏幕坐标向量相减，得到指向鼠标点的目标向量，即黄色线段  </span><br><span class="line">Vector3 direction &#x3D; mouse - obj;</span><br><span class="line">&#x2F;&#x2F;将Z轴置0,保持在2D平面内  </span><br><span class="line">direction.z &#x3D; 0f;</span><br><span class="line">&#x2F;&#x2F;将目标向量长度变成1，即单位向量，这里的目的是只使用向量的方向，不需要长度，所以变成1  </span><br><span class="line">direction &#x3D; direction.normalized;</span><br><span class="line">&#x2F;&#x2F;物体自身的Y轴和目标向量保持一直，这个过程XY轴都会变化数值  </span><br><span class="line">transform.up &#x3D; direction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-法线贴图&amp;BlendTree&amp;特效VFX</title>
    <url>/post/1132536811.html</url>
    <content><![CDATA[<h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><blockquote>
<p>法线贴图：记录了一个需要进行光影变换的贴图上的各个点的凹凸情况的贴图，显示芯片根据贴图的内容来实时生成新的有光影变换的贴图，从而实现立体效果</p>
</blockquote>
<blockquote>
<p>法线贴图不是真正的贴图，故不会直接贴到物体的表面，其作用就是记录每个点上法线的方向。</p>
</blockquote>
<a id="more"></a>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>模型面数越高，可以表现的细节越多，效果越好，但面数多了，顶点数便多了，计算量变大了。为了能用尽可能简单的模型来做出更好的效果，最初提出纹理映射，但它只影响像素阶段输出的颜色值，不能让模型有凹凸的细节，故提出法线贴图解决此问题。</p>
<p>最早在计算时需要逐顶点计算光照，然后每个像素的颜色在各个顶点的颜色之间插值，在此情况下，面数决定一切效果。但在像素着色器出现后，可以通过逐像素来计算光照效果。在计算时，会计算此像素所在面的法向量，此法向量也是由这个面周围的顶点的法线插值得来。当改变法线的方向，则可以改变这个点的光照结果。</p>
<p>在平面的情况下，感觉物体的凹凸很大一部分取决于面的亮度，有了对比，就容易感觉有凹凸。因此通过改变法线来改变面上点的光照条件进而可以让观察者感觉这个面有凹凸</p>
<p><a href="https://imgchr.com/i/sXFc0U" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sXFc0U.png" alt="sXFc0U.png"></a></p>
<h2 id="BlendTree"><a href="#BlendTree" class="headerlink" title="BlendTree"></a>BlendTree</h2><blockquote>
<p>混合树(Blend Tree)按不同程度组合所有动画的各个部分来平滑混合多个动画。即将多个动画融合在一起按条件触发。</p>
</blockquote>
<ol>
<li><code>Animator</code>选择新建混合树的状态，右键选择<code>Create New Blend Tree in State</code></li>
</ol>
<p><a href="https://imgchr.com/i/sXFRk4" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sXFRk4.png" alt="sXFRk4.png"></a></p>
<ol start="2">
<li><p>双击<code>Blend Tree</code>打开<code>Inspector</code>在<code>Motion</code>处新建需要混合的多个动画。</p>
</li>
<li><p>选择参数<code>Parameter</code>是通过速度<code>Speed</code>计算还是通过垂直加速度<code>verticalVelocity</code>，两个都是<code>Float</code>类型</p>
</li>
<li><p>在各个动画的<code>Threshold</code>设置不同的参数值来控制其出现的时间</p>
</li>
</ol>
<p><a href="https://imgchr.com/i/sXFg7F" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sXFg7F.png" alt="sXFg7F.png"></a></p>
<ol start="5">
<li>在脚本中为动画参数赋值，即关联实际角色与动画设置的参数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fallID;</span><br><span class="line">&#x2F;&#x2F;fallID为Animator状态参数的编号</span><br><span class="line">fallID &#x3D; Animator.StringToHash(&quot;verticalVelocity&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置跳跃BlendTree的动画，其float值就是角色刚体y轴跳跃的加速度,</span><br><span class="line">anim.SetFloat(fallID, rb.velocity.y);</span><br></pre></td></tr></table></figure>

<h2 id="解决更换场景也不销毁某对象"><a href="#解决更换场景也不销毁某对象" class="headerlink" title="解决更换场景也不销毁某对象"></a>解决更换场景也不销毁某对象</h2><p>在代码中使用<code>DontDestroyOnLoad(gameObject)</code>方法</p>
<h2 id="代码中给角色添加特效VFX"><a href="#代码中给角色添加特效VFX" class="headerlink" title="代码中给角色添加特效VFX"></a>代码中给角色添加特效VFX</h2><ol>
<li>脚本中创建特效变量</li>
<li>unity中将特效拖入对应变量中</li>
<li>使用<code>Instantiate(origin,position,rotation)</code>方法替换当前角色的位置为特效动画</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-2D场景透视效果&amp;多个电光源部分光源失效的问题</title>
    <url>/post/900394468.html</url>
    <content><![CDATA[<h2 id="2D场景透视效果"><a href="#2D场景透视效果" class="headerlink" title="2D场景透视效果"></a>2D场景透视效果</h2><ol>
<li>调整Camera的<code>Projection</code>为<code>Perspective</code><ul>
<li><code>Perspective</code>接近真实摄像机，在3D视图中表现为以点发散的射线构成的画面<br><img src="https://s3.ax1x.com/2021/01/25/sqIAFs.png" alt="sqIAFs.png"></li>
</ul>
</li>
</ol>
<a id="more"></a>

<pre><code>- ```Orthographic```为方形的摄像机，在3D视图中表现为方形垂直的射线构成的画面
![sqIEYn.png](https://s3.ax1x.com/2021/01/25/sqIEYn.png)</code></pre><ol start="2">
<li>调整景深，即调整不同背景图层<code>Position</code>的<code>z轴</code></li>
</ol>
<h2 id="解决设置多个电光源但部分光源失效的问题"><a href="#解决设置多个电光源但部分光源失效的问题" class="headerlink" title="解决设置多个电光源但部分光源失效的问题"></a>解决设置多个电光源但部分光源失效的问题</h2><blockquote>
<p>Unity中Quality Setting的Pixel Light Count的个数过小</p>
</blockquote>
<ol>
<li><p>点击<code>Edit</code>-&gt;<code>Project Setting</code>-&gt;<code>Quality</code>，查看<code>QualitySetting</code></p>
</li>
<li><p>在<code>Rendering</code>设置<code>Pixel Light Count</code>，即场景中渲染的点光源个数。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-合并地图碰撞器&amp;标记字段&amp;射线检测碰撞体</title>
    <url>/post/3573569076.html</url>
    <content><![CDATA[<h2 id="将地图碰撞器合并"><a href="#将地图碰撞器合并" class="headerlink" title="将地图碰撞器合并"></a>将地图碰撞器合并</h2><ol>
<li>在<code>Tile Collider 2D</code>中勾选<code>Used by Composite</code></li>
<li>新建一个<code>Composite Collider 2D</code>，同时会自动生成一个刚体<code>RigidBody 2D</code></li>
<li>将<code>RigidBody 2D</code>的<code>Body Type</code>设置为<code>static</code>，则其不会因重力而运动，固定在原地</li>
<li>同时也可以在<code>Inspector</code>的右上角将<code>Static</code>勾选</li>
</ol>
<a id="more"></a>

<h2 id="unity在脚本中使用标记字段"><a href="#unity在脚本中使用标记字段" class="headerlink" title="unity在脚本中使用标记字段"></a>unity在脚本中使用标记字段</h2><blockquote>
<p>在脚本中使用标记字段可以在<code>Inspector</code>中组织属性显示</p>
</blockquote>
<ol>
<li><code>[Space(10)]</code>: 与上面产生一个10的空隙，也可以不带参数</li>
<li><code>Header(&quot;xxx&quot;)</code>: 在<code>Inspector</code>面板上给定义的字段的上一行加描述，形成分组的感觉</li>
<li><code>[Tooltip(&quot;xxx&quot;)]</code>: 给变量加Tooltip属性使在<code>Inspector</code>面板鼠标悬停在该变量上显示提示</li>
<li><code>[Range(min,max)]</code>: 限制数值变量的取值范围并以滑动条显示在<code>Inspector</code>中</li>
<li><code>[SerializeField]</code>: 强制序列化一个私有的变量，使之可以在<code>Inspector</code>面板显示</li>
</ol>
<p><a href="https://blog.csdn.net/FifthGently/article/details/78363364?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control" target="_blank" rel="noopener">其他内容可看此链接</a></p>
<p>使用前：</p>
<p><img src="https://s3.ax1x.com/2021/01/22/sIM5N9.png" alt="sIM5N9.png"></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]</span><br><span class="line">private float crouchSpeedDivison &#x3D; 3f;</span><br><span class="line"></span><br><span class="line">[Header(&quot;移动速度&quot;)]</span><br><span class="line">public float speed &#x3D; 8f;</span><br><span class="line">[Space(10)]</span><br><span class="line"></span><br><span class="line">[Range(0, 10)]</span><br><span class="line">public float xVelocity;</span><br></pre></td></tr></table></figure>
<p>使用后：</p>
<p><img src="https://s3.ax1x.com/2021/01/22/sIMIhR.png" alt="sIMIhR.png"></p>
<h2 id="射线检测碰撞体-RaycastHit2D"><a href="#射线检测碰撞体-RaycastHit2D" class="headerlink" title="射线检测碰撞体(RaycastHit2D)"></a>射线检测碰撞体(RaycastHit2D)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;画射线</span><br><span class="line">RaycastHit2D leftCheck &#x3D; Physics2D.Raycast(pos + offset, Vector2.down, groundDistance, groundLayer);</span><br><span class="line">&#x2F;&#x2F;显示射线用于debug</span><br><span class="line">Debug.DrawRay(pos + offset, Vector2.down, Color.red, 0.2f);</span><br></pre></td></tr></table></figure>

<h3 id="Physics-Raycast"><a href="#Physics-Raycast" class="headerlink" title="Physics.Raycast"></a>Physics.Raycast</h3><blockquote>
<p><strong>射线投射(raycast)</strong>：射线投射从原点沿着射线方向发送假想的“激光束”，直至命中场景中的碰撞体，随后返回有关该对象和<code>RaycastHist</code>对象内的投射命中点的信息。</p>
</blockquote>
<blockquote>
<p>向场景中的所有碰撞体投射一条射线，该射线起点为<code>origin</code>，朝向<code>direction</code>，长度为<code>maxDistance</code>。</p>
</blockquote>
<blockquote>
<p>若射线与任何碰撞体相交，返回<code>true</code>否则为<code>false</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static bool Raycast (Vector3 origin, Vector3 direction, float maxDistance&#x3D; Mathf.Infinity, int layerMask&#x3D; DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction&#x3D; QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>origin</td>
<td>射线在坐标系中的起点</td>
</tr>
<tr>
<td>direction</td>
<td>射线方向</td>
</tr>
<tr>
<td>maxDistance</td>
<td>射线检查碰撞的最大距离</td>
</tr>
<tr>
<td>layerMask</td>
<td>遮罩层，用于投射射线时选择性的忽略碰撞体</td>
</tr>
<tr>
<td>queryTriggerInteraction</td>
<td>指定该查询是否应该命中触发器</td>
</tr>
</tbody></table>
<p><strong>重写Raycast方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重构Raycast方法</span><br><span class="line">RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)</span><br><span class="line">&#123;</span><br><span class="line">    Vector2 pos &#x3D; transform.position;</span><br><span class="line">    RaycastHit2D hit &#x3D; Physics2D.Raycast(pos + offset, rayDirection, length, layer);</span><br><span class="line">    Color color &#x3D; hit ? Color.red : Color.green;</span><br><span class="line">    Debug.DrawRay(pos + offset, rayDirection * length,color);</span><br><span class="line">    return hit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Csharp-类&amp;方法</title>
    <url>/post/2936126698.html</url>
    <content><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li><p><code>public</code>：成员可由任何代码访问</p>
</li>
<li><p><code>private</code>：成员只能由类中的代码访问</p>
</li>
<li><p><code>protected</code>：成员只能由类或派生类中的代码访问</p>
</li>
</ul>
<a id="more"></a>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p><code>static</code>：若使用<code>static</code>关键字，该方法只能通过类访问，不能通过对象实例来访问</p>
</li>
<li><p><code>virtual</code>：方法可以重写</p>
</li>
<li><p><code>abstract</code>：方法必须在非抽象的派生类中重写（只用于抽象类）</p>
</li>
<li><p><code>override</code>：方法重写了一个基类方法（若方法被重写，必须使用该关键字）</p>
</li>
<li><p><code>extern</code>：方法定义放在其他地方</p>
</li>
<li><p><code>base</code>：调用重写或隐藏的基类方法，表示包含在派生类中的基类的实现代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基类</span><br><span class="line">public class MyBaseClass&#123;</span><br><span class="line">    &#x2F;&#x2F;若子类可重写此方法，必须使用virtual关键字</span><br><span class="line">    public virtual void DoSomething()&#123;</span><br><span class="line">        &#x2F;&#x2F;方法内容</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">public class MyDerivedClass : MyBaseClass&#123;</span><br><span class="line">    &#x2F;&#x2F;重写基类方法必须使用override关键字</span><br><span class="line">    public override void DoSomething()&#123;</span><br><span class="line">        &#x2F;&#x2F;继承基类方法DoSomething()的已有内容</span><br><span class="line">        base.DoSomething();</span><br><span class="line">        &#x2F;&#x2F;重写方法其他独有功能</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-音效&amp;UI&amp;场景变换及光源</title>
    <url>/post/318510413.html</url>
    <content><![CDATA[<h2 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h2><ul>
<li><p>Audio Listener：音乐接收</p>
</li>
<li><p>Audio Source：音乐音源</p>
</li>
<li><p>Audio Clips：音乐片段</p>
</li>
</ul>
<a id="more"></a>

<h3 id="背景音乐"><a href="#背景音乐" class="headerlink" title="背景音乐"></a>背景音乐</h3><ol>
<li>下载音乐素材</li>
<li>在player界面添加<code>Audio Source</code></li>
<li>将对应bgm拖入<code>Audio Clip</code></li>
</ol>
<ul>
<li>Play On Awake: 游戏一开始就播放</li>
<li>Loop: 循环播放</li>
</ul>
<h3 id="为其他动作添加音效"><a href="#为其他动作添加音效" class="headerlink" title="为其他动作添加音效"></a>为其他动作添加音效</h3><ol>
<li><p>对象单个动作添音效</p>
<ul>
<li>下载音乐素材</li>
<li>在对象界面添加<code>Audio Source</code></li>
<li>将对应bgm拖入<code>Audio Clip</code></li>
<li>在脚本中添加<code>AudioSource</code>对象，并在<code>start()</code>方法使用<code>GetComponent&lt;AudioSource&gt;()</code>创建component</li>
<li>在合适的位置添加代码<code>audio.Play();</code>方法播放音效 </li>
</ul>
</li>
<li><p>对象多个动作添音效</p>
<ul>
<li>下载音乐素材</li>
<li>在对象界面添加<code>Audio Source</code></li>
<li>将对应bgm拖入<code>Audio Clip</code></li>
<li>在脚本中添加多个<code>public</code>的<code>AudioSource</code>对象，在unity界面将不同的音效拖入脚本的不同属性中</li>
<li>在合适的位置添加代码<code>audio.Play();</code>方法播放音效 </li>
</ul>
</li>
</ol>
<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><ol>
<li>添加UI中的<code>Panel</code>面板</li>
<li>选择合适的位置和颜色</li>
<li>在<code>Panel</code>中添加<code>Text</code>，并添加对应文字和样式</li>
<li>设置出现对话位置的碰撞体并设置<code>is Trigger</code></li>
<li>在代码中实现出现对话框的逻辑</li>
<li>在unity中将对应的对话框拖入<code>script</code>的对应<code>Object</code>中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public GameObject enterDialog;&#x2F;&#x2F;对话框Object</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;角色碰撞到出现对话的位置，触发函数</span><br><span class="line">public void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.tag.Equals(&quot;Player&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        enterDialog.SetActive(true);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;角色离开出现对话的位置，触发函数</span><br><span class="line">public void OnTriggerExit2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.tag.Equals(&quot;Player&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        enterDialog.SetActive(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="场景变换"><a href="#场景变换" class="headerlink" title="场景变换"></a>场景变换</h2><blockquote>
<p>SceneManagement</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重新加载scene--死亡后重启</span><br><span class="line">SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进入下一个场景</span><br><span class="line">&#x2F;&#x2F;使用buildIndex前需要到File-&gt;Build Setting中加入所有场景</span><br><span class="line">SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);</span><br></pre></td></tr></table></figure>


<h2 id="增加光源"><a href="#增加光源" class="headerlink" title="增加光源"></a>增加光源</h2><blockquote>
<p>先让环境暗下来，再让发光的地方发出光源</p>
</blockquote>
<ol>
<li>给背景添加材质<code>Default_diffuse</code>，使其变暗</li>
<li>给人物及其他角色添加材质<ul>
<li>新建材质</li>
<li>在<code>Shader</code>中选择<code>Sprites/Diffuse</code>，若有法线贴图，则将其添加到<code>Normal Map</code>中</li>
<li>将材质拖入人物及其他角色的材质栏</li>
</ul>
</li>
<li>添加<code>Point Light</code>，光源是3D的，需要调节z轴的值来调节光线的亮度，并通过调节Range和Intensity改变光的范围和强度</li>
<li>更改光源位置到需要的地方</li>
</ol>
<p>若添加光源有边缘线，可讲cell size改成1、1，若出现锯齿，则在Project Setting中的Quality，将抗锯齿Anti Aliasing设置为Disabled</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-调用其他类&amp;敌人death动画</title>
    <url>/post/2320782257.html</url>
    <content><![CDATA[<h2 id="调用其他类的方法"><a href="#调用其他类的方法" class="headerlink" title="调用其他类的方法"></a>调用其他类的方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;调用Enemy_Frog类的方法切换敌人的动画</span><br><span class="line">Enemy_Frog frog &#x3D; collision.gameObject.GetComponent&lt;Enemy_Frog&gt;();</span><br><span class="line">frog.SwitchDeath();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="敌人death动画切换"><a href="#敌人death动画切换" class="headerlink" title="敌人death动画切换"></a>敌人death动画切换</h2><ol>
<li>创建敌人动画</li>
<li>创建动画关联Transition</li>
<li>设置条件Trigger(当该触发器被触发则切换动画)</li>
<li>在<code>Animation</code>创建event实现当动画播放结束再销毁敌人GameObject</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-收集&amp;tilemap拼接缝隙&amp;collider碰撞摩擦&amp;敌人</title>
    <url>/post/4000927129.html</url>
    <content><![CDATA[<h2 id="创建收集内容"><a href="#创建收集内容" class="headerlink" title="创建收集内容"></a>创建收集内容</h2><ol>
<li>新建收集object</li>
<li>添加sprite和动画</li>
<li>移动至合适位置</li>
<li>设置collider碰撞体</li>
<li>设置isTrigger，使之碰撞时触发一些改变</li>
<li>为object设置特有tag，便于写脚本时获取该object</li>
<li>编写脚本实现计数、销毁等操作<a id="more"></a>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.tag.Equals(&quot;Cherry&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            cherry++;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (collision.tag.Equals(&quot;Gem&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            gem++;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些记录"><a href="#一些记录" class="headerlink" title="一些记录"></a>一些记录</h3><p>is Trigger: 触发器 触发后会发生一些改变</p>
<p>inspector中: <code>Tag</code>、<code>Layer</code></p>
<p>Perfabs: 一个预置，类似于一个模版</p>
<h2 id="瓦片地图出现拼接缝隙"><a href="#瓦片地图出现拼接缝隙" class="headerlink" title="瓦片地图出现拼接缝隙"></a>瓦片地图出现拼接缝隙</h2><p>将<code>tilemap</code>的<code>grid</code>中<code>cellsize</code>改为0.99</p>
<h2 id="解决两个collider碰撞摩擦的问题-material材质"><a href="#解决两个collider碰撞摩擦的问题-material材质" class="headerlink" title="解决两个collider碰撞摩擦的问题(material材质)"></a>解决两个collider碰撞摩擦的问题(material材质)</h2><ol>
<li>创建<code>physical material 2d</code></li>
<li>修改摩擦力<code>friction</code>为0</li>
<li>将材质放入需要的collider里的material中</li>
</ol>
<h2 id="解决角色可多次跳的问题"><a href="#解决角色可多次跳的问题" class="headerlink" title="解决角色可多次跳的问题"></a>解决角色可多次跳的问题</h2><blockquote>
<p>设置角色只有触碰地面才可以跳跃，无法在空中跳跃</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public LayerMask ground;&#x2F;&#x2F;图层</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;角色跳跃</span><br><span class="line">if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; coll.IsTouchingLayers(ground))</span><br><span class="line">&#123;</span><br><span class="line">    rb.velocity &#x3D; new Vector2(rb.velocity.x, jumpForce * Time.deltaTime);</span><br><span class="line">    anim.SetBool(&quot;jumping&quot;, true);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ol>
<li>新建UI画布<code>canvas</code></li>
<li>在<code>canvas</code>内添加需要的内容</li>
<li>需要变化的变量在脚本中实现，unity中新建的UI是什么选项，脚本中就按该关键字获取UI</li>
<li>在unity脚本框内拖入相应的ui选项</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine.UI</span><br><span class="line"></span><br><span class="line">public Text CherryNumber;&#x2F;&#x2F;新建Text类</span><br><span class="line"></span><br><span class="line">CherryNumber.text &#x3D; cherry.ToString();&#x2F;&#x2F;将实际cherry值传给unity的Text类中</span><br></pre></td></tr></table></figure>

<h2 id="敌人"><a href="#敌人" class="headerlink" title="敌人"></a>敌人</h2><h3 id="创建敌人"><a href="#创建敌人" class="headerlink" title="创建敌人"></a>创建敌人</h3><ol>
<li>新建角色sprite</li>
<li>添加动画</li>
<li>添加刚体</li>
<li>添加collider。<code>circle</code>最好，可以保证移动时不翻转</li>
<li>给敌人加标签，便于编写脚本时获取</li>
</ol>
<h3 id="踩敌人消灭"><a href="#踩敌人消灭" class="headerlink" title="踩敌人消灭"></a>踩敌人消灭</h3><blockquote>
<p>判断角色是下落状态时，碰撞到敌人则destroy敌人</p>
</blockquote>
<h3 id="受伤"><a href="#受伤" class="headerlink" title="受伤"></a>受伤</h3><ol>
<li>添加受伤动画</li>
<li>在<code>Animator</code>添加hurt标志，调整不同状态转换的条件</li>
<li>编写受伤脚本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]private bool isHurt;&#x2F;&#x2F;判断是否受伤</span><br><span class="line">&#x2F;&#x2F;受伤动画转换</span><br><span class="line">else if (isHurt)</span><br><span class="line">&#123;</span><br><span class="line">    anim.SetBool(&quot;hurt&quot;, true);</span><br><span class="line">    anim.SetFloat(&quot;running&quot;, 0);&#x2F;&#x2F;保证受伤后处于静止状态而不是跑步状态</span><br><span class="line">    if (Mathf.Abs(rb.velocity.x) &lt; 0.1) &#123;&#x2F;&#x2F;判断角色是否已经反弹结束处于静止状态</span><br><span class="line">        isHurt &#x3D; false;</span><br><span class="line">        anim.SetBool(&quot;hurt&quot;, false);</span><br><span class="line">        anim.SetBool(&quot;idle&quot;, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;消灭敌人</span><br><span class="line">private void OnCollisionEnter2D(Collision2D collision)&#x2F;&#x2F;当该刚体碰撞另一个刚体时调用的函数</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.tag.Equals(&quot;Enemies&quot;)) &#123; &#x2F;&#x2F;函数代表的是整个碰撞器&#x2F;刚体，故需要.gameObject获其角色类</span><br><span class="line">    	&#x2F;&#x2F;消灭敌人</span><br><span class="line">        if (anim.GetBool(&quot;falling&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">            &#x2F;&#x2F;增加消灭后再次小跳的效果</span><br><span class="line">            rb.velocity &#x3D; new Vector2(rb.velocity.x, jumpForce * Time.deltaTime);</span><br><span class="line">            anim.SetBool(&quot;jumping&quot;, true);</span><br><span class="line">        &#125;else if(transform.position.x &lt; collision.gameObject.transform.position.x)</span><br><span class="line">        &#123;&#x2F;&#x2F;增加受伤反弹的效果</span><br><span class="line">            rb.velocity &#x3D; new Vector2(-5, rb.velocity.y);</span><br><span class="line">            isHurt &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (transform.position.x &gt; collision.gameObject.transform.position.x)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.velocity &#x3D; new Vector2(5, rb.velocity.y);</span><br><span class="line">            isHurt &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="敌人移动AI"><a href="#敌人移动AI" class="headerlink" title="敌人移动AI"></a>敌人移动AI</h3><ol>
<li>敌人角色下创建两个<code>GameObject</code>表示左右边界，设置移动边界位置（此时角色与边界为父子关系）</li>
<li>新建敌人脚本</li>
<li>新建两个<code>Transform</code>类表示左右边界，并在unity中拖入边界Object完成关联</li>
<li>在脚本中在start时获取边界的x值，然后将其边界Object销毁，保证其不随敌人角色移动</li>
<li>编写自动移动脚本</li>
<li>在unity设置初始speed使之移动<br>（以下均可选）</li>
<li>添加跳跃动画</li>
<li>设置相关条件，并编写动画切换脚本</li>
<li>在<code>Animation</code>界面静止状态最后一秒新建事件<code>event</code>，设置其事件函数为移动的movement。使敌人角色在播放完静止动画后执行移动函数，进行跳跃等其他动作。此时不需要在update中每秒执行movement函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Rigidbody2D rb;</span><br><span class="line">&#x2F;&#x2F;左右的行动边界</span><br><span class="line">public Transform leftPoint,rightPoint;</span><br><span class="line">private bool isFaceLeft &#x3D; true;</span><br><span class="line">public float speed;</span><br><span class="line">private float leftx, rightx;&#x2F;&#x2F;用于保存左右边界的x值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;敌人移动</span><br><span class="line">void Movement()</span><br><span class="line">&#123;</span><br><span class="line">    if (isFaceLeft)</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(-speed, rb.velocity.y);</span><br><span class="line">        if(transform.position.x &lt; leftx)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;控制敌人面向右边，即掉头</span><br><span class="line">            transform.localScale &#x3D; new Vector3(-1, 1, 1);</span><br><span class="line">            isFaceLeft &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(speed, rb.velocity.y);</span><br><span class="line">        if (transform.position.x &gt; rightx)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale &#x3D; new Vector3(1, 1, 1);</span><br><span class="line">            isFaceLeft &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Csharp-基础</title>
    <url>/post/3315830508.html</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello World!&quot;); &#x2F;&#x2F;有换行符</span><br><span class="line">Console.Write(&quot;Hello New World&quot;!); &#x2F;&#x2F;无换行符</span><br></pre></td></tr></table></figure>

<p>C#区分大小写，字符串只能用<code>“”</code>，单字符char使用<code>&#39;&#39;</code></p>
<p>十进制文本：12.3m/12.3M（m/M-文本后缀）</p>
<a id="more"></a>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>字符类：string、char<br>计算类：int、decimal<br>布尔：bool</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量名区分大小写，使用驼峰命名法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char userOption;</span><br><span class="line">int gameScore;</span><br><span class="line">decimal particlesPerMillion;</span><br><span class="line">bool processedCustomer;</span><br></pre></td></tr></table></figure>

<p>使用前必须初始化。</p>
<p>可以使用<code>var</code>隐式创建变量。但初始化后推断出类型，则无法用另外的类型覆盖。且必须在初始化时使用，即<code>var word = &quot;hello!&quot;;</code></p>
<h4 id="逐字字符串"><a href="#逐字字符串" class="headerlink" title="逐字字符串"></a>逐字字符串</h4><p>逐字字符串文本保留所有空格和字符，且无需转义字符。使用时在文本字符串前加<code>@</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(&quot;C:\\Users\\Desktop&quot;);</span><br><span class="line">Console.WriteLine(@&quot;C:\Users\Desktop</span><br><span class="line">	(this is where your code goes)&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="字符串内插"><a href="#字符串内插" class="headerlink" title="字符串内插"></a>字符串内插</h4><p>使用“template”和一/多个内插表达式将多个值合为单个文本字符串。</p>
<p>内插表达式使用<code>{}</code></p>
<p>文本字符串使用<code>$</code>为前缀，该字符串变为模版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string firstName &#x3D; &quot;Bob&quot;;</span><br><span class="line">Console.WriteLine($&quot;Hello &#123;firstName&#125;!&quot;);</span><br><span class="line"></span><br><span class="line">string projectName &#x3D; &quot;First-Project&quot;;</span><br><span class="line">Console.WriteLine($@&quot;C:\Output\&#123;projectName&#125;\Data&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>除法中商必须为<code>decimal</code>，且除数或被除数必须为<code>decimal</code>（或两者都是），才能保证完全准确的结果</p>
<p>运算顺序PEMDAS：</p>
<ul>
<li>P 圆括号</li>
<li>E 指数</li>
<li>M 乘法 和 D 除法</li>
<li>A 加法 和 S 减法</li>
</ul>
<p>C#顺序相同，但没有<code>指数</code>。可以使用<code>System.Math.Pow()</code>方法。</p>
<h3 id="NET类库"><a href="#NET类库" class="headerlink" title=".NET类库"></a>.NET类库</h3><p>包含成千上万个方法的类的集合。</p>
<p>命名空间可视为类型的“姓氏”，类被组织称不同的命名空间，以防发生命名冲突。命名空间有助于确保任何两个类中不具有相同的全名。</p>
<h4 id="状态方法"><a href="#状态方法" class="headerlink" title="状态方法"></a>状态方法</h4><p>“状态”用来描述特定时刻下执行环境的状况。在代码执行过程中，应用程序的当前状态为存储在内存中的所有值的集合。</p>
<ul>
<li><p>无状态方法（静态方法）：正常工作不依赖于应用程序的当前状态，即在不引用或更改内存中存储的任何值的情况下正常工作。</p>
</li>
<li><p>有状态方法（实例方法）：依赖于由以前的已执行代码行存储在内存中的值构建的，即有状态方法通过更新值或将新值存储在内存中来修改应用程序的状态。有状态方法在字段（类上定义的变量）中跟踪方法的状态。</p>
</li>
</ul>
<p>单个类可支持有状态方法和无状态方法。需要调用有状态方法时，必须先创建类的实例，才能访问状态。</p>
<p>类的实例即对象。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string[] ids &#x3D; new string[3];</span><br><span class="line">string[] scores &#x3D; &#123;&quot;Abc&quot;,&quot;cdsd&quot;,&quot;sss&quot;&#125;;</span><br><span class="line">int length &#x3D; scores.Length;</span><br><span class="line">foreach(string num in scores)&#123; &#x2F;&#x2F;将每个元素执行一次</span><br><span class="line">	Console.WriteLine(num); &#x2F;&#x2F; foreach中不能分配num的值，它为foreach迭代内部实现的一部分</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 0; i&lt;2; i++)&#123;</span><br><span class="line">	Console.WriteLine(scores[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-tilemap&amp;角色移动&amp;刚体&amp;碰撞</title>
    <url>/post/1100701572.html</url>
    <content><![CDATA[<h2 id="制作地图（Tilemap）"><a href="#制作地图（Tilemap）" class="headerlink" title="制作地图（Tilemap）"></a>制作地图（Tilemap）</h2><ol>
<li>设置素材大小<code>Pixels Per Unit</code>为合适的数值</li>
<li>设置sprite Mode为Multiple用于切割</li>
<li>打开素材Sprite Editor编辑，选择不同slice方式切割素材</li>
<li>选择每个单元格的素材在scene中绘制地图<a id="more"></a>

</li>
</ol>
<h2 id="添加角色"><a href="#添加角色" class="headerlink" title="添加角色"></a>添加角色</h2><ol>
<li>设置素材大小为合适数值</li>
<li>将角色拖至<code>Hierarchy</code>中，设置其<code>sorting layer</code></li>
<li>在<code>Animation</code>窗口添加多张图片以添加动画</li>
<li>拖拽时间轴使动画频率合适</li>
</ol>
<h2 id="刚体–Rigidbody"><a href="#刚体–Rigidbody" class="headerlink" title="刚体–Rigidbody"></a>刚体–Rigidbody</h2><blockquote>
<p>让平面物体拥有重量，使其有重力，阻力等，可以受力的作用</p>
</blockquote>
<ol>
<li><code>Add Component</code>中选择<code>Rigidbody 2D</code></li>
<li>设置<code>Gravity Scale</code>重力为合适的数值</li>
<li>若使角色保持直立，则勾选<code>Constraints</code>中<code>Freeze Rotation</code>的Z轴使之锁定</li>
</ol>
<h2 id="碰撞–Collider"><a href="#碰撞–Collider" class="headerlink" title="碰撞–Collider"></a>碰撞–Collider</h2><blockquote>
<p>让物体可碰撞，接触。</p>
</blockquote>
<ol>
<li><code>Add Component</code>中选择需要的collider</li>
<li>勾选<code>Edit Collider</code>编辑角色碰撞的范围</li>
<li>设置不同图层，使角色与环境分离</li>
</ol>
<h2 id="角色移动"><a href="#角色移动" class="headerlink" title="角色移动"></a>角色移动</h2><ol>
<li><code>Edit</code>-&gt;<code>Project Settings</code>-&gt;<code>Input Manager</code>获取需要的输入信息</li>
<li>左右方向Horizontal，-1为左，0不动，1为右</li>
<li>编写脚本，距离=速度speed*单位位移*Time.delTime（delTime保证不同环境下都能顺滑移动），speed越高，移动的越快</li>
<li>跳跃时给角色添加跳跃的力<code>jumpForce</code>，在unity脚本页面设置的jumpForce越大跳的越高</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]private Rigidbody2D rb;</span><br><span class="line">public float speed;</span><br><span class="line">public float jumpForce;</span><br><span class="line"></span><br><span class="line">void movement()</span><br><span class="line">&#123;</span><br><span class="line">    float horizontalMove &#x3D; Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">    float faceDirection &#x3D; Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class="line">    &#x2F;&#x2F;角色移动</span><br><span class="line">    if(horizontalMove !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(horizontalMove * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line">        anim.SetFloat(&quot;running&quot;, Mathf.Abs(faceDirection)); </span><br><span class="line">    &#125;</span><br><span class="line">    if(faceDirection !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        transform.localScale &#x3D; new Vector3(faceDirection, 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;角色跳跃</span><br><span class="line">    if (Input.GetButtonDown(&quot;Jump&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(rb.velocity.x, jumpForce * Time.deltaTime);</span><br><span class="line">        anim.SetBool(&quot;jumping&quot;, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="角色移动时动画的改变"><a href="#角色移动时动画的改变" class="headerlink" title="角色移动时动画的改变"></a>角色移动时动画的改变</h2><ol>
<li>新建动画</li>
<li>打开<code>Animator</code>设置不同改变顺序</li>
<li>点击各箭头关闭<code>Has Exit Time</code>和<code>Transition Duration</code>使变化没有延迟时间</li>
<li>若需要变化条件，则在<code>Parameter</code>中新建不同的参数用于脚本使用</li>
<li>并在<code>Conditions</code>处设置不同的条件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]private Rigidbody2D rb;</span><br><span class="line">[SerializeField]private Animator anim;</span><br><span class="line"></span><br><span class="line">void switchAnim()</span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetBool(&quot;idle&quot;, false);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;跳跃到下落动画切换</span><br><span class="line">        if (anim.GetBool(&quot;jumping&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            if(rb.velocity.y &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                anim.SetBool(&quot;jumping&quot;, false);</span><br><span class="line">                anim.SetBool(&quot;falling&quot;, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if (coll.IsTouchingLayers(ground))&#x2F;&#x2F;下降到地面动画切换</span><br><span class="line">        &#123;</span><br><span class="line">            anim.SetBool(&quot;falling&quot;, false);</span><br><span class="line">            anim.SetBool(&quot;idle&quot;, true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="一些记录"><a href="#一些记录" class="headerlink" title="一些记录"></a>一些记录</h2><p>Input.GetAxis()//获取-1～0，0～1<br>Input.GetAxisRaw()//仅获取-1.0.1，左，不动，右</p>
<p>Vector2: 2维变化<br>Vector3: 3维变化    </p>
<p>FixedUpdate();<br>Update();</p>
<p>LayerMask: 在脚本中获取图层</p>
<p>public可以在script里看到<br>private不能看到，在start里初始化<br>[SerializeField]private则可以看到，但不能改</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS设置div垂直横向居中</title>
    <url>/post/3983223589.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre><code>最近写公司登陆页面，打算设置登录框水平竖直均居中，尝试了各种方式，最终解决方式如下</code></pre><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><pre><code>父级div：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.login-div&#123;</span><br><span class="line">	width: 100%,</span><br><span class="line">	height: 100%,</span><br><span class="line">	overflow: hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

子级登录框：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.login-box&#123;</span><br><span class="line">	&#x2F;&#x2F; 以左上角为原点,不处以中心位置</span><br><span class="line">	top: 50%,</span><br><span class="line">	left: 50%,</span><br><span class="line">	&#x2F;&#x2F; 往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置</span><br><span class="line">	transform: translate(-50%,-50%)</span><br><span class="line">	position: absolute</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>React(5)-构建React应用的一般步骤</title>
    <url>/post/3896685751.html</url>
    <content><![CDATA[<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>获得一张组件设计图和后台返回的JSON数据。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0bqnovjoj30f60g00uz.jpg" alt="设计图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="划分组件层级"><a href="#划分组件层级" class="headerlink" title="划分组件层级"></a>划分组件层级</h2><p>按照给定的组件设计图，划分组件层级。</p>
<p>将组件看作函数或对象来考虑，根据单一功能原则判定组件范围，即一个组件只负责一个功能。若负责多个功能则考虑将其拆分。</p>
<p>按给定的JSON数据模型设计UI（组件结构），使两者一一对应。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0byibhvyj30es0g876c.jpg" alt="划分组件"></p>
<p>如上图，可将整个设计图层级分为5部分：</p>
<ol>
<li>红色区域（FilterProductTable）：整个组件应用整体</li>
<li>绿色区域（SearchBar）：获取用户输入部分</li>
<li>蓝色部分（ProductTable）：整个数据展示部分</li>
<li>粉色部分（ProductCategoryRow）：数据展示部分的产品分类标题部分</li>
<li>橘色部分（ProductRow）：数据展示部分的分类下每个产品的部分。</li>
</ol>
<p>层级关系可表示为：</p>
<ul>
<li>FilterProductTable<ul>
<li>SearchBar</li>
<li>ProductTable<ul>
<li>ProductCategoryRow</li>
<li>ProductRow</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="根据层级关系编写应用的静态版本"><a href="#根据层级关系编写应用的静态版本" class="headerlink" title="根据层级关系编写应用的静态版本"></a>根据层级关系编写应用的静态版本</h2><p>应用静态版本即使用已有的数据模型渲染一个不包含交互的UI。</p>
<p>静态版本不需要考虑交互细节，而添加交互功能需要考虑大量的细节。故在实际应用中分开进行更合适。构建静态版本只需要通过props传入所需的数据，props是父组件向子组件传递数据的方式。此时不需要考虑state，因为state代表会随时间变化的数据，应只在交互时使用。</p>
<p>编写静态版本有两种方式：自上而下和自下而上。</p>
<ol>
<li>自上而下：先构建层级较高的组件，再自上而下分步细化组件。适用于构建简单的应用。</li>
<li>自下而上：先构建最基本的组件，再一层一层向上构建。适用于构建大型的项目。</li>
</ol>
<p>静态版本的组件提供<code>render()</code>方法用于渲染数据模型。故当数据模型改变，则调用<code>ReactDOM.render()</code>重新渲染，UI相应更新，即React的单向数据流思想。</p>
<p>相应代码见<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React官方文档</a></p>
<h2 id="确定state变量"><a href="#确定state变量" class="headerlink" title="确定state变量"></a>确定state变量</h2><blockquote>
<p>全称:Don’t Repeat Yourself (摘自wikipedia),是指编程过程中不写重复代码,将能够公共的部分抽象出来,封装成工具类或者用“abstraction”类来抽象公有的东西,降低代码的耦合性,</p>
</blockquote>
<p>按照DRY原则，只保留应用所需的<code>state</code>的最小集合，其他数据由此<code>state</code>计算得出。</p>
<p>确定<code>state</code>需考虑以下问题：</p>
<ol>
<li>该数据是否由父组件通过<code>props</code>传递而来，若是，则不是<code>state</code></li>
<li>该数据是否变化？若保持不变，则不是<code>state</code></li>
<li>该数据是否能根据其他数据计算而来，若是，则不是<code>state</code>。</li>
</ol>
<p>由上文可得，产品的所有信息都可由父组件<code>FilterProductTable</code>传递而来，故不是<code>state</code>。<code>SearchBar</code>中的搜索字段和checkbox选中值需要由用户交互而变化，且无法由其他数据计算而来，故应该为<code>state</code></p>
<h2 id="确定state位置"><a href="#确定state位置" class="headerlink" title="确定state位置"></a>确定state位置</h2><p>由于React的数据是单向流动，且按组件层级自上而下传递，故<code>state</code>所属的组件很难确定。</p>
<p>判断时，依照如下步骤考虑：</p>
<ol>
<li>查看根据此<code>state</code>渲染的所有组件</li>
<li>找到这些组件的共同所有者组件，即层级高于这些组件的组件</li>
<li>该共同所有者组件或比他层级更高的组件应该拥有此<code>state</code></li>
<li>若无法找到合适的位置存放<code>state</code>，则可以创建一个新的组件来存放<code>state</code>。</li>
</ol>
<p>根据上述步骤，可发现：</p>
<ol>
<li><code>SearchBar</code>和<code>ProductTable</code>都需要此state。<code>SearchBar</code>需要state展示搜索框和checkbox的状态。<code>ProductTable</code>需要根据state筛选产品列表。</li>
<li><code>SearchBar</code>和<code>ProductTable</code>的共同所有者是<code>FilterProductTable</code></li>
<li>因此state应存放在<code>FilterProductTable</code>中。</li>
</ol>
<p>首先，将实例属性<code>this.state = {filterText: &#39;&#39;, inStockOnly: false}</code>添加到<code>FilterableProductTable</code>的 <code>constructor</code>中，设置应用的初始 <code>state</code>；接着，将<code>filterText</code>和<code>inStockOnly</code>作为<code>props</code>传入 <code>ProductTable</code>和<code>SearchBar</code>；最后，用这些<code>props</code>筛选<code>ProductTable</code>中的产品信息，并设置<code>SearchBar</code>的表单值。</p>
<p>相应代码见<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React官方文档</a></p>
<h2 id="添加state的数据流控制"><a href="#添加state的数据流控制" class="headerlink" title="添加state的数据流控制"></a>添加state的数据流控制</h2><p>之前步骤通过props和state自上而下传递了需要的数据。现在控制处于较低层级的表单组件更新较高组件中的state，以达到完成交互。</p>
<p>要实现的功能是：<br>用户改变表单的值-&gt;改变state反映用户输入。</p>
<p>state只能由拥有它的组件进行更改，故需要设置一个能触发state改变的回调函数传递给SearchBar。思路为：</p>
<ol>
<li>使用输入框的onChange事件监视用户输入</li>
<li>当用户改变表单的值，触发onChange事件，调用表单组件的handle方法。</li>
<li>表单组件的handle方法调用父组件FilterProductTable的onFilterTextChange事件</li>
<li>FilterProductTable的handleFilterTextChange方法使用setState改变state的值，更新应用</li>
</ol>
<p>所有代码见<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React官方文档</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(4)-状态提升及组合</title>
    <url>/post/1961399673.html</url>
    <content><![CDATA[<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>React应用中，任何可变的数据应只有一个唯一数据源，此时state首先添加到需要渲染的组件中。但当多个组件需要共用反映同样的变化数据时，即其他组件也需要这个state时，需要将state提升到这些组件的共同父组件中。通过自顶向下的数据源，更新唯一的数据源state。</p>
<p>在子组件中使用<code>this.props.xxx</code>代替<code>this.state</code>。在共同父组件中使用<code>state</code>更新子组件中的值。</p>
<a id="more"></a>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>React有丰富的组合模式，供组件间的代码重用。</p>
<h3 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FancyBorder(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&#123;&#39;FancyBorder FancyBorder-&#39; + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color&#x3D;&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&quot;Dialog-title&quot;&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p className&#x3D;&quot;Dialog-message&quot;&gt;</span><br><span class="line">        Thank you for visiting our spacecraft!</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WelcomeDialog</code>方法中<code>&lt;FancyBorder&gt;</code>标签内的内容对应<code>FancyBorder</code>函数里的<code>{props.children}</code>，此时<code>props.children</code>中的内容都被渲染到<code>&lt;div&gt;</code>中。</p>
<p>也可以通过标签属性来自行约定<code>children</code>，将所需的内容传入props。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Contacts() &#123;</span><br><span class="line">  return &lt;div className&#x3D;&quot;Contacts&quot; &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Chat() &#123;</span><br><span class="line">  return &lt;div className&#x3D;&quot;Chat&quot; &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function SplitPane(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;SplitPane&quot;&gt;</span><br><span class="line">      &lt;div className&#x3D;&quot;SplitPane-left&quot;&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div className&#x3D;&quot;SplitPane-right&quot;&gt;</span><br><span class="line">        &#123;props.right&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SplitPane</span><br><span class="line">      left&#x3D;&#123;</span><br><span class="line">        &lt;Contacts &#x2F;&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right&#x3D;&#123;</span><br><span class="line">        &lt;Chat &#x2F;&gt;</span><br><span class="line">      &#125; &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中<code>&lt;Contacts /&gt;</code>和<code>&lt;Chat /&gt;</code>本质即为对象，故可以当作props来传递。</p>
<h3 id="特例关系"><a href="#特例关系" class="headerlink" title="特例关系"></a>特例关系</h3><p>有些组件可看作其他组件的特殊实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Dialog(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color&#x3D;&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&quot;Dialog-title&quot;&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p className&#x3D;&quot;Dialog-message&quot;&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Dialog</span><br><span class="line">      title&#x3D;&quot;Welcome&quot;</span><br><span class="line">      message&#x3D;&quot;Thank you for visiting our spacecraft!&quot; &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(3)-列表及简单表单</title>
    <url>/post/276282746.html</url>
    <content><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>使用<code>{}</code>在JSX构建一个元素集合。<br>使用JS的<code>map()</code>方法遍历数组，将数组中的元素变成<code>&lt;li&gt;</code>标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const number &#x3D; [1,2,3,4,5];</span><br><span class="line">const listitems &#x3D; numbers.map((number) &#x3D;&gt; </span><br><span class="line">    &lt;li&gt;&#123;number&#125;&lt;&#x2F;li&gt;</span><br><span class="line">);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;&#x2F;ul&gt;,</span><br><span class="line">document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>当创建元素时必须包含一个key属性。key属性帮助React识别元素的变化。</p>
<h4 id="key的正确使用"><a href="#key的正确使用" class="headerlink" title="key的正确使用"></a>key的正确使用</h4><p>一个元素的key最好是元素在列表中拥有的独一无二的字符串，万不得已时才使用索引作为key。</p>
<p>元素的key只有放在就近的数组上下文才有意义。故如果提取一个组件，就应把组件的key保留在该组件的元素上，而不是它里面的子元素上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ListItem(props)&#123;</span><br><span class="line">    &#x2F;&#x2F;子元素无需指定key</span><br><span class="line">    return &lt;li&gt;&#123;props.value&#125;&lt;&#x2F;li&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function NumberList(props)&#123;</span><br><span class="line">    const numbers &#x3D; props.numbers;</span><br><span class="line">    const listItems &#x3D; numbers.map((number) &#x3D;&gt;</span><br><span class="line">    &#x2F;&#x2F;key应在数组的上下文中指定，经验法则：在map()中的元素需指定key属性</span><br><span class="line">        &lt;ListItem key&#x3D;&#123;number.toString()&#125; value&#x3D;&#123;number&#125; &#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">    return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers&#x3D;&#123;numbers&#125; &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="key的唯一性"><a href="#key的唯一性" class="headerlink" title="key的唯一性"></a>key的唯一性</h4><p>key在兄弟节点之间必须唯一，但不是全局唯一。即当有两个不同的数组时，key可以相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sidebar &#x3D; (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.posts.map((post) &#x3D;&gt;</span><br><span class="line">        &lt;li key&#x3D;&#123;post.id&#125;&gt;</span><br><span class="line">          &#123;post.title&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  );</span><br><span class="line">  const content &#x3D; props.posts.map((post) &#x3D;&gt;</span><br><span class="line">    &lt;div key&#x3D;&#123;post.id&#125;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;post.title&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;post.content&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>key传递信息给React，但不会传递给组件。因此，若需要使用key的值，需要使用其他属性将其显式的传递出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const content &#x3D; posts.map((post) &#x3D;&gt;</span><br><span class="line">  &lt;Post</span><br><span class="line">    key&#x3D;&#123;post.id&#125;</span><br><span class="line">    id&#x3D;&#123;post.id&#125;</span><br><span class="line">    title&#x3D;&#123;post.title&#125; &#x2F;&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="在JSX中嵌入map"><a href="#在JSX中嵌入map" class="headerlink" title="在JSX中嵌入map()"></a>在JSX中嵌入map()</h3><p>以上都是声明单独的变量并将其包含在JSX中，但JSX允许在大括号<code>{}</code>中嵌入表达式，因此可以直接内联<code>map()</code>返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function NumberList(props)&#123;</span><br><span class="line">    const numbers &#x3D; props.numbers;</span><br><span class="line">    return (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;numbers.map((number) &#x3D;&gt; </span><br><span class="line">                &lt;ListItem key&#x3D;&#123;number.toString()&#125;</span><br><span class="line">                          value&#x3D;&#123;number&#125;</span><br><span class="line">                &#x2F;&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>HTML表单与其他DOM元素不同，它内部通常保持一些state，大多情况下，使用JavaScript函数可以方便的处理表单提交，同时访问用户填写的表单数据。实现此效果的标准方式是使用受控组件</p>
<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>受控组件使React的state成为唯一数据源。渲染表单的React组件控制用户输入过程中发生的操作。（结合state及事件处理操作）</p>
<h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    &#x2F;&#x2F;输入input组件值由state控制，此处设置初始值。</span><br><span class="line">    this.state &#x3D; &#123;value: &#39;&#39;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit &#x3D; this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;input框内容改变事件</span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;提交内容事件</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&#39;提交的名字: &#39; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          名字:</span><br><span class="line">          &#x2F;&#x2F;state.value是input框的唯一数据源</span><br><span class="line">          &#x2F;&#x2F;onChange事件会在用户每一次按键后更新React的state</span><br><span class="line">          &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h4><p>text的使用与input相同，但默认有初值</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select选择框的选中属性使用value控制，而不使用selected属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;value: &#39;coconut&#39;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit &#x3D; this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          选择你喜欢的风味:</span><br><span class="line">          &lt;select value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;grapefruit&quot;&gt;葡萄柚&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;lime&quot;&gt;酸橙&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;coconut&quot;&gt;椰子&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;mango&quot;&gt;芒果&lt;&#x2F;option&gt;</span><br><span class="line">          &lt;&#x2F;select&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>option内容也可直接在select标签内将数组传递到vlue属性。使用多选时，设置<code>multiple={true}</code></p>
<h3 id="接受多个输入"><a href="#接受多个输入" class="headerlink" title="接受多个输入"></a>接受多个输入</h3><p>当需要处理多个input元素时，给每个元素添加<code>name</code>属性，处理函数根据<code>event.target.name</code>选择要执行的操作。<code>setState()</code>自动将部分state合并到当前state。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Reservation extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      isGoing: true,</span><br><span class="line">      numberOfGuests: 2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleInputChange &#x3D; this.handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    const target &#x3D; event.target;</span><br><span class="line">    const value &#x3D; target.name &#x3D;&#x3D;&#x3D; &#39;isGoing&#39; ? target.checked : target.value;</span><br><span class="line">    const name &#x3D; target.name;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          参与:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;isGoing&quot;</span><br><span class="line">            type&#x3D;&quot;checkbox&quot;</span><br><span class="line">            checked&#x3D;&#123;this.state.isGoing&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          来宾人数:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;numberOfGuests&quot;</span><br><span class="line">            type&#x3D;&quot;number&quot;</span><br><span class="line">            value&#x3D;&#123;this.state.numberOfGuests&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(2)-事件处理及条件渲染</title>
    <url>/post/3697640733.html</url>
    <content><![CDATA[<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><blockquote>
<p>为了与传统HTML区别开，React事件命名采用小驼峰（camelCase）形式。<br>使用JSX语法时需要传入函数作为事件处理函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&#123;function&#125;&gt;</span><br><span class="line">Function</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>阻止默认行为必须显式的使用<code>preventDefault</code></p>
<a id="more"></a>    

 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ActionLink()&#123;</span><br><span class="line">    function handleClick(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        console.log(&quot;Clicked!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;a href&#x3D;&quot;#&quot; onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">        Click me!</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> e为合成事件，无跨浏览器的兼容问题。</p>
</li>
<li><p>使用React不需要使用<code>addEventListener</code>为DOM元素添加监听器。只需要在元素初始渲染时添加监听器即可。</p>
</li>
<li><p>使用class定义组件时，通常将事件处理函数声明为class的方法。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    class Toggle extends React.Component &#123;</span><br><span class="line">        constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state &#x3D; &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 为了在回调中使用 &#96;this&#96;，这个绑定是必不可少的</span><br><span class="line">        this.handleClick &#x3D; this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class="line">            &#123;this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;&#125;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;Toggle &#x2F;&gt;,</span><br><span class="line">        document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p> JavaScript中class方法默认不会绑定this。若在JSX中没有绑定this.handleClick并把它传入onClick。则调用函数时，this的值为undifined。</p>
</li>
<li><p>事件绑定this<br> <strong>优先使用方法一和方法二</strong></p>
<ul>
<li><p>方法一：bind<br>如3中代码所示</p>
</li>
<li><p>方法二：class field语法<br>class field语法为实验性语法</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LoggingButton extends React.Component&#123;</span><br><span class="line">    handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;this is:&#39;, this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class="line">            Click me</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  create React app默认使用该方法。</p>
</li>
<li><p>方法三：回调函数中使用箭头函数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    class LoggingButton extends React.Component &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">        console.log(&#39;this is:&#39;, this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">        &#x2F;&#x2F; 此语法确保 &#96;handleClick&#96; 内的 &#96;this&#96; 已被绑定。</span><br><span class="line">            return (</span><br><span class="line">                &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.handleClick()&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="向事件处理函数传递参数"><a href="#向事件处理函数传递参数" class="headerlink" title="向事件处理函数传递参数"></a>向事件处理函数传递参数</h3><p>当向事件处理函数传递额外参数时，有两种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一：箭头函数</span><br><span class="line">&lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; this.deleteRow(id, e)&#125;&gt;Delete&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F;方法二：Function.prototype.bind</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.deleteRow.bind(this,id)&#125;&gt;Delete&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>箭头函数中，事件对象e必须显式的传递，bind方式，事件对象e及更多参数会被隐式的传递。</p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="使用if渲染"><a href="#使用if渲染" class="headerlink" title="使用if渲染"></a>使用if渲染</h3><p>即if-else语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件)&#123;</span><br><span class="line">    return 元素1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    return 元素2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">let 变量;</span><br><span class="line">if(条件)&#123;</span><br><span class="line">    变量 &#x3D; 元素1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    变量 &#x3D; 元素2;</span><br><span class="line">&#125;</span><br><span class="line">return (变量);</span><br></pre></td></tr></table></figure>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符为JSX中内联条件渲染的方法，通过花括号<code>{}</code>包裹代码。</p>
<h4 id="使用-amp-amp-渲染"><a href="#使用-amp-amp-渲染" class="headerlink" title="使用&amp;&amp;渲染"></a>使用&amp;&amp;渲染</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;条件 &amp;&amp; 表达式&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>true &amp;&amp; expression</code> =&gt; <code>expression</code><br><code>false &amp;&amp; expression</code> =&gt; <code>false</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="line">&lt;h2&gt;</span><br><span class="line">You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">&lt;&#x2F;h2&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; condition ? true expression : false expression&#125;</span><br></pre></td></tr></table></figure>


<h3 id="阻止渲染（隐藏组件）"><a href="#阻止渲染（隐藏组件）" class="headerlink" title="阻止渲染（隐藏组件）"></a>阻止渲染（隐藏组件）</h3><p>若希望组件隐藏，可以让<code>render</code>方法返回<code>null</code>。不进行任何渲染，此种方式不会影响组件的生命周期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function WarningBanner(props) &#123;</span><br><span class="line">  if (!props.warn) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;warning&quot;&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Page extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;showWarning: true&#125;;</span><br><span class="line">    this.handleToggleClick &#x3D; this.handleToggleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      showWarning: !state.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn&#x3D;&#123;this.state.showWarning&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.showWarning ? &#39;Hide&#39; : &#39;Show&#39;&#125;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(1)-基础知识</title>
    <url>/post/628658596.html</url>
    <content><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React是一个声明式，高效且灵活的用于构建用户界面的JavaScript库。使用React可以将一些简短、独立的代码片段组合成复杂的UI界面，这些代码片段称为“组件”。</p>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>JSX是JavaScript的语法拓展，可以生成React“元素”。React认为渲染逻辑与其他UI逻辑内在耦合，故其没有采用将标记和逻辑分离在不同文件的方式，而是将他们共同存入“组件”的松散耦合单元中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;JSX语法</span><br><span class="line">&lt;div &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">React.createElement(&#39;div&#39;)</span><br></pre></td></tr></table></figure>

<p>在JSX中可以任意使用JavaScript表达式，只需要用大括号<code>{}</code>括起来。</p>
<a id="more"></a>
<ul>
<li><p>使用<code>{}</code>嵌入元素：可嵌入变量、表达式、函数等。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello,&#123;formatName(user)&#125;&lt;&#x2F;h1&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>&quot;&quot;</code>：将属性值指定为字符串字面量。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;div tabIndex&#x3D;&quot;0&quot;&gt;&lt;&#x2F;div&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>{}</code>：在属性值插入一个JavaScript表达式。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;img src&#x3D;&#123;user.avatarUrl&#125;&gt;&lt;&#x2F;img&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>JSX可以安全的插入用户输入的内容：React DOM渲染输入内容前，默认会进行转义。可以确保在应用中，永远不会注入并非自己明确编写的内容。所有内容渲染之前都被转换成了字符串。此方法可以有效防止XSS（跨站脚本）攻击。</p>
</li>
<li><p><code>React.createElement()</code>：创建React对象，即React元素。描述了用户希望在屏幕上看到的内容。React通过读取这些对象并使用他们来构建DOM以及保持随时更新。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &#123;</span><br><span class="line">    &lt;h1 className&#x3D;&quot;greeting&quot;&gt;</span><br><span class="line">        Hello, world!</span><br><span class="line">    &lt;&#x2F;h1&gt;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">const element &#x3D; React.createElement(</span><br><span class="line">    &#39;h1&#39;,</span><br><span class="line">    &#123;className: &#39;greeting&#39;&#125;,</span><br><span class="line">    &#39;Hello, world!&#39;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;创建对象的结构如下：</span><br><span class="line">const element &#x3D; &#123;</span><br><span class="line">    type: &#39;h1&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        className: &#39;greeting&#39;,</span><br><span class="line">        children: &#39;Hello, world!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意点：</p>
<ol>
<li><p>空元素必须用/结束，如<code>&lt;br /&gt;</code></p>
</li>
<li><p>根元素不能为两个，如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;Hello World!&lt;p&gt;</span><br><span class="line">    &lt;br&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;&lt;p&gt;和&lt;br&#x2F;&gt;为两个根元素，故只能用&lt;div&gt;包起来。</span><br></pre></td></tr></table></figure></li>
<li><p>JSX的属性和方法命名规则都必须为小驼峰，如<code>className</code></p>
</li>
<li><p>if使用<code>&amp;&amp;</code>表示，<code>&amp;&amp;</code>前为条件，后为执行的JSX语句</p>
</li>
<li><p>if-else使用<code>a?b:c</code>，a为条件，是执行b，else执行c</p>
</li>
<li><p>循环语句使用数组的map方法实现，在回调函数里处理每个子元素。为了方便的找出哪个节点有更新，其循环的子元素都必须加唯一id。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.map((number) &#x3D;&gt; </span><br><span class="line">    &lt;listItem key&#x3D;&#123;number.toString()&#125;       &#x2F;&#x2F;key-&gt;唯一id</span><br><span class="line">              value&#x3D;&#123;number&#125; &#x2F;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h3><p>元素是构成React应用的最小模块，是创建开销极小的普通对象。</p>
<p>每一个React元素都是一个JavaScript对象，可以在程序中保存到变量中或作为参数传递。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello, world&lt;&#x2F;h1&gt;;</span><br></pre></td></tr></table></figure>

<p>若要将React元素渲染到根DOM节点root，使用ReactDOM.render()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello, world&lt;&#x2F;h1&gt;;</span><br><span class="line">ReactDOM.render(element, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure>

<p>React元素不可变。一旦被创建就无法更改它的子元素或属性，它代表了某个特定时刻的UI。要修改元素只能通过重新绑定新的元素渲染或通过state修改。</p>
<h3 id="组件及Props"><a href="#组件及Props" class="headerlink" title="组件及Props"></a>组件及Props</h3><p>组件，类似于JavaScript函数，接受任意的入参（props），通过<code>render</code>方法返回用于描述页面展示内容的React元素。</p>
<p>两种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：函数</span><br><span class="line">function Welcome(props)&#123;</span><br><span class="line">    return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：ES6的class</span><br><span class="line">class Welcome extends React.Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Welcome(props)&#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意：组件名称必须使用大写字母开头。</p>
<p>自定义组件可以在其输出（return ）中引入其他组件，即组合组件。</p>
<h4 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h4><p>多层嵌套的组合组件若其中包含可复用的组件，可将组件提取出来，构建可复用的组件库。同样，若组件本身过于复杂，也可将其中的元素提取成组件，构建为可复用的组件。</p>
<blockquote>
<p>注意：组件的props绝不能修改，要像纯函数一样保护props不被修改。</p>
</blockquote>
<p>纯函数：函数不会更改入参，多次调用下相同的入参返回相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;非纯函数</span><br><span class="line">function test(a,b)&#123;</span><br><span class="line">    a +&#x3D; b;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;纯函数</span><br><span class="line">function test(a,b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数组件转换class组件"><a href="#函数组件转换class组件" class="headerlink" title="函数组件转换class组件"></a>函数组件转换class组件</h4><ol>
<li>创建同名<code>ES6 class</code>，继承于<code>React.Component</code>。</li>
<li>添加空的<code>render()</code>方法。</li>
<li>将函数组件的函数体移入<code>render()</code>方法中。</li>
<li>将<code>render()</code>方法中的<code>props</code>改为<code>this.props</code>。</li>
<li>删除空的函数组件。</li>
</ol>
<h3 id="state-amp-生命周期"><a href="#state-amp-生命周期" class="headerlink" title="state&amp;生命周期"></a>state&amp;生命周期</h3><blockquote>
<p>React把组件看作状态机。通过与用户的交互，实现不同的状态，渲染UI，让用户界面和数据保持一致。state与props类似，但state是私有的，完全受控于当前组件。React中，只需更新组件的state，根据新的state重新渲染用户界面。</p>
</blockquote>
<p>使用构造函数初始化<code>this.state</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props)&#123;</span><br><span class="line">    &#x2F;&#x2F;使用super函数将props传递到父类的构造函数中</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;date: new Date()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>render()</code>函数中使用<code>this.state</code>获取state中的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><blockquote>
<p>当组件第一次被渲染到DOM中时，调用<code>componentDidMount()</code>函数=&gt; 挂载(mount)<br>当组件被删除时，调用<code>componentWillUnmount()</code>。=&gt;卸载(unmount)</p>
</blockquote>
<p><strong>调用顺序：</strong></p>
<ol>
<li>当组件传给React.render()时，React调用组件的构造函数constructor()初始化this.state。</li>
<li>React调用render()方法。确定在该页面展示内容。更新DOM渲染输出。</li>
<li>当组件的输出插入到DOM后，调用componentDidMount()方法设置挂载时需运行的内容。</li>
<li>若需更新state，需在挂载内容时使用setState()方法更新state。并重新调用render()渲染更新过的数据，相应的更新DOM。</li>
<li>当组件从DOM移除，React调用componentWillUnmount()方法卸载。</li>
</ol>
<h4 id="state注意事项"><a href="#state注意事项" class="headerlink" title="state注意事项"></a>state注意事项</h4><ol>
<li><p>更新state<br>直接修改<code>state</code>不会重新渲染组件，如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此种修改不会渲染组件</span><br><span class="line">this.state.comment &#x3D; &quot;Hello&quot;; </span><br><span class="line">&#x2F;&#x2F;使用setState才能达到更新目的</span><br><span class="line">this.setState(&#123;comment: &#39;Hello&#39;&#125;);</span><br></pre></td></tr></table></figure>
<p> 构造函数是唯一可以给<code>this.state</code>赋值的地方。</p>
</li>
<li><p>state更新可能异步<br> <code>this.props</code>和<code>this.state</code>可能是异步更新的，故如下操作无法更新内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">    counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;若想更新，可让setState()接受函数，而非对象。</span><br><span class="line">this.setState((state, props) &#x3D;&gt; (&#123;</span><br><span class="line">    counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br><span class="line">&#x2F;&#x2F;不使用匿名箭头函数，使用普通函数也可</span><br></pre></td></tr></table></figure>
</li>
<li><p>state合并更新<br> 出于性能考虑，React可能会把多个<code>setState()</code>合并成一个调用。并将提供的对象合并到当前的<code>state</code>，进行部分替换，而非全局覆盖。<br> 如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">        posts: [],</span><br><span class="line">        comments: []</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;更新posts时，只会替换posts部分，comments不变。更新comments同理。</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    fetchPosts().then(response &#x3D;&gt; &#123;</span><br><span class="line">        this.setState(&#123;posts: response.posts&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数据自顶向下<br>无论父组件还是子组件都无法知道某组件是否有状态，且不关心是函数组件还是class组件。除了拥有并设置了state的组件，其他组件都无法访问。但组件可以选择把它的state作为props向下传递给它的子组件。从该state派生的任何数据或UI只能影响树中低于它的组件。<br>每个组件都是真正独立的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离与SPA的理解</title>
    <url>/post/3950340485.html</url>
    <content><![CDATA[<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><h3 id="一些概念理解"><a href="#一些概念理解" class="headerlink" title="一些概念理解"></a>一些概念理解</h3><ul>
<li>前端：在浏览器端运行的内容为前端。通常是用HTML+CSS+JS来实现的，如APP、小程序、H5等。</li>
<li>后端：在服务器端运行的内容为后端。如Java、C、Python、PHP等</li>
<li>静态页面：网页中没有程序代码，仅HTML。一般静态页面一旦生成，内容就不会被改变。</li>
<li>动态页面：网页文件除了HTML还包括一些程序代码使浏览器可以与服务器交互，随用户交互的不同请求动态的生成网页内容。</li>
<li>网页的静态化：将动态数据都提前生成为静态的html页面，避免从数据库取数的时间。</li>
<li>DOM：文档对象模型（Document Object Model），一种将HTML/XML文档组织成对象模型（DOM树）的建模过程。</li>
<li>虚拟DOM：DOM树结构在内存里的映射</li>
</ul>
<a id="more"></a>
<h3 id="前后端不分离架构"><a href="#前后端不分离架构" class="headerlink" title="前后端不分离架构"></a>前后端不分离架构</h3><p>传统的不分离架构的设计大致为：</p>
<ol>
<li>浏览器发出请求。</li>
<li>服务器收到请求，从数据库取出数据后，生成渲染整个页面发送给浏览器。</li>
<li>浏览器将页面展示给用户。</li>
<li>以上步骤循环进行。</li>
</ol>
<p>此种方式缺点是不但无法将前后端开发人员的职能分开（或要求开发人员掌握全栈），且在技术层面，每一次请求，要发送的内容数量很大，包括整个HTML、CSS以及JavaScript。</p>
<p>优点是服务器可以缓存整个页面，页面静态化或访问时可以不用再次访问数据。</p>
<p>若需要提升性能，要么提升服务器响应时间，要么压缩传输的内容。相比之下，压缩传输的内容的优化更有效。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>不分离架构需传输的内容太多，是否可以只传输变化的内容。因此引出了Ajax。</p>
<p>Ajax只传输数据，不传输整个网页。此时处于一种半分离的状态。设计大概为：</p>
<ol>
<li>浏览器发出请求。</li>
<li>HTML中的JS代码以Ajax方式向后台接口请求数据。</li>
<li>后台接口返回JSON数据</li>
<li>页面解析Json数据，通过DOM渲染页面展示给用户。</li>
</ol>
<p>此种方式前端不会嵌入过多后台代码，前端专注自己的开发，不依赖后段。</p>
<p>缺点是JS会出现大量冗余。若JSON数据量大，渲染仍然会花费很长时间。若业务复杂，一个页面需要发起多次http请求才能渲染完整个页面。</p>
<h3 id="前后端分离架构"><a href="#前后端分离架构" class="headerlink" title="前后端分离架构"></a>前后端分离架构</h3><p>由此产生前后端分离架构，前端只负责view和controller层，后段只负责model层、业务处理和数据持久化。前后端只通过JSON交流。</p>
<ol>
<li>浏览器发出请求。</li>
<li>Web服务器解析请求，经过转换，发送给各个相关的后端服务器。</li>
<li>后端服务器返回处理过的业务数据。</li>
<li>Web服务器将返回的业务数据填入HTML模版发送给浏览器。</li>
<li>浏览器展示页面。</li>
</ol>
<p>前后端人员约定好接口后，就可以各自开发测试。前端不用关心业务处理，后端也不用关心前端界面。代码管理、服务部署也可以分别管理。</p>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>SPA（Single Page Web Applications）单页应用，是实践前后端分离架构最好的方案。它是一种只需要将单个页面加载到浏览器中的Web应用程序。</p>
<p>工作时，在Web页面初始化时，就加载完相应的HTML、CSS、JS内容，以后不会因用户的操作而进行页面的重新加载或跳转。当用户交互时，只通过Javascript动态变换HTML的内容，即进行部分内容的动态切换和替换。</p>
<p>优点：用户体验快，避免不必要的跳转和页面的重复渲染，加快了对数据的刷新，对服务器压力小。且共用一套后端代码即可同时应用于Web界面、手机、平板等多种客户端。</p>
<p>缺点：SEO难度较高，页面的前进后退管理复杂，且初次加载时可能耗时会较长。</p>
<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><h4 id="动态切换视图"><a href="#动态切换视图" class="headerlink" title="动态切换视图"></a>动态切换视图</h4><ul>
<li><p>通过JavaScript的<code>$().replacewith()</code>等方法实现切换。</p>
</li>
<li><p>通过URL路由机制，从URL路由中的hashtag获取信息，再通过<code>window.location.hash.slice()</code>方法实现页面内容切换</p>
</li>
</ul>
<h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><ol>
<li>通过ajax获取数据</li>
<li>载入前占位提示。由于从服务器端获取数据需要时间，则设置一个占位符，如loading样式、文字提示，表示数据正在载入，请等待。</li>
<li>异步操作(取数据渲染页面)：await callback promise</li>
</ol>
<h4 id="模版替换"><a href="#模版替换" class="headerlink" title="模版替换"></a>模版替换</h4><ol>
<li>JSON数据转换：JSON是字符串，需要将它转换为DataObject使用，jQuery会自动解析，其他的库需要自己解析</li>
<li>模版替换：数据转换后就发给模版，将对应内容进行替换，得到HTML </li>
</ol>
<h4 id="双向绑定和动态渲染"><a href="#双向绑定和动态渲染" class="headerlink" title="双向绑定和动态渲染"></a>双向绑定和动态渲染</h4><p>服务器端渲染：一次请求渲染一次，新的数据变更在新的请求后渲染。</p>
<p>前端SPA渲染：用户修改数据，相应的数据要同步修改，故需要用到事件机制通知。修改数据后触发事件机制，事件绑定的函数检查修改的数据，重新通过模版渲染页面，填回DOM对应的地方，即做到自动更新。</p>
<p>问题：实现时，每次修改可能会渲染整个页面，效率十分低。</p>
<p>解决：只渲染修改的部分。</p>
<h5 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h5><blockquote>
<p>调用虚拟DOM实现动态渲染修改的内容。</p>
</blockquote>
<p>每次修改完内容，按新内容在内存里构建一个新的虚拟DOM树， 与旧的DOM树比较，检查节点变动情况，再到真实的DOM树中，修改对应的节点，完成渲染更新。</p>
<h4 id="组件化和重用"><a href="#组件化和重用" class="headerlink" title="组件化和重用"></a>组件化和重用</h4><p>支持自定义标签，在重用时只需要关注内容，不需要关心具体结构。若需要变动，只需要调整自定义标签的模版，那整个页面使用的自定义标签都会自动更新。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>SPA</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式学习笔记</title>
    <url>/post/2092262605.html</url>
    <content><![CDATA[<p>正则表达式定义了字符串的模式，可以用来搜索、编辑、处理文本。用<code>//</code>包围一个正则表达式</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>测试字符串内模式（数据验证）</li>
<li>替换文本</li>
<li>基于模式匹配提取子字符串</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式由普通字符以及特殊字符（元字符）组成。</p>
<a id="more"></a>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>包括没有显式指定为元字符的所有可打印、不可打印字符。（包括所有大小写字母、数字、标点符号、其他符号）</p>
<ul>
<li>不可打印字符：匹配包括换页符<code>\f</code>、换行符<code>\n</code>、回车符<code>\r</code>、空白字符<code>\s</code>、制表符<code>\t</code>等字符。</li>
</ul>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>类似关键字，匹配特殊字符时需要先使用<code>\</code>将其转义。</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串中的开始位置，若放在方括号表达式中使用，表示不接受该方括号表达式中的字符集合</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾。若设置了<code>RegExp</code>对象的<code>Multiline</code>属性，则也匹配<code>\n</code>和 <code>\r</code></td>
</tr>
<tr>
<td>()</td>
<td>标记子字符串的开始和结束</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式0次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式1次或多次 （至少要有一次）</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式0次或1次（最多1次）</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符\n之外的所有单字符</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为特殊字符或向后引用或转义符或原义字符</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择</td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>用来指定正则表达式中一个给定组件必须出现多少次才能满足匹配，共6种：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式0次或多次，等价于<code>{0,}</code>，如<code>/zo*/</code>匹配<code>z</code>、<code>zoo</code>、<code>zoooo</code></td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式1次或多次 （至少要有一次），如<code>/zo+/</code>匹配<code>zo</code>、<code>zoo</code>，不匹配<code>z</code></td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式0次或1次（最多1次），如<code>/zo?/</code>，只能匹配<code>z</code>、<code>zo</code>，不匹配<code>zoooo</code>等</td>
</tr>
<tr>
<td>{n}</td>
<td><code>n</code>为非负整数。匹配前面的子表达式n次，如<code>o{2}</code>匹配<code>zoo</code>、<code>book</code>，不匹配<code>box</code></td>
</tr>
<tr>
<td>{n,}</td>
<td><code>n</code>为非负整数。至少匹配前面的子表达式n次，如<code>o{2,}</code>匹配<code>zoo</code>、<code>boooook</code>，不匹配<code>box</code></td>
</tr>
<tr>
<td>{n,m}</td>
<td><code>n</code>、<code>m</code>为非负整数，且<code>n&lt;=m</code>。最少匹配前面的子表达式n次，且最多匹配前面的子表达式m次，如<code>o{2,4}</code>匹配<code>zoo</code>、<code>boook</code>，不匹配<code>box</code>、<code>booooox</code></td>
</tr>
</tbody></table>
<blockquote>
<p>限定符出现在范围表达式之后，故应用于整个范围表达式</p>
</blockquote>
<h4 id="非贪婪限定符实现"><a href="#非贪婪限定符实现" class="headerlink" title="非贪婪限定符实现"></a>非贪婪限定符实现</h4><p><code>*</code>和<code>+</code>限定符都是贪婪的，即会尽可能多的匹配文字。若<strong><em>在其后加上?就会实现非贪婪或最小匹配</em></strong>。</p>
<p>如表达式<code>&lt;p&gt;Hello World&lt;p&gt;</code></p>
<ul>
<li>使用<code>/&lt;.*&gt;/</code>匹配，则匹配到的内容为整个表达式<code>&lt;p&gt;Hello World&lt;p&gt;</code></li>
<li>使用<code>/&lt;.*?&gt;/</code>匹配，则只匹配到<code>&lt;p&gt;</code></li>
</ul>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符将正则表达式固定到某位置，让其出现在行首行尾或某单词开头、内部、结尾。用来描述字符串或单词的边界。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串中的开始位置，即匹配一行文本开始处的文本。若放在方括号表达式中使用，表示不接受该方括号表达式中的字符集合</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾，即匹配一行文本结束处的文本。若设置了<code>RegExp</code>对象的<code>Multiline</code>属性，则也匹配<code>\n</code>和 <code>\r</code></td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置。如<code>/\bCha/</code>匹配单词Chapter开头的三个字符。<code>/ter\b/</code>匹配单词Chapter结尾的三个字符</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配，如<code>/\Bapt/</code>匹配Chapter中间的apt，但不匹配aptitude开头的apt，因为此apt出现在单词的边界</td>
</tr>
</tbody></table>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p><code>()</code>：可以将选择项括起来，但其相关的匹配会被缓存，可以使用<code>?:</code>放在第一个选项消除此缓存的作用<br><code>|</code>：分割相邻的选择项。</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>反向引用提供查找文本中两个相同的相邻单词的匹配项的能力。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;Is is the cost of of gasoline going up up&quot;;</span><br><span class="line">var patt1 &#x3D; &#x2F;\b([a-z]+) \1\b&#x2F;ig;</span><br><span class="line">document.write(str.match(patt1));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>\b([a-z]+)</code>:匹配一个或多个字母</li>
<li><code>\1\b</code>:引用第一个子匹配项，即单词的第二个匹配项正好由第一个子匹配项匹配。</li>
<li>引用单词边界符确保只检测整个单词</li>
<li><code>i</code>:忽略大小写</li>
<li><code>g</code>:指定将该表达式应用到输入字符串能够查找到的尽可能多的匹配</li>
</ul>
<p>还可以将url分解为其组件，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;http:&#x2F;&#x2F;www.runoob.com:80&#x2F;html&#x2F;html-tutorial.html&quot;;</span><br><span class="line">var patt1 &#x3D; &#x2F;(\w+):\&#x2F;\&#x2F;([^&#x2F;:]+)(:\d*)?([^# ]*)&#x2F;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(\w+)</code>：<strong>\w等价于[a-zA-Z0-9_]，匹配下划线、所有字母和数字。</strong>该表达式表示匹配url的协议部分，即http。</li>
<li><code>:\/\/</code>：即http后的://</li>
<li><code>([^/:])</code>：匹配非<code>:</code>和<code>/</code>后的一个或多个字符，即url地址部分。</li>
<li><code>(:\d*)?</code>：<strong>\d等价于[0-9]，表示匹配所有的数字</strong>。该表达式表示匹配以:开头的0个或多个数字，即url端口号部分。<code>?</code>表示该端口号部分只匹配0次或1次</li>
<li><code>([^# ]*)</code>：表示匹配非<code>#</code>或<code>空格</code>字符的任何字符序列，即匹配url的指定路径和页信息。</li>
</ul>
<p>对正则表达式模式两边添加()会将相关匹配存储到一个临时缓冲区中，所捕获到的每个子匹配都按在正则表达式模式中从左到右出现的顺序存储，从1开始，最多存储99个捕获的子表达式。<br>可以使用非捕获元字符来重写捕获，忽略对相关匹配的保存。</p>
<h4 id="非捕获元"><a href="#非捕获元" class="headerlink" title="非捕获元"></a>非捕获元</h4><p><code>?:</code>：消除圆括号相关匹配缓存的副作用<br><code>?=</code>：正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来搜索字符串。<br><code>?!</code>：负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>正则表达式相同优先级的从左到右计算，不同优先级的先高后低。</p>
<p>下表表示优先级由高至低：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(),(?:),(?=),[]</td>
<td>圆括号和方括号</td>
</tr>
<tr>
<td>*,+,?,{n},{n,},{n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^,$,以开头的\元字符、字符</td>
<td>定位符和序列</td>
</tr>
<tr>
<td>｜</td>
<td>替换、或操作</td>
</tr>
</tbody></table>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><h3 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h3><p>模式是正则表达式最基本的元素，是一组描述字符串特征的字符。</p>
<p><code>^the</code>: 匹配以the开头的字符串。如匹配<code>the book is over there</code>，不匹配<code>get the book</code>。</p>
<p><code>book$</code>: 匹配以book结尾的字符串。如匹配<code>there is a book</code>，不匹配<code>the book is on the table</code>。</p>
<p><code>^book$</code>: 精准匹配book，只匹配字符串<code>book</code>。</p>
<p><code>book</code>: 与任何包含book的字符串匹配。</p>
<p>若需要匹配转义字符，则需要以<code>\</code>开头，如<code>^\t</code>，匹配以制表符开头的字符串。</p>
<h3 id="字符簇"><a href="#字符簇" class="headerlink" title="字符簇"></a>字符簇</h3><p>字符簇一组字符的集合。用方括号<code>[]</code>扩起来。如<code>[AaEeIiOoUu]</code>匹配<strong>一个元音字符</strong>。</p>
<p>用<code>-</code>连接可表示<strong>一个字符</strong>的范围。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[a-z]：所有小写字母</span><br><span class="line">[A-Z]：所有大写字母</span><br><span class="line">[a-zA-Z]：所有字母</span><br><span class="line">[0-9]：所有数字</span><br></pre></td></tr></table></figure>

<p>方括号内使用<code>^</code>表示非。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[^0-9]：除0-9所有字符</span><br><span class="line">[^a-z]：除a-z所有字符</span><br></pre></td></tr></table></figure>

<p>特殊字符<code>.</code>表示出了新行之外的所有字符。</p>
<h3 id="重复出现"><a href="#重复出现" class="headerlink" title="重复出现"></a>重复出现</h3><p>使用<code>{}</code>确定重复出现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;n&#125;：出现n次</span><br><span class="line">&#123;n,&#125;：出现至少n次</span><br><span class="line">&#123;n,m&#125;：至少出现n次但不超过m次</span><br><span class="line">?：相当于&#123;0,1&#125;，出现0次或1次</span><br><span class="line">+：&#123;1,&#125;，至少出现1次</span><br><span class="line">*：&#123;0,&#125;，出现0次或多次</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript正则表达式RegExp对象"><a href="#JavaScript正则表达式RegExp对象" class="headerlink" title="JavaScript正则表达式RegExp对象"></a>JavaScript正则表达式RegExp对象</h2><p>RefExp是JavaScript的正则表达式对象。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var patt &#x3D; new RegExp(pattern,modifiers);</span><br><span class="line"></span><br><span class="line">var patt &#x3D; &#x2F;pattern&#x2F;modifiers;</span><br></pre></td></tr></table></figure>

<ul>
<li>patterm：正则表达式模式</li>
<li>modifiers：正则表达式修饰符<ul>
<li>i：不区分大小写</li>
<li>g：执行全文搜索</li>
</ul>
</li>
</ul>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var patt &#x3D; new RegExp(&quot;^[abc]&quot;);</span><br><span class="line"></span><br><span class="line">var patt &#x3D; &#x2F;is&#x2F;g;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>test()：搜索字符串指定的值，根据结果返回<code>true</code>或<code>false</code>。</p>
<p>exec()：检索字符中指定值。找到返回该值，未找到返回null。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB安装手册</title>
    <url>/post/2734088481.html</url>
    <content><![CDATA[<p>在学习Node.js的过程中需要使用Mongoose，故安装MongeDB进行使用。但过程中踩了不少坑。以下安装步骤是多次踩坑后可以正常运行的版本。</p>
<p>安装环境：Mac OS 10.15.3</p>
<h2 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h2><h3 id="方法1-使用官网安装包"><a href="#方法1-使用官网安装包" class="headerlink" title="方法1:使用官网安装包"></a>方法1:使用官网安装包</h3><p><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">官网安装包下载链接</a></p>
<a id="more"></a>
<p>选择对应的操作系统和包格式点击下载即可。</p>
<blockquote>
<p>此方法个人在下载时一直报错，可能是因为浏览器中安装的下载插件问题，故最后未采用此方式下载。</p>
</blockquote>
<h3 id="方法2-获取官网下载链接使用命令行下载"><a href="#方法2-获取官网下载链接使用命令行下载" class="headerlink" title="方法2:获取官网下载链接使用命令行下载"></a>方法2:获取官网下载链接使用命令行下载</h3><p>在官网下载页面复制下载链接：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdealyx2fnj317s0o6acd.jpg" alt="复制官网下载链接"></p>
<ol>
<li><p>在iterm中使用命令行下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% sudo curl -O https:&#x2F;&#x2F;fastdl.mongodb.org&#x2F;osx&#x2F;mongodb-macos-x86_64-4.2.5.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压后，将文件夹重命名为mongodb（<strong><em>重要！！！</em></strong>）</p>
</li>
</ol>
<blockquote>
<p>此方法下载成功且无任何报错</p>
</blockquote>
<h3 id="方法3-使用brew下载"><a href="#方法3-使用brew下载" class="headerlink" title="方法3:使用brew下载"></a>方法3:使用brew下载</h3><blockquote>
<p>确保自己的开发环境中已安装brew</p>
<p>brew安装教程<a href="https://zhuanlan.zhihu.com/p/99104545" target="_blank" rel="noopener">点击此进行跳转</a></p>
</blockquote>
<p>在iterm中使用命令行(<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">以下步骤参考于MongoDB官方下载文档</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% brew tap mongodb&#x2F;brew</span><br><span class="line"></span><br><span class="line">Macbook% brew install mongodb-community@4.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一次使用brew下载安装包没有没有按官网的步骤下载，参考了其他大佬的教程，最终没有安装成功，出现了很多奇怪的问题，可能是版本不太一样。<br>后来使用此方法进行下载，但下载后安装遇到了一些问题，初步怀疑是第一次用brew安装后的一些操作没有卸载整理完，故安装失败。</p>
</blockquote>
<h2 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol>
<li><p>使用命令行打开环境变量文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% open -e .bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>将安装MongoDB的目录下bin的地址添加到环境变量中（<strong><em>此步骤一定要配置对！！重要！！！否则后来可能会无法打开Mongo</em></strong>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin:$PATH</span><br><span class="line">&#x2F;&#x2F;保存文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>使配置生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% source .bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证是否已安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% mongod -version</span><br></pre></td></tr></table></figure>

<p> 出现以下信息，则说明安装成功：</p>
<p> <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeb7a9ou9j30ni07yq61.jpg" alt="配置成功信息"></p>
</li>
</ol>
<h3 id="创建log和data目录"><a href="#创建log和data目录" class="headerlink" title="创建log和data目录"></a>创建log和data目录</h3><blockquote>
<p>很多教程都表示要使用<code>mkdir -p /data/db</code>创建目录，但使用各个方法都无法创建成功，故以下自己创建目录</p>
</blockquote>
<ol>
<li><p>在MongoDB的安装目录下新建log目录和data目录（本人安装目录为/usr/local/mongodb，该目录就是之前解压后重命名的文件夹）<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdebdsqowzj30nm03640e.jpg" alt="创建目录"></p>
</li>
<li><p>进入/usr/local/etc目录打开mongod.conf文件，修改log路径和data路径为步骤1中创建的目录地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  path: &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;mongo.log</span><br><span class="line">  logAppend: true</span><br><span class="line">storage:</span><br><span class="line">  dbPath: &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data</span><br><span class="line">net:</span><br><span class="line">  bindIp: 127.0.0.1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有的教程直接进行第三步运行，但我直接运行第三步后配置并没有改变，出现了一些问题，故还是增加了第二步</p>
</blockquote>
</li>
<li><p>运行MongoDB服务</p>
<blockquote>
<p>MongoDB默认数据保存的地址为/data/db，但我一直没创建成功，故修改了地址后，在启动服务时指定dbpath的位置。由于做了第二步也可不指定，以防万一。</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% mongod --dbpath data --logpath log&#x2F;mongod.log --logappend</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;--logappend:后台运行</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动后，当前终端不要关闭。</p>
</blockquote>
<p> <strong>遇到的问题：</strong></p>
<p> 在运行MongoDB服务时，有以下报错：</p>
<blockquote>
<p>NETWORK  [initandlisten] Failed to unlink socket file /tmp/mongodb-27017.sock Permission denied</p>
</blockquote>
<ul>
<li><p>原因查询:</p>
<p>  在mongodb目录下使用命令<code>ls -lat /tmp/mongodb-27017.sock</code>查看权限，显示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MacBook% srwx------  1 root  wheel  0  4  1 12:27 &#x2F;tmp&#x2F;mongodb-27017.sock</span><br></pre></td></tr></table></figure></li>
<li><p>解决办法：使用命令<code>sudo rm /tmp/mongodb-27017.sock</code>删除该文件即可。</p>
</li>
</ul>
</li>
<li><p>启动数据库<br> 新打开一个终端，输入mongo连接数据库。<br> 若出现<code>command not found</code>错误，直接使用命令<code>source .bash_profile</code>再次使环境变量生效，再使用mongo连接即可解决。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>MongoDB</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(5)-Express基础</title>
    <url>/post/1628986583.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Express 是一个简洁灵活的 Node.js Web 应用框架，其特点为：</p>
<ul>
<li><p>可以设置中间件来响应 HTTP 请求</p>
</li>
<li><p>定义了路由表用于执行不同的 HTTP 请求动作</p>
</li>
<li><p>可以通过向模板传递参数来动态渲染 HTML 页面</p>
<a id="more"></a>

</li>
</ul>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>请求发送到服务器，服务端在监听处理请求时的过程很复杂，若将这些负责的业务拆分成子部分，则每个子部份就是一个中间件，类似一个流水线工作流程。</p>
<blockquote>
<p>function(req, res, next)</p>
</blockquote>
<blockquote>
<p>若符合 function 中的条件，则执行对应的 end()函数结束此次路由，若不符合条件，则执行 next()函数进入 function2</p>
</blockquote>
<blockquote>
<p>类同与异步的 promise.then().then()</p>
</blockquote>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图参考 easy 老师方糖全站课堂内容：</a></p>
<p><img src="https://i.loli.net/2020/03/16/amscOKBu1qZRNSD.jpg" alt="中间件"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var express &#x3D; require(&#39;express&#39;);</span><br><span class="line"> var app &#x3D; express();</span><br><span class="line"></span><br><span class="line"> app.get(&#39;&#x2F;&#39;, function(req, res, next) &#123;&#x2F;&#x2F;function(req, res, next)为中间件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前中间件函数没有结束请求&#x2F;响应循环，调用next(), 将控制权传递给下一个中间件函数继续往下处理，否则页面到此会被挂起</span><br><span class="line">    next();&#x2F;&#x2F;有next()才会往下进行下一个中间件，否则一直被挂起</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;next()代表的下一个中间件</span><br><span class="line">app.get(&#39;&#x2F;end&#39;, function(req, res) &#123;</span><br><span class="line">    &#x2F;&#x2F;此时没有next(),故到此结束</span><br><span class="line">    res.send(&#39;-----END-----&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h3 id="错误中间件"><a href="#错误中间件" class="headerlink" title="错误中间件"></a>错误中间件</h3><blockquote>
<p>function(err, req, res, next)</p>
</blockquote>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图参考 easy 老师方糖全站课堂内容：</a></p>
<p><img src="https://i.loli.net/2020/03/16/AKTki9687StbFu5.jpg" alt="错误中间件"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(function(err, req, res, next) &#123;&#x2F;&#x2F;function(err, req, res, next)为错误处理中间件</span><br><span class="line">  console.error(err.stack);</span><br><span class="line">  res.status(500).send(&#39;Something broke!&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;另一种写法</span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">  next(new Error(&quot;XXX error&quot;));&#x2F;&#x2F;next()将请求交给新建的错误处理中间件。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="单文件-Express-app"><a href="#单文件-Express-app" class="headerlink" title="单文件 Express app"></a>单文件 Express app</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line">const app &#x3D; express()</span><br><span class="line">const port &#x3D; 3000</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; res.send(&#39;Hello World!&#39;))</span><br><span class="line"></span><br><span class="line">app.listen(port, () &#x3D;&gt; console.log(&#96;Example app listening on port &#96;+ port));</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/16/Of4DapRuvUVq5mE.jpg" alt="output"></p>
<h2 id="使用-Express-generate-生成-Express-项目"><a href="#使用-Express-generate-生成-Express-项目" class="headerlink" title="使用 Express generate 生成 Express 项目"></a>使用 Express generate 生成 Express 项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Node.js v8.2.0直接使用npx命令使用生成器</span><br><span class="line">$ npx express-generator</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;之前版本先安装生成器包</span><br><span class="line">$ npm install -g express-generator</span><br><span class="line">$ express</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成项目myapp</span><br><span class="line">&#x2F;&#x2F;将view引擎设置成pug，jade已不被支持</span><br><span class="line">$ express --view&#x3D;pug myapp</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行</span><br><span class="line">&#x2F;&#x2F;安装依赖</span><br><span class="line">$ cd myapp</span><br><span class="line">$ npm install</span><br><span class="line">&#x2F;&#x2F;运行</span><br><span class="line">$ set DEBUG&#x3D;myapp:*</span><br><span class="line">$ npm start</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打开页面http:&#x2F;&#x2F;localhost:3000&#x2F;查看结果</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/16/BNmsdbH4D3yvjqU.jpg" alt="express"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(4)-模块及文件系统</title>
    <url>/post/3550571859.html</url>
    <content><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>模块是 Node.js 的基本组成部分，文件和模块一一对应，即一个 Node.js 文件就是一个模块。</p>
<blockquote>
<p><code>exports</code>：模块公开的接口，即封装模块的关键字</p>
</blockquote>
<blockquote>
<p><code>require</code>：从外部获取一个模块的接口，即调用模块的关键字</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入当前目录下的hello文件</span><br><span class="line">var hello &#x3D; require(&quot;.&#x2F;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;使用exports将world作为模块访问的接口</span><br><span class="line">exports.world&#x3D;function()&#123;</span><br><span class="line">    console.log(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <a id="more"></a>
<h3 id="require-调用模块机制"><a href="#require-调用模块机制" class="headerlink" title="require 调用模块机制"></a>require 调用模块机制</h3><p><img src="https://s1.ax1x.com/2020/03/16/8GZTTx.jpg" alt="require"></p>
<blockquote>
<p>其中，</p>
</blockquote>
<blockquote>
<p>原生模块：Node.js 自带的模块，如 http、fs 等。</p>
</blockquote>
<blockquote>
<p>文件模块：某目录下的文件，使用前必须先使用<code>exports</code>封装模块</p>
</blockquote>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br></pre></td></tr></table></figure>

<p>文件模块中所有方法均有异步同步两种，异步方法的最后一个参数为回掉函数，第一个参数包含了错误信息。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步读取</span><br><span class="line">fs.readFile(&#39;fs.txt&#39;, function (err, data) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;异步: &quot; + data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步读取</span><br><span class="line">var data &#x3D; fs.readFileSync(&#39;fs.txt&#39;);</span><br><span class="line">console.log(&quot;同步: &quot; + data.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;------END------&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/16/8Gmoi6.jpg" alt="output"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(3)-回调与事件</title>
    <url>/post/407120575.html</url>
    <content><![CDATA[<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>回调是 Node.js 异步编程的直接体现。回调函数在完成任务后就会被调用。Node 的所有 API 都支持回调函数。回调函数是一种非阻塞的方式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1(value,callback1,callback2,...)&#123;&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h3><blockquote>
<p>进程：系统中正在运行的一个应用程序，是资源分配的最小单位。</p>
</blockquote>
<blockquote>
<p>线程：系统分配处理器时间资源的最小单位，程序执行的最小单位。</p>
</blockquote>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><blockquote>
<p>1.进程包含一个或多个线程。</p>
</blockquote>
<blockquote>
<p>2.进程=线程+内存+文件/网络句柄</p>
</blockquote>
<blockquote>
<p>3.线程=栈+程序计数器+线程独立内存 TLS</p>
</blockquote>
<blockquote>
<p>4.一个程序至少有一个进程，一个进程至少有一个线程，其第一个线程即为此进程的主线程。</p>
</blockquote>
<blockquote>
<p>5.一个线程可以创建和撤销另一个线程，同一个进程的多个线程可以并发执行。</p>
</blockquote>
<h3 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h3><blockquote>
<p><strong>同步、异步关注应用层，阻塞、非阻塞更多针对进程和线程而谈</strong></p>
</blockquote>
<blockquote>
<p>同步：发送方发送请求之后，需要等接收方发回响应后才接着发。</p>
</blockquote>
<blockquote>
<p>异步：发送方发送请求后，不等待接收方响应请求，继续发送下个请求。</p>
</blockquote>
<blockquote>
<p>阻塞调用：调用结果返回之前，当前线程会被挂起，调用线程在获得结果后才会返回数据。</p>
</blockquote>
<blockquote>
<p>非阻塞调用：调用结果返回之前，当前线程也不会被挂起，而是立刻返回执行下一个调用。</p>
</blockquote>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>进程通信方面，同步、异步和阻塞、非阻塞基本是同义词，发送方阻塞/非阻塞与接收方阻塞/非阻塞互不影响。</p>
</li>
<li><p>I/O 系统调用层面，非阻塞 I/O 系统调用和异步 IO 系统调用都不会阻塞进程，但非阻塞 I/O 系统调用 read()立即返回的是可以立即拿到的数据，完整或不完整的结果或空值都可；而异步 I/O 系统调用 read()返回的结果必须是完整的。</p>
</li>
<li><p>非阻塞 I/O 系统调用可用来实现线程级别的 I/O 并发，与通过多线程实现的 I/O 并发相比，可减少内存消耗及进程切换的开销。</p>
</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote>
<p>Node.js 是单进程单线程的应用程序，但通过 V8 引擎提供的异步执行回调接口，可以处理大量的并发。</p>
</blockquote>
<blockquote>
<p>Node.js 所有的事件机制，都通过观察者模式实现。其单线程类似进入一个<code>while(true)</code>的事件循环，知道没有事件观察者退出，每个异步事件都生成一个事件观察者，若有事件发生就调用该回调函数。</p>
</blockquote>
<blockquote>
<p>观察者模式：其定义了对象的一对多依赖，当一个对象改变，所有依赖它的观察者都会收到通知并自动更新。</p>
</blockquote>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Node.js 使用事件驱动模型。当 web server 收到请求，就将他关闭放到任务队列中，然后服务下一个 web 请求，通过先进先出的原则，任务队列中的事件会被放到调用栈上进行处理（若为非阻塞 I/O 操作，则直接调用栈执行完毕，若为文件或其他数据库等需长时间的操作，则会被放入 Libuv 处理，当前任务挂起，处理下一个任务），当此请求处理完成，它会将结果重新放回任务队列，当到达队列开头，此处理结果被返回给用户（<strong>非阻塞 I/O</strong>或<strong>事件驱动 I/O</strong>）</p>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图 Node.js 工作流程源自 easy 老师方糖全站课堂（超值！！买买买！！！）：</a></p>
<p><a href="https://imgchr.com/i/83rcH1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/15/83rcH1.md.jpg" alt="node.js"></a></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li>事件驱动程序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var events &#x3D; require(&quot;events&quot;);</span><br><span class="line">var eventEmitter &#x3D; new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">var connectHandler &#x3D; function connected() &#123;</span><br><span class="line">  console.log(&quot;Connect Success!!&quot;);</span><br><span class="line">  &#x2F;&#x2F;触发data_received事件</span><br><span class="line">  eventEmitter.emit(&quot;data_received&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;绑定事件处理</span><br><span class="line">eventEmitter.on(&quot;connection&quot;, connectHandler);</span><br><span class="line">&#x2F;&#x2F;绑定data_received事件</span><br><span class="line">eventEmitter.on(&quot;data_received&quot;, function() &#123;</span><br><span class="line">  console.log(&quot;data received success!!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;触发connection事件</span><br><span class="line">eventEmitter.emit(&quot;connection&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;------END------&quot;);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/83ryu9.jpg" alt="event"></p>
<ol start="2">
<li>文件读入</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&quot;fs.txt&quot;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&quot;------ERROR------&quot;);</span><br><span class="line">    console.log(err.stack);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&quot;------DATA------&quot;);</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;------END------&quot;);</span><br></pre></td></tr></table></figure>

<p>运行成功：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/83rrjJ.jpg" alt="fs1"></p>
<p>运行失败：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/83r6BR.jpg" alt="fs2"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(2)-REPL(交互式解释器)</title>
    <url>/post/2853246140.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>REPL 表示一个电脑环境类似 Windows 的 cmd 或 powershell 终端，Unix/Linux 的 shell。可进行一些读取、执行、打印、循环操作。</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$node    &#x2F;&#x2F;进入node REPL</span><br><span class="line">&gt; 1+6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; x&#x3D;100</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">&gt; var y&#x3D;50</span><br><span class="line">undifined</span><br><span class="line"></span><br><span class="line">&gt; console.log(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<h3 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var x&#x3D;0;</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&gt; while(x&lt;6)&#123;</span><br><span class="line">... x++;        &#x2F;&#x2F;...为换行，node会自动检测是否为连续的表达式</span><br><span class="line">... console.log(&quot;x:&quot;+x);</span><br><span class="line">...&#125;</span><br><span class="line">x:1</span><br><span class="line">x:2</span><br><span class="line">x:3</span><br><span class="line">x:4</span><br><span class="line">x:5</span><br><span class="line">x:6</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<h3 id="下划线变量"><a href="#下划线变量" class="headerlink" title="下划线变量"></a>下划线变量</h3><blockquote>
<p>node 中下划线_可代表上一个表达式的结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var x&#x3D;5;</span><br><span class="line">undefined</span><br><span class="line">&gt; var y&#x3D;10;</span><br><span class="line">undefined</span><br><span class="line">&gt; x+y</span><br><span class="line">15</span><br><span class="line">&gt; var sum&#x3D;_;</span><br><span class="line">undefined</span><br><span class="line">&gt; console.log(&quot;sum:&quot;+sum);</span><br><span class="line">sum:15</span><br></pre></td></tr></table></figure>

<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+c: 退出当前表达式</span><br><span class="line"></span><br><span class="line">ctrl+c(两次)&#x2F;ctrl+d：退出node REPL</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(1)-创建应用</title>
    <url>/post/2478022751.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Node.js 为运行在服务端的 JavaScript。它是一个基于 Chrome JavaScript 运行时建立的平台，也是一个事件驱动 I/O 服务端的 JavaScript，基于 Google 的 V8 引擎。</p>
<a id="more"></a>

<p>Node.js 应用由以下部分组成：</p>
<ul>
<li><p>引入 required 模块：使用 require 指令载入 Node.js 模块</p>
</li>
<li><p>创建服务器：服务器监听客户端请求。</p>
</li>
<li><p>接收、响应请求</p>
</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="引入-required-模块"><a href="#引入-required-模块" class="headerlink" title="引入 required 模块"></a>引入 required 模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const server &#x3D; http.createServer();&#x2F;&#x2F;创建服务器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给服务器绑定request事件，并使用匿名函数作为其回调函数</span><br><span class="line">server.on(&quot;request&quot;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(req.url); &#x2F;&#x2F;输出请求的url地址</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;通过normalize将URL规范成路径</span><br><span class="line">  &#x2F;&#x2F;通过join将他和当前目录拼接起来</span><br><span class="line">  &#x2F;&#x2F;__dirname代表当前文件所在目录</span><br><span class="line">  const doc_path &#x3D; path.join(</span><br><span class="line">    __dirname,</span><br><span class="line">    &quot;document_root&quot;,</span><br><span class="line">    path.normalize(req.url)</span><br><span class="line">  );</span><br><span class="line">  console.log(doc_path);</span><br><span class="line"></span><br><span class="line">  const ext &#x3D; path.extname(req.url); &#x2F;&#x2F;获取扩展名</span><br><span class="line">  let mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;;</span><br><span class="line">  switch (</span><br><span class="line">    ext &#x2F;&#x2F;指定对应的MIME信息</span><br><span class="line">  ) &#123;</span><br><span class="line">    case &quot;.html&quot;:</span><br><span class="line">    case &quot;.htm&quot;:</span><br><span class="line">      mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;;</span><br><span class="line">      break;</span><br><span class="line">    case &quot;.css&quot;:</span><br><span class="line">      mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;text&#x2F;css&quot; &#125;;</span><br><span class="line">      break;</span><br><span class="line">    case &quot;.ico&quot;:</span><br><span class="line">      mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;image&#x2F;x-icon&quot; &#125;;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;使用existSync判断文件是否存在</span><br><span class="line">  &#x2F;&#x2F;使用extname去掉url目录，以防路径为目录，但目录里没有文件</span><br><span class="line">  if (path.extname(req.url) !&#x3D; &quot;&quot; &amp;&amp; fs.existsSync(doc_path)) &#123;</span><br><span class="line">    &#x2F;&#x2F;Response里边会包含MIME信息以告诉浏览器这是个什么格式的文件</span><br><span class="line">    res.writeHead(200, mime); &#x2F;&#x2F;输出状态码</span><br><span class="line">    content &#x3D; fs.readFileSync(doc_path); &#x2F;&#x2F;通过readFileSync读取文件内容</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    res.writeHead(404, mime);</span><br><span class="line">    content &#x3D; &quot;文件不存在&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.write(content); &#x2F;&#x2F;将内容写到request响应里去</span><br><span class="line"></span><br><span class="line">  res.end();&#x2F;&#x2F;发送响应数据</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(8080);&#x2F;&#x2F;监听8080端口</span><br></pre></td></tr></table></figure>

<h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><p><img src="https://s2.ax1x.com/2020/03/08/3xIOiT.jpg" alt="测试结果"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>JavaScript</tag>
        <tag>Node.js</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>纯HTML/CSS/JS实现九宫格拼图游戏</title>
    <url>/post/1512225577.html</url>
    <content><![CDATA[<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://i.loli.net/2020/02/21/MBsWOjbg8ED7wLd.gif" alt="showall.gif"></p>
<p>github地址：<a href="https://github.com/ChangeZ24/game-gridpuzzle" target="_blank" rel="noopener">https://github.com/ChangeZ24/game-gridpuzzle</a></p>
<p>在线试玩地址： <a href="http://awesolynn.me/game-gridpuzzle/gridpuzzle.html">http://awesolynn.me/game-gridpuzzle/gridpuzzle.html</a></p>
<a id="more"></a>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>整个九宫格看作一个 div，分为 9 份，位置号为 1~9</p>
</li>
<li><p>九宫格内 8 个活动格看作 8 个 div，格号为 1~8，第 9 格为空格，记为 0</p>
</li>
</ul>
<h3 id="乱序排列九宫格内-8-个活动格"><a href="#乱序排列九宫格内-8-个活动格" class="headerlink" title="乱序排列九宫格内 8 个活动格"></a>乱序排列九宫格内 8 个活动格</h3><blockquote>
<p>算法：</p>
</blockquote>
<blockquote>
<p>1、从第 9 格空格开始，选取随机位置号为 1~9 的某格进行两两替换</p>
</blockquote>
<blockquote>
<p>2、接下来，第 8 格，即格号为 8（初始后格号为 8 的格同在位置 8），则选取随机位置号为 1~8 的格进行两两替换</p>
</blockquote>
<blockquote>
<p>以此类推</p>
</blockquote>
<h3 id="活动格鼠标点击进行滑动"><a href="#活动格鼠标点击进行滑动" class="headerlink" title="活动格鼠标点击进行滑动"></a>活动格鼠标点击进行滑动</h3><blockquote>
<p>算法：</p>
</blockquote>
<blockquote>
<p>1、初始时，使用数组记录每个位置可移动的位置号，如位置 1，可移动到位置 2 和位置 4</p>
</blockquote>
<blockquote>
<p>2、使用数组记录每个位置格的左上角点的 x、y 值，在 css 中即为 left、top 值，即每个格从位置 1 移动到位置 2，改变的位移值。</p>
</blockquote>
<blockquote>
<p>3、当鼠标进行点击某格时，若其可移动的格内有空格，则其位移变为空格的 x、y 值，完成移动的动作。</p>
</blockquote>
<h3 id="时间记录"><a href="#时间记录" class="headerlink" title="时间记录"></a>时间记录</h3><blockquote>
<p>时间记录，同样使用<code>setInterval()</code>函数按 1000ms 的间隔进行实时计算。</p>
</blockquote>
<h3 id="关卡设置"><a href="#关卡设置" class="headerlink" title="关卡设置"></a>关卡设置</h3><blockquote>
<p>本游戏共设置 3 关，当每关成功完成拼图，会出现提示<code>play more</code>表示进入下一关</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/BYJ6b4WPpdKz8j9.gif" alt="next.gif"></p>
<blockquote>
<p>当位于最后一关时，成功后只会提示<code>congratulations</code>，表示游戏结束。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/eXKdZgihUxIpHzy.gif" alt="suss.gif"></p>
<h3 id="暂停、重玩机制"><a href="#暂停、重玩机制" class="headerlink" title="暂停、重玩机制"></a>暂停、重玩机制</h3><blockquote>
<p>当点击开始游戏后，开始游戏的按钮会自动变为暂停游戏</p>
</blockquote>
<blockquote>
<p>点击暂停游戏后，时间暂停，各活动格也无法点击，只有点击开始游戏继续玩或点击重新开始，重启此关</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/5gc2CEVIyBKTMpl.gif" alt="pause.gif"></p>
<blockquote>
<p>点击重新开始，会重新启动所在的关卡，重排整个图。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/1r2jPMApN3wGTgo.gif" alt="reset.gif"></p>
<h2 id="疑惑-学习点"><a href="#疑惑-学习点" class="headerlink" title="疑惑/学习点"></a>疑惑/学习点</h2><h3 id="对-CSS-中-position-的理解"><a href="#对-CSS-中-position-的理解" class="headerlink" title="对 CSS 中 position 的理解"></a>对 CSS 中 position 的理解</h3><h4 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h4><p>position：用于层的绝对定位，即让一个层位于一个层内具体什么位置</p>
<p>参数：</p>
<ul>
<li><p>static：默认。按页面文档流放置，忽略 top、bottom、left、right 设置的值</p>
</li>
<li><p>relative：相对位置。对象不可层叠，可通过 top、bottom、left、right 设置在文档流中的位置</p>
</li>
<li><p>absolute：绝对位置。对象可通过 z-index 设置层叠，对象被从文档流拖出，根据 top、bottom、left、right 等属性进行绝对定位。</p>
</li>
<li><p>fixed：固定位置。通过 top、bottom、left、right 进行定位，页面滚动，对象仍存在于固定的位置不变。</p>
</li>
</ul>
<h4 id="对相对、绝对位置的理解"><a href="#对相对、绝对位置的理解" class="headerlink" title="对相对、绝对位置的理解"></a>对相对、绝对位置的理解</h4><ol>
<li><p>当子级使用<code>position: absolute;</code>时。其父级通常定义为<code>position: relative;</code></p>
<p>父级使用<code>position: relative;</code>相对位置时，最好同时定义其<code>width</code>和<code>height</code>。</p>
<p>此时，子级使用<code>position: absolute;</code>，设置的<code>top/bottom、left/right</code>即为距离父级上/下侧、左/右侧的距离，有点类似外边距。</p>
<blockquote>
<p><strong>注意</strong>：此时<code>top/bottom</code>二选一，<code>left/right</code>二选一！</p>
</blockquote>
</li>
<li><p>当子级使用<code>position: absolute;</code>但父级没有设置<code>position: relative;</code>时，无论子级处于 div 哪一层，都会被拖出文档流，以 <code>body</code>为父级，所设置的所有 <code>top/bottom、left/right</code>都会为距离<code>body</code>的上/下侧、左/右侧的距离，不受其父级控制。</p>
</li>
</ol>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol>
<li><p>实验楼拼图实现教学</p>
<p><a href="https://www.shiyanlou.com/courses/161" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/161</a></p>
</li>
<li><p>CSS 中 position 相关讲解</p>
<p><a href="http://www.divcss5.com/rumen/r403.shtml" target="_blank" rel="noopener">http://www.divcss5.com/rumen/r403.shtml</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>Grid Puzzle</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo建站指南</title>
    <url>/post/1566052460.html</url>
    <content><![CDATA[<h2 id="下载安装必要工具"><a href="#下载安装必要工具" class="headerlink" title="下载安装必要工具"></a>下载安装必要工具</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><blockquote>
<p>搭建网站需要进行版本管理，故下载 git 进行使用。</p>
</blockquote>
<blockquote>
<p>下载网址： <a href="https://www.git-scm.com/download" target="_blank" rel="noopener">https://www.git-scm.com/download</a></p>
</blockquote>
<blockquote>
<p>使用说明可参考 git 官方文档：<a href="https://www.git-scm.com/doc" target="_blank" rel="noopener">https://www.git-scm.com/doc</a></p>
</blockquote>
<ul>
<li>安装时，一键 next 即可<a id="more"></a></li>
<li>安装后，在文件夹内或桌面点击鼠标右键，若出现如下工具，则证明安装成功:</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/iyzHFrNle78sTZn.jpg" alt="git.jpg"></p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><blockquote>
<p>Hexo 是基于 Node.js 编写的，所以需要安装一下 Node.js 和里面的 npm 工具。</p>
</blockquote>
<blockquote>
<p>网址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p>
</blockquote>
<h4 id="安装后检查是否安装成功"><a href="#安装后检查是否安装成功" class="headerlink" title="安装后检查是否安装成功"></a>安装后检查是否安装成功</h4><ul>
<li><code>win+R</code> 打开运行，输入<code>cmd</code>：</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/rn3PRI9HsfzwM4h.jpg" alt="cmd.jpg"></p>
<ul>
<li>检查 node.js 和 npm 是否安装成功：</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/I2HDLrPgampFnke.jpg" alt="node.jpg"></p>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><blockquote>
<p>hexo 即为此次搭建网站的框架</p>
</blockquote>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li><p>创建一个文件夹，名字任取，作为以后网站所有文件的存储地，即本地仓库</p>
</li>
<li><p>进入文件夹，按住<code>shift</code>键点击鼠标右键，win10 选择“在此处打开 powershell 窗口”，win7 选择“在此处打开命令窗口”</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/xKdosqQEHlnMr4X.jpg" alt="powershell2.jpg"></p>
<ul>
<li><p>输入命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装结束，输入命令检查是否安装成功</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="初始化-hexo"><a href="#初始化-hexo" class="headerlink" title="初始化 hexo"></a>初始化 hexo</h4><ul>
<li><p>初始化 hexo 框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>初始化后一般在博客文件夹会出现以下文件：</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/K8XiTDvh4rexBp5.jpg" alt="folder.jpg"></p>
<ul>
<li><p>在文件夹内安装 npm 相关组件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成页面</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地服务器打开查看页面</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
<li><p>若出现此页面，证明生成页面成功</p>
<p><img src="https://i.loli.net/2020/02/20/8fZiS1Wln3x4Ksj.jpg" alt="pagelocal.jpg"></p>
</li>
<li><p><code>ctrl+C</code>关掉本地</p>
</li>
</ul>
<h2 id="使用-Github-作为服务器部署-hexo-网站"><a href="#使用-Github-作为服务器部署-hexo-网站" class="headerlink" title="使用 Github 作为服务器部署 hexo 网站"></a>使用 Github 作为服务器部署 hexo 网站</h2><h3 id="配置-github"><a href="#配置-github" class="headerlink" title="配置 github"></a>配置 github</h3><ul>
<li><p>若没有 github 账号，则首先需要注册</p>
<p>网址：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
</li>
<li><p>新建仓库，点击页面右上角+，新建仓库 repository</p>
<p><img src="https://i.loli.net/2020/02/21/NVMhiTOzBWPGp9U.jpg" alt="repository.jpg"></p>
</li>
<li><p>填入信息，注意仓库名必须为：<strong>你的 github 用户名.github.io</strong></p>
<p>例如：ChangeZ24.github.io</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5P8P.jpg" alt="github"></p>
</li>
<li><p>在 blog 目录内点击鼠标右键，选择在此处打开 git Bash</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/sgNcERCUeFvb7VD.jpg" alt="gitbash.jpg"></p>
<ul>
<li><p>生成 SSH key</p>
<blockquote>
<p>SSH key 提供了一种与 GitHub 通信的方式，通过这种方式，能够在不输入密码的情况下，将 GitHub 作为自己的 remote 端服务器，进行版本控制</p>
</blockquote>
<p>输入命令生成 SSH key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;github用户名&quot;</span><br><span class="line">git config --global user.email &quot;github登陆邮箱&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以使用此命令检查是否输入正确</span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 SSH key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github登陆邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>创建完成后会在我的电脑 C 盘出现 id_rsa、id_rsa.pub 文件</p>
<p><img src="https://i.loli.net/2020/02/20/2Uu6ZaMjqlENSz4.jpg" alt="id.jpg"></p>
</li>
<li><p>打开 id_rsa.pub 文件，复制里面全部内容（即 key）</p>
</li>
<li><p>打开 github 导入 key</p>
<p><img src="https://i.loli.net/2020/02/21/84Wx7mUcVqRMB3Y.jpg" alt="setting.jpg"></p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5SUA.jpg" alt="3m5SUA.jpg"></p>
<p><img src="https://i.loli.net/2020/02/20/5RXFkjyDr2IH4e9.jpg" alt="createSSH.jpg"></p>
<p>新建时 SSHkey 的 title 可以随便填。</p>
</li>
<li><p>在 git Bash 中输入以下命令检查是否导入成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="将-hexo-部署到-github"><a href="#将-hexo-部署到-github" class="headerlink" title="将 hexo 部署到 github"></a>将 hexo 部署到 github</h3><ul>
<li><p>修改站点的配置文件_config.yml</p>
<blockquote>
<p><strong>注意</strong></p>
</blockquote>
<blockquote>
<p>存储在博客目录文件下的_config.yml 为<strong>站点的配置文件</strong></p>
</blockquote>
<blockquote>
<p>存储在博客目录的/theme/xxx(模板名)/_config.yml 为<strong>模板的配置文件</strong></p>
</blockquote>
<p>修改站点配置文件_config.yml 的 deploy 属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  # 此路径可直接在github仓库复制，如下图所示</span><br><span class="line">  repository:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;github用户名&#x2F;你的github用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>repository 路径可直接在仓库页面复制 http 路径：</p>
<p><img src="https://i.loli.net/2020/02/20/cQmOy5DBiz6eKbl.jpg" alt="githubhttp.jpg"></p>
</li>
<li><p>安装部署 git 的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理部署项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成部署命令可一起使用</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署成功即可在<code>http://github用户名.github.io</code>查看生成的页面</p>
<p><img src="https://i.loli.net/2020/02/20/8fZiS1Wln3x4Ksj.jpg" alt="pagelocal.jpg"></p>
</li>
</ul>
<h2 id="常用的-hexo-命令"><a href="#常用的-hexo-命令" class="headerlink" title="常用的 hexo 命令"></a>常用的 hexo 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目缓存内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br><span class="line"></span><br><span class="line">hexo new page &quot;page名&quot; &#x2F;&#x2F;新建页面</span><br><span class="line">hexo new &quot;文章名&quot; &#x2F;&#x2F;新建文章</span><br></pre></td></tr></table></figure>

<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ul>
<li>在 hexo 官网选择喜欢的模板</li>
</ul>
<p>网址：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<ul>
<li>在 blog 目录下打开命令行或 git Bash 输入命令下载主题</li>
</ul>
<blockquote>
<p>主题下载命令一般在主题页面，或预览页面主题创作人的文章里都有</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Shen-Yu&#x2F;hexo-theme-ayer.git themes&#x2F;ayer</span><br></pre></td></tr></table></figure>

<ul>
<li>修改站点配置文件_config.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: ayer  #在此处修改想要使用的主题名</span><br></pre></td></tr></table></figure>

<ul>
<li>重新生成部署页面即可看到新主题下的网页</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目缓存内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br></pre></td></tr></table></figure>

<h2 id="设置自己的个人域名"><a href="#设置自己的个人域名" class="headerlink" title="设置自己的个人域名"></a>设置自己的个人域名</h2><pre><code>目前生成的页面都是通过github提供的xxx.github.io访问，若想使用自己的个性化域名则需要以下步骤</code></pre><h3 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h3><blockquote>
<p>申请域名有很多网站，国内大多使用<a href="https://wanwang.aliyun.com/?spm=5176.8142029.digitalization.2.e9396d3e46JCc5" target="_blank" rel="noopener">阿里云</a>，不同的域名后缀价格不同，挑选自己喜欢可承受的即可。<br>国外域名可使用<a href="https://sg.godaddy.com/domains/domain-name-search" target="_blank" rel="noopener">godaddy</a>、<a href="https://www.namesilo.com/" target="_blank" rel="noopener">namesilo</a>等购买，国外域名一般不需要备案。</p>
</blockquote>
<h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><p>本人注册的域名时在 namesilo 购买，故以 namesilo 为例：</p>
<ul>
<li><p>登陆 namesilo 在自己的账户页面，点击 Account Domain 后的数字，进入域名管理页面</p>
<p><img src="https://i.loli.net/2020/02/20/ZDBEhn9WfrKbLvQ.jpg" alt="namesilo1.jpg"></p>
</li>
<li><p>选择 option 下的蓝色小人图标，进入解析界面</p>
<p><img src="https://i.loli.net/2020/02/20/p4fmEQvedOkT6MA.jpg" alt="domain.jpg"></p>
</li>
<li><p>将 namesoil 自动生成的所有记录删除，即 sevice 下所有未 parking 状态的记录，一般情况为 3 条 A 记录，1 条 CNAME 记录</p>
</li>
<li><p>添加自己的解析内容</p>
<ul>
<li><p>新建一个 A 记录</p>
<p><img src="https://i.loli.net/2020/02/20/lFyMoJXKYPnswN1.jpg" alt="a.jpg"></p>
</li>
<li><p>在系统 cmd 界面 ping github.io 的 ip</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5EDg.jpg" alt="3m5EDg.jpg"></p>
</li>
<li><p>在框内填写解析 ip</p>
<p><img src="https://i.loli.net/2020/02/20/ODTXBP4WRYyZcVK.jpg" alt="A2.jpg"></p>
</li>
<li><p>新建 CNAME 记录</p>
<p><img src="https://i.loli.net/2020/02/20/CP6BZFTMnqYycbh.jpg" alt="cname.jpg"></p>
</li>
<li><p>域名解析</p>
<blockquote>
<p>点击 SUBMIT 之后，回到域名管理界面，等待 status 状态变为 Active，则为解析成功，一般大概需要几分钟时间。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5p4I.jpg" alt="3m5p4I.jpg"></p>
</li>
</ul>
</li>
</ul>
<h3 id="在-github-关联域名"><a href="#在-github-关联域名" class="headerlink" title="在 github 关联域名"></a>在 github 关联域名</h3><ul>
<li><p>进入 github 博客仓库，选择 settings 进入项目设置</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5CCt.jpg" alt="3m5CCt.jpg"></p>
</li>
<li><p>在 Option 界面找到 git page 属性进行以下设置</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/D1tE3YZ8naOTmFS.jpg" alt="githubpage.jpg"></p>
<h3 id="在博客目录下的-source-文件夹新建-CNAME-文件，在文件内填写自己的域名"><a href="#在博客目录下的-source-文件夹新建-CNAME-文件，在文件内填写自己的域名" class="headerlink" title="在博客目录下的 source 文件夹新建 CNAME 文件，在文件内填写自己的域名"></a>在博客目录下的 source 文件夹新建 CNAME 文件，在文件内填写自己的域名</h3><blockquote>
<p>保存时，注意选择所有文件类型，文件名仅为 CNAME，无后缀</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/20/VxqNsOWwflFrESG.jpg" alt="cname2.jpg"></p>
<p><img src="https://i.loli.net/2020/02/20/3aSFl1etGmCx5kU.jpg" alt="cname1.jpg"></p>
<h3 id="重新部署生成页面"><a href="#重新部署生成页面" class="headerlink" title="重新部署生成页面"></a>重新部署生成页面</h3><ul>
<li>生成部署页面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目缓存内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br></pre></td></tr></table></figure>

<ul>
<li>在浏览器输入自己的域名即可看到生成的网页</li>
</ul>
<blockquote>
<p><strong>注意：记得清理浏览器缓存。</strong></p>
</blockquote>
<ul>
<li>使用<code>hexo new “文章名”</code>新建文章，在博客目录的 source/_posts/下找到“文章名.md”，即可使用 Markdown 编辑自己的文章了</li>
</ul>
<blockquote>
<p>写好后，注意使用<code>hexo g -d</code>重新生成，部署页面</p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>纯HTML/CSS/JS实现扫雷游戏</title>
    <url>/post/2192395528.html</url>
    <content><![CDATA[<h2 id="使用语言"><a href="#使用语言" class="headerlink" title="使用语言"></a>使用语言</h2><p>  该半个月在<a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web" target="_blank" rel="noopener">MDN Web Docs</a>网站学习网页开发，在学完 HTML、CSS、JavaScript 相关内容以后，决定用项目练练手。在<a href="https://www.shiyanlou.com/courses/?tag=%E5%85%A8%E9%83%A8&fee=all&sort=default&category=Web%20%E5%89%8D%E7%AB%AF&page=2" target="_blank" rel="noopener">实验楼 Web 开发</a>找到仅有的几个纯 HTML + CSS + JavaScript 项目作为练习。</p>
<p>  此项目即为纯Html + CSS + JavaScript的网页版扫雷游戏实现。</p>
<p>  github地址: <a href="https://github.com/ChangeZ24/game-minesweeper" target="_blank" rel="noopener">https://github.com/ChangeZ24/game-minesweeper</a></p>
<p>  在线试玩页面：<a href="http://awesolynn.me/game-minesweeper/">http://awesolynn.me/game-minesweeper/</a></p>
  <a id="more"></a>

<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="https://i.loli.net/2020/02/19/4y2JApmUso1Q6YH.jpg" alt="index.jpg"></p>
<h3 id="游戏页"><a href="#游戏页" class="headerlink" title="游戏页"></a>游戏页</h3><p><img src="https://s2.ax1x.com/2020/02/21/3m5eEj.gif" alt="3m5eEj.gif"></p>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><h3 id="选择游戏难度"><a href="#选择游戏难度" class="headerlink" title="选择游戏难度"></a>选择游戏难度</h3><ol>
<li><p>游戏难度参照 win10 自带扫雷设置：</p>
<ul>
<li>初级 9*9 雷：10</li>
<li>中级 16*16 雷：40</li>
<li>高级 30*16 雷：99</li>
</ul>
</li>
<li><p>选择游戏难度后，点击开始游戏按钮跳转进入游戏页面。</p>
</li>
<li><p>游戏难度自带参数通过 url 传递</p>
</li>
</ol>
<h3 id="左键点击格子显示数字-雷"><a href="#左键点击格子显示数字-雷" class="headerlink" title="左键点击格子显示数字/雷"></a>左键点击格子显示数字/雷</h3><ol>
<li><p>为每个格子绑定 onmousedown 事件，通过其 event.button 值确定点击左键</p>
</li>
<li><p>初始化时，设定扫雷 mineSweeper 类，其中，地图格子以二维数组形式 landArrs 存在</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;由于扫雷每个格子中的内容为数字或雷。数字表示以其为中心的九宫格内雷的数量，故以九宫格中数字1~8表示，0为空格，9为雷</span><br><span class="line">landArrs[i][j]&#x3D;0;&#x2F;&#x2F;空格</span><br><span class="line">landArrs[i][j]&#x3D;1;&#x2F;&#x2F;数字1~8</span><br><span class="line">landArrs[i][j]&#x3D;9;&#x2F;&#x2F;雷</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>游戏开始前，按所选难度的雷数，将各雷随机放在地图内，再根据雷的位置计算雷周围数字的设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1.初始化所有格子为0</span><br><span class="line">landArrs[i][j]&#x3D;0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.按雷数随机放置雷位置</span><br><span class="line">&#x2F;&#x2F;随机数a-b：Math.floor(Math.random() * (max - min)) + min</span><br><span class="line">var randomNum &#x3D; Math.floor(Math.random() * (row * col - 0) + 0);</span><br><span class="line">var rNum &#x3D; parseInt(randomNum &#x2F; this.colCount);&#x2F;&#x2F;随机数所在的格子行数</span><br><span class="line">var cNum &#x3D; parseInt(randomNum % this.colCount);&#x2F;&#x2F;随机数所在的格子列数</span><br><span class="line">&#x2F;&#x2F;判断该位置是否已放置雷（省略）</span><br><span class="line">landArrs[rNum][cNum] &#x3D; 9;&#x2F;&#x2F;放置雷</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.按雷位置，计算其周边数字</span><br><span class="line">&#x2F;&#x2F;算法：遍历每个雷，将每个雷上下左右8格均+1</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>点中雷，游戏失败</li>
</ol>
<h3 id="右键点击插旗或取消旗子"><a href="#右键点击插旗或取消旗子" class="headerlink" title="右键点击插旗或取消旗子"></a>右键点击插旗或取消旗子</h3><ol>
<li><p>为每个格子绑定 onmousedown 事件，通过其 event.button 值确定点击右键</p>
</li>
<li><p>点击右键则将此格的 class 设置为 flag，按 CSS 样式放置旗子背景图—-&gt;插旗</p>
</li>
<li><p>再次点击右键则将已插旗的格子 class 设置为空字符串，取消 CSS 样式—-&gt;拔旗</p>
</li>
</ol>
<h3 id="点击格子为空值无数字时，自动连续展开其周边格子"><a href="#点击格子为空值无数字时，自动连续展开其周边格子" class="headerlink" title="点击格子为空值无数字时，自动连续展开其周边格子"></a>点击格子为空值无数字时，自动连续展开其周边格子</h3><blockquote>
<p>算法：</p>
<ol>
<li>点击格子值为 0，则以该格为中心查看其周围8个格</li>
<li>若其周围格为被打开过，则打开该格。</li>
<li>若其周围格再次遇到 0，自动循环查找</li>
</ol>
</blockquote>
<h3 id="花费时间即剩余雷数计算"><a href="#花费时间即剩余雷数计算" class="headerlink" title="花费时间即剩余雷数计算"></a>花费时间即剩余雷数计算</h3><ol>
<li><p>花费时间</p>
<blockquote>
<p>采用 JS 异步时间间隔 setInterval()算法，每 1s 更新一次时间<br>setInterval(displayTime, 1000);</p>
</blockquote>
</li>
<li><p>剩余雷数</p>
<blockquote>
<p>每标记一处，html 更新一次内容</p>
</blockquote>
</li>
</ol>
<h3 id="双击设定：满足已标记数与自身数字一致时自动打开格子"><a href="#双击设定：满足已标记数与自身数字一致时自动打开格子" class="headerlink" title="双击设定：满足已标记数与自身数字一致时自动打开格子"></a>双击设定：满足已标记数与自身数字一致时自动打开格子</h3><ol>
<li><p>双击已打开的数字格。</p>
<blockquote>
<p>当双击位置周围已标记雷数等于该位置数字时操作有效，相当于对该数字周围未打开的方块均进行一次左键单击操作。<br>地雷未标记完全时使用双击无效。</p>
</blockquote>
</li>
<li><p>若数字周围有标错的地雷，则游戏结束，标错的地雷上会显示一个“×”</p>
</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5VbQ.gif" alt="3m5VbQ.gif"></p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol>
<li><p>实验楼扫雷实现教程</p>
<p><a href="https://www.shiyanlou.com/courses/144" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/144</a></p>
</li>
<li><p>MDN Web Docs</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>MineSweeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Web学习(1)--网络基础</title>
    <url>/post/957423368.html</url>
    <content><![CDATA[<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>  Web开发与网络息息相关，故首先从打好网络基础入手：<br>  <a id="more"></a></p>
<p>  <img src="https://i.loli.net/2020/02/19/Q3fYNHwpL6XPcng.jpg" alt="internet.jpg"></p>
<h2 id="参考学习内容"><a href="#参考学习内容" class="headerlink" title="参考学习内容"></a>参考学习内容</h2><p>  MDN Web Docs</p>
<p>  <a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Internet</tag>
      </tags>
  </entry>
</search>
