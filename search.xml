<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端面经总结（八）</title>
    <url>/post/bb6a8b1a.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/4c01a359.html">前端面经总结（六）</a></p>
<h2 id="Vue中computed和watch区别"><a href="#Vue中computed和watch区别" class="headerlink" title="Vue中computed和watch区别"></a>Vue中computed和watch区别</h2><ol>
<li><p>computed是计算属性，只有依赖数据发生改变才会重新计算。watch是监听属性，数据遍直接会触发相应的操作</p>
</li>
<li><p>computed不支持异步。watch支持异步</p>
</li>
<li><p>computed多用于多对一或一对一，即属性由其他属性计算而来时的情况。watch多用于一对多的情况，即当一个属性变化时，需要执行对应的操作</p>
</li>
<li><p>computed属性在<code>getter</code>执行后默认走缓存，它基于响应式依赖进行缓存，即基于data声明或父组件传递的props中的数据通过计算后得到的值。只有当它依赖的属性值改变后，下一次获取computed的值时才会重新调用<code>getter</code>计算。</p>
</li>
<li><p>watch监听的函数接收两个参数，最新的值<code>newVal</code>和输入之前的值<code>oldVal</code>。在每次监听的值变化时，都会执行回调。当数据变化时，触发的函数有两个参数，<code>immediate</code>表示组件加载立即触发回调函数执行，<code>deep</code>为深度监听，为了发现对象内部值的变化，为复杂类型的数据时使用。如数组中对象内容的改变，但<code>deep</code>无法监听数组变动。</p>
<a id="more"></a>

</li>
</ol>
<h2 id="cors后端如何实现，能否传递cookie"><a href="#cors后端如何实现，能否传递cookie" class="headerlink" title="cors后端如何实现，能否传递cookie"></a>cors后端如何实现，能否传递cookie</h2><h3 id="Java实现"><a href="#Java实现" class="headerlink" title="Java实现"></a>Java实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.servlet.FilterChain;</span><br><span class="line">import javax.servlet.FilterConfig;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.ServletRequest;</span><br><span class="line">import javax.servlet.ServletResponse;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">import org.apache.log4j.Logger;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 允许跨域过滤器(Cross-Origin Resource Sharing)</span><br><span class="line"> * @author user</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class CorsFilter implements Filter &#123;</span><br><span class="line">    </span><br><span class="line">    private final Logger logger &#x3D; Logger.getLogger(this.getClass().getPackage().getName());</span><br><span class="line">    </span><br><span class="line">    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException &#123;  </span><br><span class="line">        HttpServletResponse response &#x3D; (HttpServletResponse) res;  </span><br><span class="line"></span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;*&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);</span><br><span class="line">&#x2F;&#x2F;        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;*&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Authorization,Origin,X-Requested-With,Content-Type,Accept,&quot;</span><br><span class="line">                + &quot;content-Type,origin,x-requested-with,content-type,accept,authorization,token,id,X-Custom-Header,X-Cookie,Connection,User-Agent,Cookie,*&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Request-Headers&quot;, &quot;Authorization,Origin, X-Requested-With,content-Type,Accept&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Expose-Headers&quot;, &quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        chain.doFilter(req, response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void init(FilterConfig filterConfig) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    public void destroy() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;web.xml文件：用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等</span><br><span class="line">&lt;!-- 跨域过滤器 --&gt;</span><br><span class="line">&lt;filter&gt;  </span><br><span class="line">    &lt;filter-name&gt;corsFilter&lt;&#x2F;filter-name&gt;  </span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;corsFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;dental&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;corsFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;toothCheck&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure>

<h3 id="cors传递cookie"><a href="#cors传递cookie" class="headerlink" title="cors传递cookie"></a>cors传递cookie</h3><ol>
<li><p>没有跨域时，后端在<code>response</code>头部设置<code>set-cookie</code>，则会产生<code>cookie</code>并保存在客户端。等客户端再次向后端发送请求时，浏览器会自动携带<code>cookie</code>随请求一并发送到后端</p>
</li>
<li><p>cors跨域时，浏览器默认无法主动跨域向后端发送<code>cookie</code>。故需要发送<code>cookie</code>时</p>
<ul>
<li><p>浏览器设置<code>withCredentials</code>为<code>true</code></p>
</li>
<li><p>后端设置<code>Access-Control-Allow-Credentials</code>为<code>true</code></p>
</li>
</ul>
</li>
</ol>
<p>此时可以发送<code>cookie</code>，但由于<code>同源策略</code>，仍然无法使用/修改<code>cookie</code>，仅能访问到。<code>cookie</code>的CRUD只能由<code>server</code>控制</p>
<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h2><blockquote>
<p>Tree Shaking 是一种通过消除最终文件中未使用的代码来优化体积的方法。</p>
</blockquote>
<p>当引入一个模块时，不引入此模块的所有代码，只引入需要的代码，故可以借助webpack的<code>tree shaking</code>功能。</p>
<figure class="highlight plain"><figcaption><span>shaking```只支持```ES Module-import```，不支持```require```。```require```是动态加载模块的，故可以根据代码中的条件来导入。而```import```是静态加载的，故需要使用```tree shaking```。</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在&#96;&#96;&#96;mode: production&#96;&#96;&#96;模式下，&#96;&#96;&#96;tree shaking&#96;&#96;&#96;会被自动配置，但&#96;&#96;&#96;tree shaking&#96;&#96;&#96;并不能自动判断副作用脚本，即在&#96;&#96;&#96;import&#96;&#96;&#96;时执行了一些行为，但此行为不一定和到处相关，如&#96;&#96;&#96;polyfill&#96;&#96;&#96;是全局引用的，不是在&#96;&#96;&#96;index.js&#96;&#96;&#96;中导入引用。故对于副作用脚本需要在&#96;&#96;&#96;package.json&#96;&#96;&#96;文件中添加&#96;&#96;&#96;&quot;sideEffect&quot;:[&quot;.&#x2F;src&#x2F;polyfill.js&quot;],</span><br></pre></td></tr></table></figure>

<p>在<code>mode: development</code>模式下，可以在<code>webpack.config.js</code>文件中，使用<code>optimization:{ usedExports: true }</code>来配置<code>tree shaking</code>。</p>
<h2 id="图片懒加载的实现和原理"><a href="#图片懒加载的实现和原理" class="headerlink" title="图片懒加载的实现和原理"></a>图片懒加载的实现和原理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol>
<li><p>设置图片的data-set属性值为图片路径，而不是src，故不会发送http请求</p>
</li>
<li><p>计算页面scrollTop的高度和浏览器高度之和，若图片距离页面顶端（相对于整个页面，而不是浏览器窗口）坐标Y小于两者之和，则说明图片要显示出来了</p>
</li>
<li><p>替换data-set属性为src属性</p>
</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ol>
<li>使用<code>padding-top</code>或<code>padding-bottom</code>实现固定宽高比</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;padding-top:75%&quot;&gt;</span><br><span class="line">    &lt;img data-src&#x3D;&quot;&quot; alt&#x3D;&quot;&quot; class&#x3D;&quot;lazyload&quot;&gt;</span><br><span class="line">&lt;div&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Vue中使用开源vue-lazyload</p>
<ul>
<li><p>使用<code>npm install vue-lazyload --save</code>下载</p>
</li>
<li><p>引入vue-lazyload到main.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import VueLazyload from &#39;vue-lazyload&#39;</span><br><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line">preLoad: 1.3,&#x2F;&#x2F;在屏幕多少倍的范围内开始加载</span><br><span class="line">loading: &#39;http:&#x2F;&#x2F;cdn.uehtml.com&#x2F;201402&#x2F;1392662591495_1140x0.gif&#39;,</span><br><span class="line">error: &#39;https:&#x2F;&#x2F;cdn.dribbble.com&#x2F;users&#x2F;195330&#x2F;screenshots&#x2F;1545094&#x2F;attachments&#x2F;235536&#x2F;21_404-error.png&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在.vue中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img id&#x3D;&quot;errorImg&quot; v-lazy&#x3D;&quot;&#39;http:&#x2F;&#x2F;bbg-seller.oss-cn-qingdao.aliyuncs.com&#x2F;test&#x2F;gp&#x2F;p1&#x2F;&#39; + item.picture&quot; error&#x3D;&quot;this.src&#x3D;null;&quot; &gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="502产生的原因"><a href="#502产生的原因" class="headerlink" title="502产生的原因"></a>502产生的原因</h2><p>连接超时，服务器当前链接太多，无法给予正常响应。通常可产生的原因有</p>
<ol>
<li><p>DNS缓冲，如未开启vpn访问外链，未访问到且在本机留下了缓冲，可通过等待几分钟再次访问或在cmd中运行<code>ipconfig/flushdns</code>解决</p>
</li>
<li><p>浏览器开了代理，关掉后可访问</p>
</li>
<li><p>dns被劫持。</p>
</li>
</ol>
<h2 id="jquery如何获得兄弟节点"><a href="#jquery如何获得兄弟节点" class="headerlink" title="jquery如何获得兄弟节点"></a>jquery如何获得兄弟节点</h2><ul>
<li><p>siblings()：选取所有兄弟节点</p>
</li>
<li><p>next()：选取后面的兄弟节点</p>
</li>
<li><p>nextAll()：选取所有后面的兄弟节点</p>
</li>
<li><p>nextUntil()：选取所有后面的兄弟节点，但不包括后面指定节点的弟弟。</p>
</li>
<li><p>prevAll()：选取所有墙面的兄弟节点</p>
</li>
<li><p>prevUntil()：选取所有的兄弟节点，但不包含后面指定的节点及指定节点的哥哥</p>
</li>
</ul>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;li.start&quot;).siblings().css(&#123;&quot;color&quot;:&quot;red&quot;,&quot;border&quot;:&quot;2px solid red&quot;&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="echarts原理"><a href="#echarts原理" class="headerlink" title="echarts原理"></a>echarts原理</h2><blockquote>
<p>echarts是轻量级的javascript图形库，纯js实现，MVC封装，数据驱动</p>
</blockquote>
<p>echarts特点为重要性和优先级一次递减，可个性化定制。其总体结构基于<code>MVC</code>架构。</p>
<ul>
<li>Storage(M)：模型层，实现图形数据的增删改查管理</li>
<li>Painter(V)：视图层，实现Canvas元素的生命周期管理。如视图渲染、更新控制、绘图等</li>
<li>Handler(C)：控制层，事件交互处理，实现完整的dom事件模拟封装</li>
</ul>
<p>其中，<code>Painter</code>持有<code>Storage</code>对象，即<code>Painter</code>读取<code>Storage</code>进行绘图。<code>Handler</code>持有<code>Storage</code>和<code>Painter</code>对象，控制层对模型层有增删改查<code>CURD</code>关系，即<code>Handler</code>通过访问<code>Storage</code>对象提供的数据增删改查操作，实现事件交互处理所需的数据部分，控制层和视图层存在<code>call</code>关系，即<code>Handler</code>通过访问<code>Painter</code>对象提供的视图操作，实现事件交互处理的视图部分。</p>
<h3 id="SVG和Canvas"><a href="#SVG和Canvas" class="headerlink" title="SVG和Canvas"></a>SVG和Canvas</h3><p>SVG和Canvas是两个可选择的类库之一。SVG基于<code>XML</code>，即SVG DOM中每个怨毒都是可用的，且每个被绘制的图像均被视为对象。Canvas基于JavaScript绘制2D图形，且是逐像素渲染，一旦图形被绘制完成，则浏览器停止关注它，若其位置发生变化，则整个场景都需要重新绘制。</p>
<ol>
<li><p>Canvas依赖分辨率，SVG不依赖分辨率</p>
</li>
<li><p>Canvas不支持事件处理器，SVG支持事件处理器</p>
</li>
<li><p>Canvas文本渲染能力弱，SVG适合带有大型渲染区域的应用程序</p>
</li>
<li><p>Canvas能以.png/.jpg格式保存结果图像</p>
</li>
<li><p>Canvas适合图像密集型的游戏，其中许多对象会被频繁重绘。SVG不适合游戏应用，复杂度高会减慢渲染速度</p>
</li>
</ol>
<h3 id="echarts如何实现响应式变化"><a href="#echarts如何实现响应式变化" class="headerlink" title="echarts如何实现响应式变化"></a>echarts如何实现响应式变化</h3><p>使用echarts里的resize函数，当页面发生resize事件时，触发echarts的resize事件，重绘canvas</p>
<ul>
<li><p>若页面只有一个echarts图表，可<code>window.onresize = myChart.resize()</code></p>
</li>
<li><p>若页面有多个echarts图表，使用事件绑定方法<code>addEventListener()</code>方法</p>
</li>
<li><p>若在vue中使用响应式图标，直接对对象添加事件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myCharts.setOption(option);&#x2F;&#x2F;使用指定的配置项和数据显示图表</span><br><span class="line">window.addEventListener(&quot;resize&quot;, () &#x3D;&gt; &#123; myCharts.resize();&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="作用域题"><a href="#作用域题" class="headerlink" title="作用域题"></a>作用域题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log( a ); </span><br><span class="line">&#125;</span><br><span class="line">function bar() &#123;</span><br><span class="line">  var a &#x3D; 3;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; 2;</span><br><span class="line">bar();&#x2F;&#x2F;输出2</span><br><span class="line">bar.call(&#123;a:4&#125;)&#x2F;&#x2F;输出2</span><br></pre></td></tr></table></figure>

<p>调用方法<code>bar()</code>时，<code>bar()</code>方法在全局作用域创建，同时<code>bar()</code>方法调用<code>foo()</code>方法，<code>foo()</code>方法也在全局作用域创建，故<code>foo()</code>方法中，用到的<code>a</code>的值，要取全局作用域定义的<code>a</code>值，即<code>var a = 2;</code>。故<code>bar()</code>输出2。</p>
<p>以上<code>bar()</code>方法的输出用到了“静态作用域“的内容，即<strong>调用函数时，函数内用到的参数要到创建这个函数的那个作用域中取值</strong>。</p>
<p>同样，<code>bar.call({a:4})</code>将<code>bar()</code>的<code>this</code>指向了<code>{a:4}</code>。但<code>foo()</code>方法输出的是<code>console.log(a)</code>中<code>a</code>仍是自由变量，故还是在创建<code>foo()</code>方法的作用域找，故仍输出2。若想输出4，则需要修改<code>foo()</code>方法<code>console.log(this.a)</code>。</p>
<h2 id="算法：千分位"><a href="#算法：千分位" class="headerlink" title="算法：千分位"></a>算法：千分位</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    let str &#x3D; &quot;&quot;;</span><br><span class="line">    let nstr &#x3D; n.toString().split(&quot;&quot;).reverse();</span><br><span class="line">    for(let i &#x3D; 0;i&lt;nstr.length;i++)&#123;</span><br><span class="line">        if(i%3 &#x3D;&#x3D; 2 &amp;&amp; i !&#x3D; nstr.length - 1)&#123;</span><br><span class="line">            str+&#x3D;nstr[i]+&quot;.&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            str+&#x3D;nstr[i]+ &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return str.split(&quot;&quot;).reverse().join(&quot;&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;利用正则表达式</span><br><span class="line">var thousandSeparator &#x3D; function(n) &#123;</span><br><span class="line">    let str &#x3D; n.toString();</span><br><span class="line">    let reg &#x3D; &#x2F;(\d)(?&#x3D;(?:(\d&#123;3&#125;)+$))&#x2F;g;</span><br><span class="line">    return str.replace(reg,&#39;$1.&#39;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="算法：两数之和"><a href="#算法：两数之和" class="headerlink" title="算法：两数之和"></a>算法：两数之和</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var twoSum &#x3D; function(nums, target) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for(let i &#x3D; 0;i&lt; nums.length;i++)&#123;</span><br><span class="line">        let num &#x3D; target - nums[i];</span><br><span class="line">        let index &#x3D; nums.lastIndexOf(num);</span><br><span class="line">        if(index &amp;&amp; index !&#x3D;&#x3D; i &amp;&amp; index !&#x3D;&#x3D; -1)&#123;</span><br><span class="line">            result.push(i);</span><br><span class="line">            result.push(index);</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="算法：多维数组转化为一维数组"><a href="#算法：多维数组转化为一维数组" class="headerlink" title="算法：多维数组转化为一维数组"></a>算法：多维数组转化为一维数组</h2><ol>
<li>利用str</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn(arr)&#123;</span><br><span class="line">    let str &#x3D; arr.join();</span><br><span class="line">    return str.split(&quot;,&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用循环递归</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn(arr)&#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for(let i &#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        if(Array.isArray(arr[i]))&#123;</span><br><span class="line">            fn(arr[i]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            result.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn(arr);</span><br></pre></td></tr></table></figure>

<h2 id="算法：珂里化"><a href="#算法：珂里化" class="headerlink" title="算法：珂里化"></a>算法：珂里化</h2><p>待改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fn &#x3D; function(n1,n2,n3)&#123;return n1*n2*n3&#125;</span><br><span class="line"></span><br><span class="line">function fun1(fn)&#123;</span><br><span class="line">    let len &#x3D; fn.length;</span><br><span class="line">    let args &#x3D; [];</span><br><span class="line">    return function(arg)&#123;</span><br><span class="line">        args.push(arg);</span><br><span class="line">        if(arg.length &lt; len)&#123;</span><br><span class="line">            return arguments.callee;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            return fn.apply(&quot;&quot;,args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>面经</tag>
        <tag>http</tag>
        <tag>HTML</tag>
        <tag>浏览器</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经总结（七）</title>
    <url>/post/4c01a359.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/9e01d4c6.html">前端面经总结（六）</a></p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环是为了解决js单线程运行阻塞的问题而产生。在js中所有任务可以分为同步任务(立即执行的任务，一般直接进入主线程中执行)和异步任务(如ajax/setTimeout等)。</p>
<p>同步任务进入主线程(主执行栈)，异步任务进入任务队列，主线程内任务执行完毕为空，则去任务队列读取对应的任务，推入主线程执行，以上不断重复的过程即为事件循环。</p>
<h3 id="宏任务-微任务"><a href="#宏任务-微任务" class="headerlink" title="宏任务/微任务"></a>宏任务/微任务</h3><a id="more"></a>

<ul>
<li><p>宏任务：由Node/浏览器发起的任务，每次从宏任务事件队列中获取一个放入执行栈中执行</p>
<ul>
<li><p>script</p>
</li>
<li><p>setTimeout/setInterval</p>
</li>
<li><p>I/O</p>
</li>
<li><p>UI交互事件</p>
</li>
<li><p>postMessage()</p>
</li>
<li><p>setImmediate: 遇到setTimeout，先于它执行</p>
</li>
</ul>
</li>
<li><p>微任务：由JavaScript发起的任务，当前任务执行后立刻执行，无需等渲染。</p>
<ul>
<li><p>Promise</p>
</li>
<li><p>process.nextTick</p>
</li>
<li><p>Object.observe</p>
</li>
</ul>
</li>
</ul>
<h3 id="常见考题"><a href="#常见考题" class="headerlink" title="常见考题"></a>常见考题</h3><ol>
<li>基础题</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(1)&#x2F;&#x2F;主线程</span><br><span class="line"></span><br><span class="line">setTimeout(()&#x3D;&gt;&#123;&#x2F;&#x2F;放入宏任务队列</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;, 0)</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject)&#x3D;&gt;&#123;&#x2F;&#x2F;主线程</span><br><span class="line">    console.log(&#39;new Promise&#39;)&#x2F;&#x2F;主线程</span><br><span class="line">    resolve()&#x2F;&#x2F;微任务，放入微任务队列</span><br><span class="line">&#125;).then(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&#39;then&#39;)&#x2F;&#x2F;微任务</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(3)&#x2F;&#x2F;主线程</span><br><span class="line">&#x2F;&#x2F;输出：1 -&gt; new Promise -&gt; 3 -&gt; then -&gt; 2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>复杂题</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function async1() &#123;&#x2F;&#x2F;函数定义，未调用，不管</span><br><span class="line">    console.log(&#39;async1 start&#39;)&#x2F;&#x2F;4.主线程</span><br><span class="line">    await async2()&#x2F;&#x2F;5.遇到await，先执行async2，阻塞下面代码console，即加入微任务1</span><br><span class="line">    console.log(&#39;async1 end&#39;)</span><br><span class="line">&#125;</span><br><span class="line">async function async2() &#123;&#x2F;&#x2F;函数定义，未调用，不管</span><br><span class="line">    console.log(&#39;async2&#39;)&#x2F;&#x2F;6.执行async2，打印</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;script start&#39;)&#x2F;&#x2F;1.主线程</span><br><span class="line">setTimeout(function () &#123;&#x2F;&#x2F;2.宏任务，放入宏任务队列1</span><br><span class="line">    console.log(&#39;settimeout&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">async1()&#x2F;&#x2F;3.调用async1</span><br><span class="line">new Promise(function (resolve) &#123;&#x2F;&#x2F;7.new Promise主线程</span><br><span class="line">    console.log(&#39;promise1&#39;)&#x2F;&#x2F;8. 打印</span><br><span class="line">    resolve()&#x2F;&#x2F;9. 微任务，放入微任务队列2</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(&#39;promise2&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;script end&#39;)&#x2F;&#x2F;10.主线程，打印</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;第一趟主线程输出：script start -&gt; async1 start -&gt; async2 -&gt; promise1 -&gt; script end</span><br><span class="line">&#x2F;&#x2F;开始微任务，输出：async1 end -&gt; promise2</span><br><span class="line">&#x2F;&#x2F;微任务执行完毕，执行下一个宏任务，输出：settimeout</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;最终输出：script start -&gt; async1 start -&gt; async2 -&gt; promise1 -&gt; script end -&gt; async1 end -&gt; promise2 -&gt; settimeout</span><br></pre></td></tr></table></figure>

<h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ol>
<li><p>执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中</p>
</li>
<li><p>当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完</p>
</li>
<li><p>遇到<code>async</code>和<code>await</code>，<code>await</code>会阻塞下面的代码（即加入微任务队列），先执行<code>async</code>外面的同步代码，同步代码执行完，再回到<code>async</code>函数中，再执行之前阻塞的代码</p>
</li>
</ol>
<h2 id="vue双向绑定原理"><a href="#vue双向绑定原理" class="headerlink" title="vue双向绑定原理"></a>vue双向绑定原理</h2><p>通过数据劫持结合发布订阅者模式实现</p>
<p>vue通过<code>Object.defineProperty()</code>实现数据劫持，它可以控制一个对象属性的特有操作，例如读写权/枚举等，</p>
<p>MVVM主要包含两方面，数据变化更新视图，视图变化更新数据。其中视图变化更新数据只需要通过事件监听即可。</p>
<h3 id="数据变化更新视图"><a href="#数据变化更新视图" class="headerlink" title="数据变化更新视图"></a>数据变化更新视图</h3><p>通过<code>Object.defineProperty()</code>对属性设置一个set函数，当数据改变后触发set函数，故将更新方法写入set即可实现data更新view</p>
<ol>
<li><p>实现监听器Observer，用来劫持监听所有属性，若有变动，则通知订阅者</p>
</li>
<li><p>实现订阅者Watcher，可收到属性的变化通知并执行相应的函数，从而更新视图</p>
</li>
<li><p>实现解析器Compile，扫描解析每个节点的相关指令，并根据初始化模版数据以及初始化相应的订阅器</p>
</li>
</ol>
<h2 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h2><p>页面更新可以先全部反映到虚拟dm中，操作内存中的js对象速度会更快，当更新完成后，再将最终的js对象映射到真实的dom中，由浏览器绘制渲染</p>
<h3 id="dom-diff"><a href="#dom-diff" class="headerlink" title="dom diff"></a>dom diff</h3><ol>
<li>思想：DOM Diff过程即对比新旧两份VNode的过程。</li>
</ol>
<ul>
<li><p>旧的VNode(即oldVNode)就是数据变化之前视图所对应的虚拟DOM节点</p>
</li>
<li><p>新的VNode是数据变化之后将要渲染的新的视图所对应的虚拟DOM节点</p>
</li>
</ul>
<p>以生成的新的VNode为基准，对比旧的oldVNode</p>
<ul>
<li>如果新的VNode上有的节点而旧的oldVNode上没有，那么就在旧的oldVNode上加上去；</li>
<li>如果新的VNode上没有的节点而旧的oldVNode上有，那么就在旧的oldVNode上去掉；</li>
<li>如果某些节点在新的VNode和旧的oldVNode上都有，那么就以新的VNode为准，更新旧的oldVNode，从而让新旧VNode相同。</li>
</ul>
<ol start="2">
<li>算法描述</li>
</ol>
<ul>
<li>遍历整个虚拟节点树，找出所有节点差异，记录在补丁包中</li>
<li>遍历结束后根据补丁包执行<code>addPatch()</code>逻辑更新视图</li>
</ul>
<ol start="3">
<li>对比算法</li>
</ol>
<ul>
<li><p>创建节点：新的<code>VNode</code>中有而旧的<code>oldVNode</code>中没有，就在旧的<code>oldVNode</code>中创建。先判断节点类型，再根据不同类型调用不同方法创建节点。</p>
<ul>
<li>调用<code>createElement</code>创建元素节点</li>
<li>调用<code>createComment</code>创建注释节点</li>
<li>调用<code>createTextNode</code>创建文本节点</li>
</ul>
</li>
<li><p>删除节点：新的<code>VNode</code>中没有而旧的<code>oldVNode</code>中有，就从旧的<code>oldVNode</code>中删除。在要删除节点的父元素上调用<code>removeChild</code>方法删除节点</p>
</li>
<li><p>更新节点：新的<code>VNode</code>和旧的<code>oldVNode</code>中都有，就以新的<code>VNode</code>为准，更新旧的<code>oldVNode</code>。</p>
<ul>
<li><p>判断节点类型</p>
<ul>
<li><p>元素节点：判断<code>VNode</code>中是否有<code>tag</code>标签。判断是否包含子节点</p>
<ul>
<li><p>包含子节点：查看<code>oldVNode</code>是否包含子节点，若包含则递归对比更新子节点，若不包含，则判断是空节点还是文本节点，空节点则在新节点<code>VNode</code>里的子节点创建一份插入到<code>oldVNode</code>中，若为文本节点，则将文本清空，将新节点<code>VNode</code>的子节点创建一份插入到<code>oldVNode</code>中。</p>
</li>
<li><p>不包含子节点：若同时又不是文本节点，则说明是空节点，直接清空旧节点<code>oldVNode</code></p>
</li>
</ul>
</li>
<li><p>注释节点：判断<code>VNode</code>的<code>isComment</code>是否为<code>true</code>。注释节点是静态节点，不包含任何变量，故数据发生任何变化均与他无关，更新节点时直接跳过。</p>
</li>
<li><p>文本节点：不是元素节点和注释节点则为文本节点。更新时对比文本内容是否一致。若不同，则把<code>oldVNode</code>里的文本改成跟<code>VNode</code>的文本一样。若<code>oldVNode</code>不是文本节点，则直接使用<code>setTextNode</code>方法将它改成文本节点</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li>完整的树比较算法时间复杂度过高，DOM-Diff中使用的算法是只对新旧两棵树中的节点进行同层比较，忽略跨层比较。</li>
</ol>
<h2 id="dom概念及分类"><a href="#dom概念及分类" class="headerlink" title="dom概念及分类"></a>dom概念及分类</h2><p>Dom即HTML的层级结构，有Dom元素树和Dom文档树。</p>
<p>其节点类型有：元素节点、属性节点、文本节点、文档节点、注释节点、实体名称节点、处理指令节点等</p>
<h3 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h3><ul>
<li>document.getElementById: 通过id获取元素节点　</li>
<li>getElementsByTagName:　通过标签名称获取元素节点</li>
<li>getElementsByClassName: 通过类名获取元素节点</li>
<li>getElementsByName: 通过表单元素的name获取元素节点</li>
<li>querySelector(“[selector]”):　支持一切css中的选择器，但如果匹配多个，只会返回第一个</li>
<li>querySelectorAll(“[selector]”):　返回所有选中的元素</li>
</ul>
<h2 id="a-2-amp-amp-a-3"><a href="#a-2-amp-amp-a-3" class="headerlink" title="a==2 &amp;&amp; a==3"></a>a==2 &amp;&amp; a==3</h2><p>js调用==比较时，会触发类型转换，即两个函数<code>toString()</code>和<code>valueOf</code>，每比较一次，调用一次</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">    i: 1,</span><br><span class="line">    valueOf:()&#x3D;&gt;&#123;</span><br><span class="line">        return a.i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="a-2-amp-amp-a-3-1"><a href="#a-2-amp-amp-a-3-1" class="headerlink" title="a===2&amp;&amp;a===3"></a>a===2&amp;&amp;a===3</h2><p>使用Object.defineProperty为对象定义一个属性，此时该属性具有getter方法，即可以在代码中被直接访问到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var value &#x3D; 0;</span><br><span class="line">Object.defineProperty(window,&#39;a&#39;,&#123;</span><br><span class="line">    get: function()&#123;</span><br><span class="line">        return this.value ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="实现元素拖拽"><a href="#实现元素拖拽" class="headerlink" title="实现元素拖拽"></a>实现元素拖拽</h2><ol>
<li><p>使用HTML5的API：dataTransfer</p>
<ul>
<li><p>为拖拽的元素设值允许拖拽，赋予dragstart事件将其id转换为数据保存</p>
</li>
<li><p>为容器添加dragover属性添加事件组织浏览器默认事件，允许元素放置，并赋予drop事件进行元素放置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 参数要传入event对象 --&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box1&quot; ondragover&#x3D;&quot;allowdrop(event)&quot; ondrop&#x3D;&quot;drop(event)&quot;&gt;</span><br><span class="line">    &lt;img src&#x3D;&quot;img&#x2F;2.jpg&quot; alt&#x3D;&quot;00&quot; draggable&#x3D;&quot;true&quot; ondragstart&#x3D;&quot;drag(event)&quot; id&#x3D;&quot;drag&quot; width&#x3D;&quot;50&quot; height&#x3D;&quot;50&quot;&gt;</span><br><span class="line">    &lt;span&gt;我是盒子一&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box2&quot; ondragover&#x3D;&quot;allowdrop(event)&quot; ondrop&#x3D;&quot;drop(event)&quot;&gt;</span><br><span class="line">&lt;span&gt;我是盒子二&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function allowdrop(e) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drop(e) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        var data &#x3D; e.dataTransfer.getData(&quot;text&quot;);</span><br><span class="line">        e.target.appendChild(document.getElementById(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function drag(e) &#123;</span><br><span class="line">        e.dataTransfer.setData(&quot;text&quot;, e.target.id);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用原生js</p>
<ul>
<li><p>获取鼠标距离元素左边界和上边界的距离</p>
</li>
<li><p>移动后计算元素相对原来位置的相对距离，赋予样式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;box1&quot; id&#x3D;&quot;drag&quot;&gt;</span><br><span class="line">    &lt;span&gt;我是盒子一&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;box2&quot;&gt;</span><br><span class="line">    &lt;span&gt;我是盒子二&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let drag &#x3D; document.querySelector(&quot;#drag&quot;);&#x2F;&#x2F;获取操作元素</span><br><span class="line">    drag.onmousedown &#x3D; function (e) &#123;&#x2F;&#x2F;鼠标按下触发</span><br><span class="line">        var disx &#x3D; e.pageX - drag.offsetLeft;&#x2F;&#x2F;获取鼠标相对元素距离</span><br><span class="line">        var disy &#x3D; e.pageY - drag.offsetTop;</span><br><span class="line">        console.log(e.pageX);</span><br><span class="line">        console.log(drag.offsetLeft);</span><br><span class="line">        document.onmousemove &#x3D; function (e) &#123;&#x2F;&#x2F;鼠标移动触发事件，元素移到对应为位置</span><br><span class="line">            drag.style.left &#x3D; e.pageX - disx + &#39;px&#39;;</span><br><span class="line">            drag.style.top &#x3D; e.pageY - disy + &#39;px&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">        document.onmouseup &#x3D; function()&#123;&#x2F;&#x2F;鼠标抬起，清除绑定的事件，元素放置在对应的位置</span><br><span class="line">            document.onmousemove &#x3D; null;</span><br><span class="line">            document.onmousedown &#x3D; null;</span><br><span class="line">        &#125;;</span><br><span class="line">        e.preventDefault();&#x2F;&#x2F;阻止浏览器的默认事件</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="实现防抖-节流函数"><a href="#实现防抖-节流函数" class="headerlink" title="实现防抖/节流函数"></a>实现防抖/节流函数</h2><ol>
<li>防抖函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function debounce(func,delay)&#123;</span><br><span class="line">    var timeout;</span><br><span class="line">    return function(e)&#123;</span><br><span class="line">        &#x2F;&#x2F;清除旧timeout</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        var context &#x3D;  this, args &#x3D; arguments;</span><br><span class="line">        &#x2F;&#x2F;新timeout</span><br><span class="line">        timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">        &#125;,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;第一次触发会立刻执行 </span><br><span class="line">const debounceImmediate &#x3D; (cb, delay &#x3D; 1000, immediate &#x3D; true) &#x3D;&gt; &#123;</span><br><span class="line">  let timer &#x3D; null;</span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    const context &#x3D; this;</span><br><span class="line">    const execNow &#x3D; immediate &amp;&amp; !timer;</span><br><span class="line">    if (timer) clearTimeout(timer);</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      cb.apply(context, args);</span><br><span class="line">      timer &#x3D; null;</span><br><span class="line">    &#125;, delay);</span><br><span class="line">    execNow &amp;&amp; cb.apply(this, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>节流函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function throttle(func, delay)&#123;</span><br><span class="line">    let timeout;</span><br><span class="line">    let start &#x3D; new Date;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        let context &#x3D;  this, args &#x3D; arguments, curr &#x3D;  new Date() - 0;</span><br><span class="line">        let remain &#x3D;  delay - (curr - start);</span><br><span class="line">        if(timeout) </span><br><span class="line">            clearTimeout(timeout);</span><br><span class="line">        if(remain &lt;&#x3D; 0&gt;)&#123;</span><br><span class="line">            &#x2F;&#x2F;第一次触发执行</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            start &#x3D; curr;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;事件结束后也执行一次</span><br><span class="line">            timeout &#x3D; setTimeout(function()&#123;</span><br><span class="line">                func.apply(context,args)</span><br><span class="line">                timeout &#x3D; null</span><br><span class="line">            &#125;,delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="vue直接赋值修改数组，页面无法同步更新"><a href="#vue直接赋值修改数组，页面无法同步更新" class="headerlink" title="vue直接赋值修改数组，页面无法同步更新"></a>vue直接赋值修改数组，页面无法同步更新</h2><p>vue由于js限制，不能同步更新，它会绕开监听器，无法实现动态效果。若需要实时更新，需要使用push()/pop()等方法</p>
<h2 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h2><p>2种模式：hash/history</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F; 根据mode确定history实际的类并实例化    </span><br><span class="line">switch (mode) &#123;</span><br><span class="line">  case &#39;history&#39;:</span><br><span class="line">    this.history &#x3D; new HTML5History(this, options.base)</span><br><span class="line">    break</span><br><span class="line">  case &#39;hash&#39;:</span><br><span class="line">    this.history &#x3D; new HashHistory(this, options.base, this.fallback)</span><br><span class="line">    break</span><br><span class="line">  case &#39;abstract&#39;:</span><br><span class="line">    this.history &#x3D; new AbstractHistory(this, options.base)</span><br><span class="line">    break</span><br><span class="line">  default:</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      assert(false, &#96;invalid mode: $&#123;mode&#125;&#96;)</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>hash：url的<code>hash</code>以<code>#</code>开头，基于<code>location.hash</code>实现，值为<code>#</code>后的内容。当<code>hash</code>改变时，页面不会刷新，浏览器也不会请求服务器。<code>hash</code>改变时，触发相应的<code>hashchange</code>事件，操控路由改变，切换内容</p>
</li>
<li><p>history：通过使用<code>pushState</code>和<code>replaceState</code>改变url地址，同时使用<code>onpopState</code>事件，刷新页面向服务器发送请求。需要特别注意的是,调用<code>history.pushState()</code>或<code>history.replaceState()</code>不会触发<code>popstate</code>事件。只有在做出浏览器动作时，比如点击后退、前进按钮或者调用JS中的<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>才会触发该事件。</p>
</li>
</ul>
<h3 id="HashHistory"><a href="#HashHistory" class="headerlink" title="HashHistory"></a>HashHistory</h3><p>替换路由有两个方法<code>HashHistory.push()</code>和<code>HashHistory.replace()</code></p>
<ul>
<li><p>HashHistory.push()将新路由添加到浏览器访问离是栈顶。</p>
<ol>
<li>$router.push()</li>
<li>HashHistory.push()：根据hash模式调用，设置hash并添加到浏览器历史记录，即<code>window.location.hash=xxx</code></li>
<li>History.transitionTo()：监听更新，若更新则调用</li>
<li>History.updateRoute()：更新路由</li>
<li>app._route = route：替换路由</li>
<li>vm.render()：更新视图</li>
</ol>
</li>
<li><p>HashHistory.replace()替换当前路由</p>
</li>
</ul>
<h3 id="HTML5History"><a href="#HTML5History" class="headerlink" title="HTML5History"></a>HTML5History</h3><p>History interface是浏览器历史记录栈提供的接口，通过<code>back()</code>/<code>forward()</code>/<code>go()</code>等方法，读取浏览器历史记录栈的信息，进行跳转操作。HTML5后通过使用<code>pushState()</code>/<code>replaceState()</code>读取、修改浏览器历史记录栈</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.history.pushState(stateObject, title, URL)</span><br><span class="line">window.history.replaceState(stateObject, title, URL)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>stateObject: 当浏览器跳转到新状态时，将触发<code>popState</code>事件，该事件携带此参数副本</p>
</li>
<li><p>title：所添加记录的标题</p>
</li>
<li><p>URL：所添加记录的url</p>
</li>
</ul>
<h2 id="事件冒泡-事件捕获-事件委托"><a href="#事件冒泡-事件捕获-事件委托" class="headerlink" title="事件冒泡/事件捕获/事件委托"></a>事件冒泡/事件捕获/事件委托</h2><p>解决页面中事件流的问题，即解决事件发生的顺序问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;div2&quot;&gt;</span><br><span class="line">        &lt;p id&#x3D;&quot;p1&quot;&gt;事件&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    let div1 &#x3D; document.getElementById(&#39;div1&#39;);</span><br><span class="line">    let div2 &#x3D; document.getElementById(&#39;div2&#39;);</span><br><span class="line">    let p1 &#x3D; document.getElementById(&#39;p1&#39;);</span><br><span class="line">    div1.onclick &#x3D; function ()&#123; console.log(&quot;click div1&quot;)&#125;;</span><br><span class="line">    div2.onclick &#x3D; function ()&#123; console.log(&quot;click div2&quot;)&#125;;</span><br><span class="line">    p1.onclick &#x3D; function ()&#123; console.log(&quot;click p1&quot;)&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>事件冒泡：事件从最内层的元素开始发生，一直向上传播，直到document对象。如上述代码，事件发生顺序为<code>&lt;p&gt;</code>=&gt;<code>&lt;div id=&quot;div2&quot;&gt;</code>=&gt;<code>&lt;div id=&quot;div1&quot;&gt;</code>。阻止事件冒泡使用<code>event.stopPropagation()</code>方法。取消默认事件使用<code>event.preventDefault()</code>。</p>
</li>
<li><p>事件捕获：事件从最外层元素开始发生，直到最具体的元素。如上述代码，事件发生顺序为<code>&lt;div id=&quot;div1&quot;&gt;</code>=&gt;<code>&lt;div id=&quot;div2&quot;&gt;</code>=&gt;<code>&lt;p&gt;</code></p>
</li>
</ul>
<p>方法<code>addEventListener(event, function, useCapture)</code>用来为特定元素绑定事件处理函数，其参数分别为：没有on的事件类型<code>event</code>/事件处理函数<code>function</code>/控制事件阶段<code>useCapture</code>。其中<code>useCapture</code>默认为<code>false</code>，即在事件冒泡阶段调用事件函数，若为<code>true</code>，即在事件捕获阶段调用事件函数</p>
<ul>
<li>事件委托：事件目标自身不处理事件，而是把处理任务委托给其父元素/祖先元素或者根元素document</li>
</ul>
<p>DOM标准事件流的触发的先后顺序为：先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。</p>
<p>常用的冒泡事件为: <code>touchstart</code>/<code>touchmove</code>/<code>tap</code>/```animationstart``等</p>
<p>常见的非冒泡事件（组件的自定义事件若无特殊声明都为非冒泡事件）：<code>form</code>的<code>submit</code>事件，<code>input</code>的<code>input</code>事件，<code>scroll-view</code>的<code>scroll</code>事件。</p>
<h2 id="typeof-null-typeof-undefined输出"><a href="#typeof-null-typeof-undefined输出" class="headerlink" title="typeof null/typeof undefined输出"></a>typeof null/typeof undefined输出</h2><ul>
<li><p>typeof null = object：null表示一个空对象的引用，即一个变量不再指向任何对象地址</p>
</li>
<li><p>typeof undefined = undefined：undefined表示一个没有赋值的变量</p>
</li>
</ul>
<h2 id="异步async实现sleep函数"><a href="#异步async实现sleep函数" class="headerlink" title="异步async实现sleep函数"></a>异步async实现sleep函数</h2><ol>
<li><p>promise解决callback会产生的回调地狱，且不能捕获错误的问题而产生，它实现了链式调用，每次返回都是一个全新的promise。但无法取消promise，错误也需要通过回调函数来捕获。</p>
</li>
<li><p>async/await也解决回调地狱的问题，且不会向promise产生一系列的then链。但他的缺点是await将异步代码改造成同步代码，若多个异步操作没有依赖性，则await会导致性能上的降低</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sleep(ms) &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn() &#123;</span><br><span class="line">    await sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;promise</span><br><span class="line">function sleep &#x3D; time&#x3D;&gt;&#123;</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">        setTimeour(resolve,ms);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sleep(1000).then(()&#x3D;&gt;&#123;</span><br><span class="line">    console.log(&quot;111&quot;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="instanceof实现"><a href="#instanceof实现" class="headerlink" title="instanceof实现"></a>instanceof实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn(a,b)&#123;</span><br><span class="line">    let type &#x3D; b.prototype;&#x2F;&#x2F;类型原型</span><br><span class="line">    let obj &#x3D; a._proto_;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        if(type &#x3D;&#x3D;&#x3D; obj)</span><br><span class="line">            return true;</span><br><span class="line">        obj &#x3D; obj._proto_;</span><br><span class="line">        if(obj &#x3D;&#x3D;&#x3D; null)</span><br><span class="line">            return false;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="jsonp原理及实现"><a href="#jsonp原理及实现" class="headerlink" title="jsonp原理及实现"></a>jsonp原理及实现</h2><blockquote>
<p>jsonp是json的使用模式，可以让网页从别的域名获取资料，即跨域读取数据。由于同源策略，所以需要使用jsonp</p>
</blockquote>
<p>原理：利用<code>script</code>标签的<code>src</code>没有跨域限制来完成</p>
<p>过程：</p>
<ol>
<li>前端定义解析函数jsonCallback = function(res){}，并把callback名字jsonpCallback传递给服务器</li>
<li>后端生成JSON数据，并以此JSON数据为入参生成function，function名字为传入的jsonpCallback。function语法为js，返回给客户端</li>
<li>前端在script标签返回资源时，执行jsonpCallback并通过回调函数的方式拿到数据。</li>
</ol>
<h3 id="jsonp实现"><a href="#jsonp实现" class="headerlink" title="jsonp实现"></a>jsonp实现</h3><ol>
<li>客户端jQuery实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;JSONP 实例&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.static.runoob.com&#x2F;libs&#x2F;jquery&#x2F;1.8.3&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;    </span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;divCustomers&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$.ajax(&#39;https:&#x2F;&#x2F;www.runoob.com&#x2F;try&#x2F;ajax&#x2F;jsonp.php&#39;, &#123;</span><br><span class="line">        method: &#39;post&#39;,</span><br><span class="line">        contentType: &#39;application&#x2F;javascript;charset&#x3D;utf-8&#39;,</span><br><span class="line">        </span><br><span class="line">        dataType: &#39;jsonp&#39;,		&#x2F;&#x2F; jsonp方式</span><br><span class="line">        jsonp: &#39;jsoncallback&#39;,	&#x2F;&#x2F; 回调函数名-参数名</span><br><span class="line">        success: function (result) &#123;</span><br><span class="line">            &#x2F;&#x2F;  回调函数</span><br><span class="line">            console.log(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    $(&quot;#jkl&quot;).html(parseInt($(&quot;#jkl&quot;).html()) + 1);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>服务端实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void service(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line">		</span><br><span class="line">		String msg &#x3D; &quot;测试信息&quot;;</span><br><span class="line">		&#x2F;&#x2F; jsonp跨域协议</span><br><span class="line">		resp.addHeader(&quot;content-type&quot;, &quot;application&#x2F;javascript&quot;);</span><br><span class="line">		String func &#x3D; request.getParameter(&quot;jsoncallback&quot;);</span><br><span class="line">		PrintWriter pw &#x3D; resp.getWriter();</span><br><span class="line">		pw.print(func + &quot;(&#39;&quot; + msg + &quot;&#39;);&quot;);</span><br><span class="line">		pw.flush();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jsonp如何处理多个请求"><a href="#jsonp如何处理多个请求" class="headerlink" title="jsonp如何处理多个请求"></a>jsonp如何处理多个请求</h3><p>在发送请求前判断当前是否有相同的jsonp请求正在发送，如果发生冲突则取消本次请求，等到上一次请求完成后再重新请求。也就是说把并发的请求转换为穿行执行。可以使用<code>Promise</code>链式调用处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myjsonp.JSONP(&#123;</span><br><span class="line">    url: &#39;http:&#x2F;&#x2F;url&#39;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        test: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    cache: true,</span><br><span class="line">    dataType: &#39;jsonp&#39;,</span><br><span class="line">    jsonp: &#39;cb&#39;,</span><br><span class="line">    jsonpCallback: &#39;jsonpCallback&#39;,</span><br><span class="line">    success: function () &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; todo</span><br><span class="line">&#125;)</span><br><span class="line">.catch(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; todo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>实现不同屏幕分辨率的终端上浏览网页的不同展示方式，即通过检测视口分辨率，针对不同客户端在客户端做代码处理，来展现不同的布局和内容。常用的是三栏布局等</p>
<h2 id="webpack打包output中filename-name-chunkhash-js里chunkhash的用处"><a href="#webpack打包output中filename-name-chunkhash-js里chunkhash的用处" class="headerlink" title="webpack打包output中filename:[name][chunkhash].js里chunkhash的用处"></a>webpack打包output中filename:[name][chunkhash].js里chunkhash的用处</h2><p>具体来说webpack是根据入口entry配置文件来分析其依赖项并由此来构建该entry的chunk，并生成对应的hash值。不同的chunk会有不同的hash值。一般在项目中把公共的依赖库和程序入口文件隔离并进行单独打包构建，用chunkhash来生成hash值，只要依赖公共库不变，那么其对应的chunkhash就不会变，从而达到缓存的目的。</p>
<h2 id="map和foreach的区别，好处和优点"><a href="#map和foreach的区别，好处和优点" class="headerlink" title="map和foreach的区别，好处和优点"></a>map和foreach的区别，好处和优点</h2><ul>
<li><p>forEach()：针对每个元素执行提供的函数</p>
</li>
<li><p>map()：创建新的数组，其中每个元素由调用a中每个元素执行提供的函数而来</p>
</li>
</ul>
<p>区别：</p>
<ol>
<li><p>forEach会修改原来数组，map得到一个新的数组并返回</p>
</li>
<li><p>forEach执行速度比map慢</p>
</li>
<li><p>forEach适用于不改变数据，仅利用数据时使用，map适用于需要改变数值时使用</p>
</li>
</ol>
<h2 id="防抖和节流分别在什么情况下使用"><a href="#防抖和节流分别在什么情况下使用" class="headerlink" title="防抖和节流分别在什么情况下使用"></a>防抖和节流分别在什么情况下使用</h2><ol>
<li><p>防抖：N秒后再执行该事件，若n秒内重复触发，则重新计时。</p>
<ul>
<li><p>搜索框搜索输入，用户最后一次输入完再发送请求</p>
</li>
<li><p>手机号/邮箱输入检测</p>
</li>
<li><p>窗口大小resize。窗口调整完在计算窗口大小，防止重复渲染</p>
</li>
</ul>
</li>
<li><p>节流：N秒内值运行一次，若n秒内重复触发，则只有一次生效</p>
<ul>
<li>滚动加载，加载更多等</li>
<li>搜索框，搜索联想功能</li>
</ul>
</li>
</ol>
<h2 id="项目登陆如何实现"><a href="#项目登陆如何实现" class="headerlink" title="项目登陆如何实现"></a>项目登陆如何实现</h2><ol>
<li><p>写登陆页面和登陆的路由跳转</p>
</li>
<li><p>写登陆的请求接口</p>
</li>
<li><p>使用axios向后端登陆接口发送登陆请求</p>
</li>
<li><p>跨域在java后端使用cors标签头处理</p>
</li>
<li><p>后端校验登陆返回一个token或者sessionID</p>
</li>
<li><p>使用vuex保存登陆状态token到浏览器的sessionStorage，并根据返回内容跳转URL路由</p>
</li>
<li><p>退出时，清空sessionStorage中的token信息，跳转页面</p>
</li>
</ol>
<h3 id="单点登陆"><a href="#单点登陆" class="headerlink" title="单点登陆"></a>单点登陆</h3><ol>
<li><p>用户在认证中心登陆</p>
</li>
<li><p>登陆成功，认证中心记录用户登陆状态，将token写入认证中心的cookie</p>
</li>
<li><p>应用系统检查请求中有没有token，没有，则表示没有登陆，页面带着认证中心的cookie跳转至认证中心。</p>
</li>
<li><p>认证中心通过cookie了解用户是否已经登陆。</p>
</li>
<li><p>若没有登陆，则返回登陆页面等待登陆。若登陆过了，则生成一个token，拼接在目标url后，回传给系统</p>
</li>
<li><p>系统拿到token，想认证中心确认token的合法性，防止伪造token。</p>
</li>
<li><p>确认无误，系统记录用户登陆状态，将token写入当前系统的cookie，进入系统。</p>
</li>
<li><p>后续用户再次访问系统，会自动带上此token，系统验证token发现已登陆则直接放行。</p>
</li>
</ol>
<h2 id="基本类型和引用类型区别"><a href="#基本类型和引用类型区别" class="headerlink" title="基本类型和引用类型区别"></a>基本类型和引用类型区别</h2><ol>
<li><p>基本类型是存储在栈内的简单数据段，其值存在变量访问的位置。故赋值/访问/函数传参都是按值传递。复制时，复制原始值的副本给新变量，从此而至为两个独立的变量，传参同</p>
</li>
<li><p>引用类型是存储在堆中的对象，其指针存在变量访问的位置。故赋值/访问/函数传参都是按地址传递。复制时，复制原始值的内存地址给新变量，故新变量改变，原始值也会改变，传参亦同。</p>
</li>
</ol>
<h2 id="script的defer和async的区别"><a href="#script的defer和async的区别" class="headerlink" title="script的defer和async的区别"></a>script的defer和async的区别</h2><ol>
<li><p>script没有<code>defer</code>或<code>async</code>属性，浏览器立即加载并执行相应脚本，此时会阻塞渲染script标签之后的文档</p>
</li>
<li><p>script有<code>async</code>属性，表示后续文档加载和渲染与js脚本加载执行是并行的。</p>
</li>
<li><p>script有<code>defer</code>属性，表示加载后续文档的过程和js脚本加载是并行的，但js脚本的执行要等到文档所有元素解析完成后，DOMContentLoaded事件触发执行之前。</p>
</li>
<li><p>若有多个<code>defer</code>属性脚本，则他们按照加载顺序执行脚本，若有多个<code>async</code>属性脚本，则他们的加载和执行是紧挨着的，无论声明顺序如何，只要加载完就立刻执行</p>
</li>
</ol>
<h2 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h2><ol>
<li><p>for in是es5的标准，遍历的是可遍历对象/数组/字符串的key，for of是es6的标准，遍历的是可遍历对象/数组/字符串的value</p>
</li>
<li><p>代码<code>for(let index in arr)</code>的<code>index</code>为字符串型数字，不能进行集合运算。且遍历顺序不一定按照实际数组的内部顺序，for-in也会遍历数组所有可美剧属性，包括原型。若原型方法被遍历出来，通常需要配合<code>hasOwnProperty()</code>方法来判断某个属性是是否是对象的实例属性，来删除原型对象</p>
</li>
<li><p>for-of避开for in的缺陷，且不会遍历到原型的method和name</p>
</li>
<li><p>for-in更适合遍历对象，不建议遍历数组。for-of适合遍历数组。</p>
</li>
<li><p>for-of可用于遍历Map和Set</p>
</li>
</ol>
<h2 id="算法求数组第二大的数"><a href="#算法求数组第二大的数" class="headerlink" title="算法求数组第二大的数"></a>算法求数组第二大的数</h2><ol>
<li>先排序再输出</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sort(arr)&#123;</span><br><span class="line">    &#x2F;&#x2F;快排</span><br><span class="line">&#x2F;&#x2F;     let mid &#x3D; Math.floor(arr.length &#x2F; 2);</span><br><span class="line">&#x2F;&#x2F;     let middle &#x3D; arr.splice(mid,1)[0];</span><br><span class="line">&#x2F;&#x2F;     let left &#x3D; [],right &#x3D; [];</span><br><span class="line">&#x2F;&#x2F;     for(let i &#x3D; 0; i&lt; arr.length-1; i++)&#123;</span><br><span class="line">&#x2F;&#x2F;         if(arr[i] &gt; middle)</span><br><span class="line">&#x2F;&#x2F;             right.push(arr[i]);</span><br><span class="line">&#x2F;&#x2F;         else</span><br><span class="line">&#x2F;&#x2F;             left.push(arr[i]);</span><br><span class="line">        </span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F;     return sort(left).concat([mid],sort(right));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;冒泡</span><br><span class="line">    for(let i &#x3D; 0;i&lt;arr.length - 1;i++)&#123;</span><br><span class="line">        for(let j &#x3D; 0;j&lt;arr.length - 1 - i;j++)&#123;</span><br><span class="line">            if(arr[j+1] &lt;arr[j])</span><br><span class="line">                [arr[j],arr[j+1]] &#x3D; [arr[j+1],arr[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function findSecondMax(arr)&#123;</span><br><span class="line">    sort(arr);</span><br><span class="line">    console.log(arr);</span><br><span class="line">    console.log(arr[arr.length - 2]);</span><br><span class="line">&#125;</span><br><span class="line">findSecondMax([3,1,2]);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将第一大和第二大的数，放在数组0和1的位置上，若当前数属于第一大，则使用<code>unshift</code>插入到第一位，并删除当前数。若当前数属于第二大，将此数赋值到a[1]。再删除当前数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">findSecondMath(arr)&#123;</span><br><span class="line">    for(let i &#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        if(i &#x3D;&#x3D;&#x3D; 1 &amp;&amp; arr[i] &gt; arr[0])&#123;</span><br><span class="line">            arr.unshift(arr[i]);</span><br><span class="line">            arr.splice(i+1,1)</span><br><span class="line">        &#125;else if(arr[i] &lt; arr[0] &amp;&amp; arr[i] &gt; arr[1])&#123;</span><br><span class="line">            &#x2F;&#x2F;属于第二大</span><br><span class="line">            arr[1] &#x3D; arr[i];</span><br><span class="line">            arr.splice(i,1);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else if(arr[i] &gt; arr[0] &amp;&amp; arr[i] &gt; arr[1])&#123;</span><br><span class="line">            arr.unshift(arr[i]);</span><br><span class="line">            arr.splice(i+1,1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法：括号匹配"><a href="#算法：括号匹配" class="headerlink" title="算法：括号匹配"></a>算法：括号匹配</h2><p>利用栈和map匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn(str)&#123;</span><br><span class="line">    let stack &#x3D; [];</span><br><span class="line">    let valid &#x3D; &#123;</span><br><span class="line">        &#39;(&#39; : &#39;)&#39;,</span><br><span class="line">        &#39;[&#39; : &#39;]&#39;,</span><br><span class="line">        &#39;&#123;&#39; : &#39;&#125;&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">    for(let ch of str)&#123;</span><br><span class="line">        if([&quot;(&quot;,&quot;&#123;&quot;,&quot;[&quot;].includes(ch))&#123;</span><br><span class="line">            stack.push(ch);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            let left &#x3D; stack.pop();</span><br><span class="line">            let right &#x3D; valid[left];</span><br><span class="line">            if(right !&#x3D;&#x3D; ch)&#123;</span><br><span class="line">                console.log(false);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(stack.length &#x3D;&#x3D;&#x3D; 0)</span><br><span class="line">        console.log(true);</span><br><span class="line">&#125;</span><br><span class="line">fn(&quot;([([))]&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>面经</tag>
        <tag>http</tag>
        <tag>HTML</tag>
        <tag>浏览器</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经总结（六）</title>
    <url>/post/9e01d4c6.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/fb0f9f1f.html">前端面经总结（五）</a></p>
<h2 id="SetTimeout循环输出数组"><a href="#SetTimeout循环输出数组" class="headerlink" title="SetTimeout循环输出数组"></a>SetTimeout循环输出数组</h2><p>题目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;,0);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i)</span><br></pre></td></tr></table></figure>
<p>由于<code>var</code>不是块级作用域，为全局作用域。<code>setTimeout</code>为异步操作，故每次执行循环，将<code>setTimeout</code>放入执行队列中，等全局<code>i</code>执行到5结束循环了再从队列中取出5次<code>setTimeout</code>执行，由于<code>var i = 0</code>全局可用，故最终输出6个5，5次<code>setTimeout</code>，1次全局<code>console.log(i)</code></p>
<a id="more"></a>

<ol>
<li>使用闭包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for(var i &#x3D; 1; i &lt; 5; i++)&#123;</span><br><span class="line">    (function(j)&#123;</span><br><span class="line">        setTimeout(function ()&#123;</span><br><span class="line">            console.log(j);</span><br><span class="line">        &#125;,0);</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i);</span><br></pre></td></tr></table></figure>

<p>通过闭包，将i变量留在内存中，输出j时，引用外部函数变量i，i根据循环得出。</p>
<ol start="2">
<li>let</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (let i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(i);</span><br><span class="line">    &#125;,0);</span><br><span class="line">&#125;</span><br><span class="line">console.log(i)</span><br></pre></td></tr></table></figure>

<p>声明<code>let</code>是块级作用域，将<code>i</code>绑定到循环体的每次迭代，确保上一次迭代结束的值重新被赋值，且不会影响后面<code>for</code>循环的<code>i</code>值赋给前面的<code>setTimeout</code>里。又由于<code>let</code>是块级作用域，只在<code>for</code>循环的大括号内可用，故全局的<code>console.log(i)</code>并不存在<code>i</code>值</p>
<h2 id="js作用域"><a href="#js作用域" class="headerlink" title="js作用域"></a>js作用域</h2><ol>
<li>作用域</li>
</ol>
<p>定义的变量可以产生作用/使用的区域。js作用域可以分为<strong>全局作用域</strong>和<strong>局部作用域</strong>。</p>
<ol start="2">
<li>执行上下文：当前代码运行的环境，主要分为<strong>全局级别</strong>和<strong>函数级别</strong>。</li>
</ol>
<p>无论什么环境，只能存在一个全局级别的执行上下文，可以有多个函数执行上下文。函数每次被调用执行时，js引擎自动创建出一个函数上下问，并放入执行上下文堆栈中，<strong>外部上下文无法访问内部上下文中的变量，但内部上下文可以访问外部上下文中的变量</strong>。</p>
<h2 id="js中this指向"><a href="#js中this指向" class="headerlink" title="js中this指向"></a>js中this指向</h2><blockquote>
<p>谁调用这个函数或方法，this关键字就指向谁</p>
</blockquote>
<ol>
<li>普通函数调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; var name &#x3D; &quot;x1&quot;;&#x2F;&#x2F;输出一样</span><br><span class="line">function person()&#123;</span><br><span class="line">    this.name &#x3D; &quot;x1&quot;;</span><br><span class="line">    console.log(this);</span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;</span><br><span class="line">person();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;output</span><br><span class="line">window</span><br><span class="line">x1</span><br></pre></td></tr></table></figure>

<p>如上，全局对象window调用了person方法，故this指向全局对象window。故person内的this也指向window，故name为window的一个属性。</p>
<ol start="2">
<li>作为方法调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;xx&quot;;</span><br><span class="line">var person&#x3D;&#123;</span><br><span class="line">    name: &quot;yy&quot;,</span><br><span class="line">    showName:function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.showName();&#x2F;&#x2F;输出yy</span><br><span class="line">var showNameA &#x3D; person.showName;</span><br><span class="line">showNameA();&#x2F;&#x2F;输出xx</span><br></pre></td></tr></table></figure>

<p>person.showName()明显为person调用showName方法，故this指向person，输出yy</p>
<p>而showNameA = person.showName时，showNameA相当于window的一个属性，将person.showName赋值给他，故调用showNameA时，是相当于window.showNameA。故this指向window，输出xx</p>
<ol start="3">
<li>作为构造函数调用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">var personA &#x3D; Person(&quot;xx&quot;);</span><br><span class="line">console.log(personA.name);&#x2F;&#x2F;undefined;</span><br><span class="line">console.log(window.name);&#x2F;&#x2F;xx</span><br></pre></td></tr></table></figure>

<p>personA.name即window.personA.name，可见上述代码并没有定义此属性，故输出undefined；</p>
<p>而window.name。在personA赋值时，调用了window.Person(“xx”)，此时将window的name赋值为xx。故输出window.name即为xx</p>
<ol start="4">
<li>new</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">var personB &#x3D; new Person(&quot;xx&quot;);</span><br><span class="line">console.log(personB.name);</span><br></pre></td></tr></table></figure>

<p>new操作符实例化对象的内部过程为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function person(name)&#123;</span><br><span class="line">    var o &#x3D; &#123;&#125;;</span><br><span class="line">    o._proto_ &#x3D; Person.prototype;</span><br><span class="line">    Person.call(o,name);</span><br><span class="line">    return o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可得，当使用new操作符实例化对象，首先创建一个新的对象，并将新对象的proto指向Person的prototype完成对原型属性和方法的继承。再通过使用call方法，将this的指向从Person改为新对象，并完成o.name = name;</p>
<p>此时使用new Person(“xx”)；即将this指向personB，并赋值personB.name = “xx”;<br>故输出personB.name时，输出xx</p>
<ol start="5">
<li>call/apply方法调用</li>
</ol>
<p>call/apply方法最大的作用是改变this的指向，且都属于Function.prototype的一个方法。但他们的区别在于传递的参数不同，call传递函数运行作用域(this)和所有的参数序列(必须列举出来)，apply传递函数运行作用域(this)和参数数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;xx&quot;;</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name : &quot;yy&quot;,</span><br><span class="line">    showName:function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;call方法第一个参数函数运行作用域为空，则指向默认值window</span><br><span class="line">Person.showName.call();&#x2F;&#x2F;输出window.name，即xx</span><br><span class="line"></span><br><span class="line">funtion FruitA(n1,n2)&#123;</span><br><span class="line">    this.n1&#x3D;n1;</span><br><span class="line">    this.n2&#x3D;n2;</span><br><span class="line">    this.change&#x3D;function(x,y)&#123;</span><br><span class="line">        this.n1&#x3D;x;</span><br><span class="line">        this.n2&#x3D;y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fruitA&#x3D;new FruitA(&quot;cheery&quot;,&quot;banana&quot;);</span><br><span class="line">var FruitB&#x3D;&#123;</span><br><span class="line">    n1:&quot;apple&quot;,</span><br><span class="line">    n2:&quot;orange&quot;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;将fruitA的change方法this指向FruitB，故设置FruitB.n1 &#x3D; pear;FruitB.n2 &#x3D; peach;</span><br><span class="line">fruitA.change.call(FruitB,&quot;pear&quot;,&quot;peach&quot;);</span><br><span class="line"></span><br><span class="line">console.log(FruitB.n1); &#x2F;&#x2F;输出 pear</span><br><span class="line">console.log(FruitB.n2);&#x2F;&#x2F; 输出 peach</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>bind方法</li>
</ol>
<p>bind方法也是用来改变函数的this指向，且利用后续参数传参。但它与call/apply的区别为：bind方法不会立即执行，即它返回的是一个函数，执行时需要使用()调用，或将其绑定到事件上，通过事件触发调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fruitA.change.bind(FruitB,&quot;pear&quot;,&quot;peach&quot;)();</span><br><span class="line">document.onclick &#x3D; fruitA.change.bind(FruitB,&quot;pear&quot;,&quot;peach&quot;);</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>eval方法</li>
</ol>
<p>eval方法执行，this绑定到当前作用域的对象上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &quot;xx&quot;;</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">    name: &quot;yy&quot;;</span><br><span class="line">    showName:function()&#123;</span><br><span class="line">        eval(&quot;console.log(this.name&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">person.showName();&#x2F;&#x2F;输出yy</span><br><span class="line">var a &#x3D; person.showName;</span><br><span class="line">a();&#x2F;&#x2F;即window.a，则this指向window，输出xx</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>箭头函数</li>
</ol>
<p>箭头函数中this始终指向外部对象，且自身没有this，故自身不能new实例化，也不能使用call/apply/bind等方法来改变this指向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function timer()&#123;</span><br><span class="line">    this.seconds &#x3D; 0;</span><br><span class="line">    setInterval(() &#x3D;&gt; this.seconds ++, 1000);&#x2F;&#x2F;this指向外部对象，即实例化timer后的timer1的seconds，每秒+1</span><br><span class="line">&#125;</span><br><span class="line">var timer1 &#x3D; new timer();</span><br><span class="line">setTimeout(() &#x3D;&gt; console.log(timer1.seconds),3100);&#x2F;&#x2F;3s后输出timer1.seconds即3</span><br></pre></td></tr></table></figure>

<h2 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h2><ol>
<li><p>优化DOM：</p>
<ul>
<li>删除不必要的代码和注释，最小化文件</li>
<li>利用GZIP压缩文件</li>
<li>结合HTTP缓存文件</li>
</ul>
</li>
<li><p>图片懒加载，避免一次性加载过多文件导致请求阻塞</p>
</li>
<li><p>减少HTTP请求数量</p>
<ul>
<li><p>文件合并，图片压缩</p>
</li>
<li><p>减少重定向</p>
</li>
</ul>
</li>
<li><p>优化网络连接：使用CDN，将用户请求导向离用户最近的服务节点上</p>
</li>
<li><p>优化资源加载</p>
<ul>
<li><p>优化资源加载位置，即CSS放在head，先外链再内页，JS文件放在body底部，先外链再内页</p>
</li>
<li><p>模块按需加载。</p>
</li>
</ul>
</li>
<li><p>减少重绘回流</p>
<blockquote>
<p>重绘：页面中样式改变不影响它在文档流中的位置，如color/visibility等，浏览器将新样式赋予元素并重新绘制</p>
</blockquote>
<blockquote>
<p>回流：当render tree中部分或全部元素尺寸/结构等属性改变，浏览器需要重新渲染部分或全部文档的过程</p>
</blockquote>
<ul>
<li><p>避免使用层次较深的选择器，避免使用css表达式，元素适当定义高度等</p>
</li>
<li><p>使用防抖或节流限制某方法的频繁触发</p>
<blockquote>
<p>防抖debounce：频繁触发的情况下，只要有足够的空闲时间才执行代码一次</p>
</blockquote>
<blockquote>
<p>节流：一定时间内js方法只跑一次</p>
</blockquote>
</li>
<li><p>及时清理环境</p>
</li>
</ul>
</li>
<li><p>webpack优化</p>
<ul>
<li><p>打包公共代码</p>
</li>
<li><p>动态导入，按需加载</p>
</li>
<li><p>删除无用代码</p>
</li>
</ul>
</li>
</ol>
<h2 id="CSS居中-行内-块级"><a href="#CSS居中-行内-块级" class="headerlink" title="CSS居中(行内/块级)"></a>CSS居中(行内/块级)</h2><h3 id="水平"><a href="#水平" class="headerlink" title="水平"></a>水平</h3><ol>
<li>行内</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父级元素</span><br><span class="line">display: block;&#x2F;&#x2F;设置为块级</span><br><span class="line">text-align: center;&#x2F;&#x2F;设置行内水平居中</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>块级元素</p>
<ul>
<li><p>宽度固定: <code>margin: 0 auto;</code></p>
</li>
<li><p>不定宽度:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;方法1</span><br><span class="line">    &#x2F;&#x2F;子元素</span><br><span class="line">    display:inline-block&#x2F;inline;&#x2F;&#x2F;改为行内块级元素&#x2F;行内元素</span><br><span class="line">    &#x2F;&#x2F;父元素</span><br><span class="line">    text-align: center;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方法2</span><br><span class="line">    transform: translateX(-50%);&#x2F;&#x2F;在x轴位移50%</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方法3</span><br><span class="line">    &#x2F;&#x2F;父元素</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">    &#96;&#96;&#96; </span><br><span class="line">### 垂直</span><br><span class="line"></span><br><span class="line">1. 行内</span><br><span class="line"></span><br><span class="line">    - 单行：设置行高&#x3D;盒子高，即父元素和子元素height相等</span><br><span class="line"></span><br><span class="line">    - 多行：设置&#96;&#96;&#96;display:table-cell;vertical-align:middle;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>块级</p>
<ul>
<li><p>position: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父元素</span><br><span class="line">position: relative;</span><br><span class="line">&#x2F;&#x2F;子元素</span><br><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex：<code>display: flex; align-items: center;</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="垂直水平"><a href="#垂直水平" class="headerlink" title="垂直水平"></a>垂直水平</h3><ol>
<li>已知高宽</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父元素</span><br><span class="line">position: relative;</span><br><span class="line">&#x2F;&#x2F;子元素</span><br><span class="line">position: absolute;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>未知高宽</p>
<ul>
<li><p>定位属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父元素</span><br><span class="line">position: relative;</span><br><span class="line">&#x2F;&#x2F;子元素</span><br><span class="line">position: absolute;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">transform: translateX(-50%) translateY(-50%);</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="闭包的理解及优缺点"><a href="#闭包的理解及优缺点" class="headerlink" title="闭包的理解及优缺点"></a>闭包的理解及优缺点</h2><p>闭包指有权访问另一个函数作用域中的变量的函数。可以在函数外部访问到函数内部的局部变量，且这些变量始终保存在内存中，不会随函数的结束而自动销毁</p>
<ul>
<li><p>优点</p>
<ol>
<li><p>保护函数内变量安全</p>
</li>
<li><p>内存中保存变量，可以做缓存</p>
</li>
<li><p>匿名自执行函数可以减少内存消耗</p>
</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li><p>被引用的私有变量不能被销毁，增大了内存消耗</p>
</li>
<li><p>闭包涉及跨域访问，导致性能损失</p>
</li>
</ol>
</li>
</ul>
<h2 id="position配置的相对元素"><a href="#position配置的相对元素" class="headerlink" title="position配置的相对元素"></a>position配置的相对元素</h2><ul>
<li><p>absolute：相对父级元素</p>
</li>
<li><p>relative：相对默认位置</p>
</li>
<li><p>fixed：相对浏览器窗口</p>
</li>
<li><p>static：默认位置</p>
</li>
</ul>
<h2 id="git常用操作"><a href="#git常用操作" class="headerlink" title="git常用操作"></a>git常用操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config -global user.name &lt;name&gt; #设置提交者名字</span><br><span class="line">$ git config -global user.email &lt;email&gt; #设置提交者邮箱</span><br><span class="line">$ git config -global core.editor &lt;editor&gt; #设置默认文本编辑器</span><br><span class="line">$ git config -global merge.tool &lt;tool&gt; #设置解决合并冲突时差异分析工具</span><br><span class="line">$ git config -list #检查已有的配置信息</span><br><span class="line">$ git clone &lt;url&gt; #克隆远程版本库        </span><br><span class="line">$ git init #初始化本地版本库</span><br><span class="line"></span><br><span class="line">$ git add . #添加所有改动过的文件</span><br><span class="line">$ git add &lt;file&gt; #添加指定的文件</span><br><span class="line">$ git mv &lt;old&gt; &lt;new&gt; #文件重命名</span><br><span class="line">$ git rm &lt;file&gt; #删除文件</span><br><span class="line">$ git rm -cached &lt;file&gt; #停止跟踪文件但不删除</span><br><span class="line">$ git commit -m &lt;file&gt; # 提交指定文件</span><br><span class="line">$ git commit -m “commit message” #提交所有更新过的文件</span><br><span class="line">$ git commit -amend # 修改最后一次提交</span><br><span class="line">$ git commit -C HEAD -a -amend #增补提交（不会产生新的提交历史纪录）</span><br><span class="line"></span><br><span class="line">$ git reset -hard HEAD #撤消工作目录中所有未提交文件的修改内容  比如删除也可以撤销</span><br><span class="line">$ git checkout HEAD &lt;file1&gt; &lt;file2&gt; #撤消指定的未提交文件的修改内容</span><br><span class="line">$ git checkout HEAD. #撤消所有文件</span><br><span class="line">$ git revert &lt;commit&gt; #撤消指定的提交</span><br><span class="line"></span><br><span class="line">$ git log #查看提交历史</span><br><span class="line">$ git branch -v #每个分支最后的提交</span><br><span class="line">$ git status #查看当前状态</span><br><span class="line">$ git diff #查看变更内容</span><br><span class="line"></span><br><span class="line">$ git branch #显示所有本地分支</span><br><span class="line">$ git checkout &lt;branch&#x2F;tagname&gt; #切换到指定分支或标签</span><br><span class="line">$ git branch &lt;new-branch&gt; #创建新分支</span><br><span class="line">$ git branch -d &lt;branch&gt; #删除本地分支</span><br><span class="line">$ git tag #列出所有本地标签</span><br><span class="line">$ git tag &lt;tagname&gt; #基于最新提交创建标签</span><br><span class="line">$ git tag -d &lt;tagname&gt; #删除标签</span><br><span class="line"></span><br><span class="line">$ git merge &lt;branch&gt; #合并指定分支到当前分支</span><br><span class="line">$ git rebase &lt;branch&gt; #衍合指定分支到当前分支</span><br><span class="line"></span><br><span class="line">$ git fetch &lt;remote&gt; #从远程库获取代码</span><br><span class="line">$ git pull &lt;remote&gt; &lt;branch&gt; #下载代码及快速合并</span><br><span class="line">$ git push &lt;remote&gt; &lt;branch&gt; #上传代码及快速合并</span><br><span class="line">$ git push &lt;remote&gt; : &lt;branch&gt;&#x2F;&lt;tagname&gt; #删除远程分支或标签</span><br><span class="line">$ git push -tags #上传所有标签</span><br></pre></td></tr></table></figure>

<h2 id="js原生以class获取元素更改样式"><a href="#js原生以class获取元素更改样式" class="headerlink" title="js原生以class获取元素更改样式"></a>js原生以class获取元素更改样式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getByClass(oParent, sClass)&#123;</span><br><span class="line">    var aResult&#x3D;[];</span><br><span class="line">    var aEle&#x3D;oParent.getElementsByTagName(&#39;*&#39;);</span><br><span class="line">    </span><br><span class="line">    for(var i&#x3D;0;i&lt;aEle.length;i++)&#123;</span><br><span class="line">        if(aEle[i].className&#x3D;&#x3D;sClass)</span><br><span class="line">        &#123;</span><br><span class="line">            aResult.push(aEle[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return aResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用法如下</span><br><span class="line">window.onload&#x3D;function ()&#123;</span><br><span class="line">    var oUl&#x3D;document.getElementById(&#39;ul1&#39;);</span><br><span class="line">    var aBox&#x3D;getByClass(oUl, &#39;box&#39;);</span><br><span class="line">    </span><br><span class="line">    for(var i&#x3D;0;i&lt;aBox.length;i++)&#123;</span><br><span class="line">        aBox[i].style.background&#x3D;&#39;red&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="java-js类的区别"><a href="#java-js类的区别" class="headerlink" title="java/js类的区别"></a>java/js类的区别</h2><ol>
<li><p>java面向对象， 有继承/封装/多态</p>
</li>
<li><p>js基于对象，没有继承/封装/多态，js的继承通过原型链或娶她方法实现</p>
</li>
<li><p>java类不可以直接运行，js的可以直接调用运行</p>
</li>
</ol>
<h2 id="前后端分离实现"><a href="#前后端分离实现" class="headerlink" title="前后端分离实现"></a>前后端分离实现</h2><p>核心思想：前端html页面通过ajax调用后端的restuful api接口并使用json数据进行交互。</p>
<p>涉及到的内容：</p>
<ol>
<li><p>技术选型</p>
</li>
<li><p>搭建框架</p>
</li>
<li><p>设计接口和数据模型</p>
</li>
<li><p>解决跨域</p>
</li>
<li><p>数据存储和部署</p>
</li>
</ol>
<h2 id="浏览器隐身模式"><a href="#浏览器隐身模式" class="headerlink" title="浏览器隐身模式"></a>浏览器隐身模式</h2><p>浏览器隐身模式时，不会保存浏览记录/cookie/网站数据/表单信息。即浏览网页时存储在本地的数据。</p>
<h2 id="jquery和Vue异同"><a href="#jquery和Vue异同" class="headerlink" title="jquery和Vue异同"></a>jquery和Vue异同</h2><ol>
<li><p>jquery首先需要获取dom对象，在对对象进行各项操作</p>
</li>
<li><p>vue首先将值和js对象绑定，修改js对象的值，vue自动把dom值更新。即通过vue对象将数据和view分离，实现相互绑定</p>
</li>
</ol>
<h2 id="jquery和原生js异同"><a href="#jquery和原生js异同" class="headerlink" title="jquery和原生js异同"></a>jquery和原生js异同</h2><ol>
<li><p>原生js会等到dom元素加载完毕且图片加载完毕后再执行，jquery会等到dom加载完成但不会等图片加载完成</p>
</li>
<li><p>jquery可以写多个入口函数你，原生js不行</p>
</li>
</ol>
<h2 id="echart如何实现和Vue的响应"><a href="#echart如何实现和Vue的响应" class="headerlink" title="echart如何实现和Vue的响应"></a>echart如何实现和Vue的响应</h2><p>使用Vue中的<code>watch</code>监测数据变化，当数据更新后，调用<code>echarts</code>中图表的绘制方法即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    all(curVal) &#123;</span><br><span class="line">    &#x2F;&#x2F; 数据发生改变，便调用图表绘制方法传入最新数据绘制</span><br><span class="line">      this.drawLine(curVal.counts, curVal.days);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="手写call-bind-apply"><a href="#手写call-bind-apply" class="headerlink" title="手写call/bind/apply"></a>手写call/bind/apply</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function call(context)&#123;</span><br><span class="line">    context &#x3D; context || window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    const args &#x3D; Array.from(arguments).slice(1);</span><br><span class="line">    const res &#x3D; argument.length &gt; 1 ? context.fn(...args):context.fn;</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function apply(context)&#123;</span><br><span class="line">    context &#x3D; context || window;</span><br><span class="line">    context.fn &#x3D; this;</span><br><span class="line">    const res &#x3D; arguments[1]? context.fn(...arguments[1]) : context.fn();</span><br><span class="line">    delete context.fn;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>将新的this绑定到某函数func上，并返回func的拷贝</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bind(context,...args)&#123;</span><br><span class="line">    const fn &#x3D; this;&#x2F;&#x2F;调用bind的函数func</span><br><span class="line">    return function(...args)&#123;</span><br><span class="line">        return fn.apply(context,...args.concat(...args2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;另一种</span><br><span class="line">function bind(context)&#123;</span><br><span class="line">	console cxt &#x3D; JSOn.parse(JSON.stringify(context)) || window;</span><br><span class="line">	cxt.func &#x3D; this;</span><br><span class="line">	const args &#x3D; Array.from(arguments).slice(1);</span><br><span class="line">	return function()&#123;</span><br><span class="line">		const allArgs &#x3D; args.concat(Array.from(arguments));</span><br><span class="line">		return allArgs.length &gt; 0 ? cxt.func(...allArgs):cxt.func();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h2><h3 id="Promise特征："><a href="#Promise特征：" class="headerlink" title="Promise特征："></a>Promise特征：</h3><ol>
<li><p>三个状态: <code>pending</code>/<code>fulfilled</code>/<code>rejected</code>。状态默认为<code>pending</code>，且只能从<code>pending</code>到<code>fulfilled</code>或从<code>pending</code>到<code>rejected</code>，一旦确认不会再改变</p>
</li>
<li><p>new promise时，需要传递<code>executor()</code>执行器，执行器立刻执行。<code>executor</code>接收两个参数，分别是<code>resolve</code>/<code>reject</code></p>
</li>
<li><p>promise使用<code>value</code>保存成功状态的值，可以是<code>undefined</code>/<code>thenable</code>/<code>promise</code>。</p>
</li>
<li><p>promise使用<code>reason</code>保存失败状态的值</p>
</li>
<li><p>promise必须有一个<code>then</code>方法，接收两个参数，分别是成功回调<code>onFulfilled</code>和失败回调<code>onRejected</code></p>
</li>
<li><p>调用<code>then</code>，promise成功，则执行<code>onFulfilled</code>，参数为promise的<code>value</code>。promise失败，则执行<code>onRejected</code>，参数为promise的<code>reason</code>。</p>
</li>
<li><p>若<code>then</code>中抛出异常，则将异常作为参数，传递给下一个<code>then</code>失败回调<code>onRejected</code></p>
</li>
</ol>
<h3 id="promise原理及基础版代码（无链式调用和值穿透）"><a href="#promise原理及基础版代码（无链式调用和值穿透）" class="headerlink" title="promise原理及基础版代码（无链式调用和值穿透）"></a>promise原理及基础版代码（无链式调用和值穿透）</h3><p>原理：发布订阅者模式，通过两个队列缓存成功的回调和失败的回调。当执行函数executor执行时，触发resolve和reject，依次调用成功或失败的回调函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PENDING &#x3D; &quot;PENDING&quot;;</span><br><span class="line">const FULFILLED &#x3D; &quot;FULFILLED&quot;;</span><br><span class="line">const REJECTED &#x3D; &quot;REJECTED&quot;;</span><br><span class="line"></span><br><span class="line">class Promise&#123;</span><br><span class="line">    constructor(executor)&#123;</span><br><span class="line">        &#x2F;&#x2F;默认状态为pending</span><br><span class="line">        this.status &#x3D; PENDING；</span><br><span class="line">        &#x2F;&#x2F;存放成功状态值</span><br><span class="line">        this.value &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F;存放失败状态值</span><br><span class="line">        this.reason &#x3D; undefined;</span><br><span class="line">        &#x2F;&#x2F;存放成功回调</span><br><span class="line">        this.onResolvedCallbacks &#x3D; [];</span><br><span class="line">        &#x2F;&#x2F;存放失败回调</span><br><span class="line">        this.onRejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;成功方法</span><br><span class="line">        let resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if(value instanceof Promise)&#123;</span><br><span class="line">                return value.then(resolve,reject);</span><br><span class="line">            &#125;</span><br><span class="line">            setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">                if(this.status &#x3D;&#x3D;&#x3D; PENDING)&#123;</span><br><span class="line">                    &#x2F;&#x2F;状态置为成功</span><br><span class="line">                    this.status &#x3D; FULFILLED;</span><br><span class="line">                    this.value &#x3D; value;</span><br><span class="line">                    &#x2F;&#x2F;依次执行成功回调函数</span><br><span class="line">                    this.onResolvedCallbacks.forEach(fn&#x3D;&gt;fn());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;失败方法</span><br><span class="line">        let reject &#x3D; (reason)&#x3D;&gt;&#123;</span><br><span class="line">            setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">                if(this.status &#x3D;&#x3D;&#x3D; PENDING)&#123;</span><br><span class="line">                    &#x2F;&#x2F;状态置为失败</span><br><span class="line">                    this.status &#x3D; REJECTED;</span><br><span class="line">                    this.reason &#x3D; reason;</span><br><span class="line">                    &#x2F;&#x2F;依次执行失败回调函数</span><br><span class="line">                    this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try&#123;</span><br><span class="line">            &#x2F;&#x2F;立即执行executor方法，将resolve和reject传递出去</span><br><span class="line">            executor(resolve,reject);</span><br><span class="line">        &#125;catch(error)&#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;then方法</span><br><span class="line">        then(onFulfilled,onRejected)&#123;</span><br><span class="line">            if(this.status &#x3D;&#x3D;&#x3D; FULFILLED)&#123;</span><br><span class="line">                &#x2F;&#x2F;链式调用</span><br><span class="line">                return fulfillPromise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">                        try&#123;</span><br><span class="line">                            let result &#x3D; onFulfilled(this.value);</span><br><span class="line">                            resolve(result);</span><br><span class="line">                        &#125;catch(e)&#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                &#x2F;&#x2F;调用成功的回调函数</span><br><span class="line">                &#x2F;&#x2F;onFulfilled(this.value);</span><br><span class="line">            &#125;</span><br><span class="line">            if(this.status &#x3D;&#x3D;&#x3D; REJECTED)&#123;</span><br><span class="line">                return rejectPromise &#x3D; new Promise((resolve,reject) &#x3D;&gt; &#123;</span><br><span class="line">                    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">                        try&#123;</span><br><span class="line">                            let result &#x3D; onRejected(this.reason);</span><br><span class="line">                            resolve(result);</span><br><span class="line">                        &#125;catch(e)&#123;</span><br><span class="line">                            reject(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">                &#x2F;&#x2F;调用失败的回调函数</span><br><span class="line">                &#x2F;&#x2F;onRejected(this.reason);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;若状态为pendig，依次将成功&#x2F;失败回调函数存放起来</span><br><span class="line">            if(this.status&#x3D;&#x3D;&#x3D; PENDING)&#123;</span><br><span class="line">                this.onResolvedCallbacks.push(()&#x3D;&gt;&#123;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        let result &#x3D; onFulfilled(this.value);</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;catch(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;);</span><br><span class="line">                this.onRejectedCallbacks.push(()&#x3D;&gt;&#123;</span><br><span class="line">                    try&#123;</span><br><span class="line">                        let result &#x3D; onRejected(this.reason);</span><br><span class="line">                        resolve(result);</span><br><span class="line">                    &#125;catch(e)&#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all"></a>promise.all</h3><blockquote>
<p>promise.all解决并发问题，多个异步并发获取最终的结果 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.all &#x3D; function(values)&#123;</span><br><span class="line">    if(!Array.isArray(values))&#123;</span><br><span class="line">        const type &#x3D; typeof values;</span><br><span class="line">        return new TypeError(&#96;TypeError: $&#123;type&#125; $&#123;values&#125; is not iterable&#96;);</span><br><span class="line">    &#125;</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        let resultArr&#x3D;[];</span><br><span class="line">        let orderIndex &#x3D; 0;</span><br><span class="line">        const processResultByKey &#x3D; (value,index)&#x3D;&gt;&#123;</span><br><span class="line">            resultArr[index] &#x3D; value;</span><br><span class="line">            &#x2F;&#x2F;若当前顺序与结果数量一致，则输出最终结果</span><br><span class="line">            if(++orderIndex &#x3D;&#x3D;&#x3D; values.length)&#123;</span><br><span class="line">                resolve(resultArr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(let i &#x3D; 0;i&lt;value.length;i++)&#123;</span><br><span class="line">            let value &#x3D; value[i];</span><br><span class="line">            if(value &amp;&amp; typeof value.then &#x3D;&#x3D;&#x3D; &quot;function&quot;)&#123;</span><br><span class="line">                value.then((value)&#x3D;&gt;&#123;</span><br><span class="line">                    processResultByKey(value,i);</span><br><span class="line">                &#125;,reject);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                processResultByKey(value,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="promise-race"><a href="#promise-race" class="headerlink" title="promise.race()"></a>promise.race()</h3><blockquote>
<p>promise.race用来处理多个请求，哪个请求最先完成先用哪个</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.race &#x3D; function(promises)&#123;</span><br><span class="line">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        for(let i &#x3D; 0;i&lt;promises.length;i++)&#123;</span><br><span class="line">            let val &#x3D; promises[i];</span><br><span class="line">            if(val &amp;&amp; typeof val.then &#x3D;&#x3D;&#x3D; &quot;function&quot;)&#123;</span><br><span class="line">                val.then(resolve,reject);</span><br><span class="line">            &#125;else&#123;&#x2F;&#x2F;普通值</span><br><span class="line">                resolve(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubble(arr)&#123;</span><br><span class="line">    for(let i &#x3D; 0;i&lt;arr.length -1;i++)&#123;</span><br><span class="line">        for(let j &#x3D; 0; j&lt;arr.length - 1- i;j++)&#123;</span><br><span class="line">            if(arr[j]&gt;arr[j+1])</span><br><span class="line">                [arr[j],arr[j+1]] &#x3D; [arr[j+1],arr[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度On2</p>
<h4 id="优化（有序数组冒泡排序）"><a href="#优化（有序数组冒泡排序）" class="headerlink" title="优化（有序数组冒泡排序）"></a>优化（有序数组冒泡排序）</h4><p>设置标识位，若没有发生交换，则说明有序，不需要排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubble(arr)&#123;</span><br><span class="line">    let flag &#x3D; true;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; arr.length-1;i++)&#123;</span><br><span class="line">        for(let j&#x3D;0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">            if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                flag &#x3D; false;</span><br><span class="line">                [arr[j],arr[j+1]] &#x3D; [arr[j+1],arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优化（部分有序）"><a href="#优化（部分有序）" class="headerlink" title="优化（部分有序）"></a>优化（部分有序）</h4><p>设置变量记录有序的部分，则每次冒泡到此就不继续排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [3,2,1,4,5,6]</span><br><span class="line">function bubble(arr)&#123;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; arr.length-1;i++)&#123;</span><br><span class="line">        let len &#x3D; arr.length -1-i;</span><br><span class="line">        let pos &#x3D; -1;&#x2F;&#x2F;记录有序的下标</span><br><span class="line">        for(let j&#x3D;0;j&lt;arr.length-1-i;j++)&#123;</span><br><span class="line">            if(arr[j]&gt;arr[j+1])&#123;</span><br><span class="line">                pos &#x3D; j;</span><br><span class="line">                [arr[j],arr[j+1]] &#x3D; [arr[j+1],arr[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        len &#x3D; pos;</span><br><span class="line">        if(pos &#x3D;&#x3D; -1)&#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>时间复杂度O(nlogn)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quicksort(arr)&#123;</span><br><span class="line">    let mid &#x3D; Math.floor(arr.length &#x2F; 2);</span><br><span class="line">    let middle &#x3D; arr.splice(mid,1)[0];</span><br><span class="line">    let left,right &#x3D; [];</span><br><span class="line">    for(let i&#x3D;0;i&lt;a.length -1;i++)&#123;</span><br><span class="line">        if(arr[i] &gt; middle)</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        else</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return quicksort(left).concat([mid],quicksort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>时间复杂度O(nlogn)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function mergesort(arr)&#123;</span><br><span class="line">    function merge(a,b)&#123;</span><br><span class="line">        let left,right &#x3D; 0;</span><br><span class="line">        let result &#x3D; [];</span><br><span class="line">        while(left &lt; a.length &amp;&amp; right &lt; b.length)&#123;</span><br><span class="line">            if(a[left] &lt; b[right])&#123;</span><br><span class="line">                result.push(a[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.push(b[right]);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while(left &lt; a.length)&#123;</span><br><span class="line">            result.push(a[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        while(right &lt; b.length)&#123;</span><br><span class="line">            result.push(b[right]);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function mergeArr(arr)&#123;</span><br><span class="line">        if(arr.length &#x3D;&#x3D;&#x3D; 1)</span><br><span class="line">            return arr;</span><br><span class="line">        let mid &#x3D; Math.floor(arr.length &#x2F; 2);</span><br><span class="line">        let left &#x3D; arr.slice(0,mid);</span><br><span class="line">        let right &#x3D; arr.slice(mid,arr.length);</span><br><span class="line">        return merge(mergeArr(left),mergeArr(right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树算法"><a href="#树算法" class="headerlink" title="树算法"></a>树算法</h2><h2 id="webpack原理"><a href="#webpack原理" class="headerlink" title="webpack原理"></a>webpack原理</h2><ol>
<li><p>初始化参数</p>
</li>
<li><p>根据参数初始化compiler对象，注册所有配置插件，监听webpack构建生命周期的事件节点，执行对象run方法执行编译</p>
</li>
<li><p>通过配置的entry入口解析文件构建语法树</p>
</li>
<li><p>递归调用所有配置的loader对文件进行转换，再找出模块依赖的模块，直到所有入口依赖的文件都经过处理</p>
</li>
<li><p>根据递归得到每个文件的结果，根据entry配置生成代码块chunk</p>
</li>
<li><p>输出所有chunk到文件系统。</p>
</li>
</ol>
<h2 id="webpack两个核心元素及常用Loader，Plugin"><a href="#webpack两个核心元素及常用Loader，Plugin" class="headerlink" title="webpack两个核心元素及常用Loader，Plugin"></a>webpack两个核心元素及常用Loader，Plugin</h2><ol>
<li><p>核心元素</p>
<ul>
<li>compiler对象：类似于webpack的司机，有run-启动编译/newCompilation-创建编译器/emitAsset-处理编译后结果等方法</li>
<li>compilation对象：类似于webpack的发动机，被compiler用来创建新的编译或构建。它能访问所有模块和他们的依赖</li>
</ul>
</li>
<li><p>loader</p>
<ul>
<li>vue-loader：.vue文件加载器</li>
<li>sass-loader：sass&amp;scss文件加载器</li>
<li>postcss-loader：css样式处理工具，自动添加浏览器适配前缀，压缩css样式等</li>
<li>css-loader：css模块加载器</li>
<li>babel-loader：webpack加载器</li>
<li>eslint-loader：代码检查工具</li>
</ul>
</li>
<li><p>plugin</p>
<ul>
<li>html-webpack-plugin：自动引入js资源文件到入口index.html文件</li>
<li>mini-css-extract-plugin：抽离css样式到独立的.css文件</li>
</ul>
</li>
</ol>
<h2 id="webpack中plugin哪个时期触发"><a href="#webpack中plugin哪个时期触发" class="headerlink" title="webpack中plugin哪个时期触发"></a>webpack中plugin哪个时期触发</h2>]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>面经</tag>
        <tag>http</tag>
        <tag>HTML</tag>
        <tag>浏览器</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经总结（五）</title>
    <url>/post/fb0f9f1f.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/94915a58.html">前端面经总结（四）</a></p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>Vue是一个渐进性框架，可以把一个页面分割成多个组件，当其他页面有类似功能时，直接让封装的组件复用。Vue是构建页面的声明式框架，不关心具体实现，只关心图层</p>
<h3 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h3><p>绑定数据并监听数据改变。初始化时使用Object.defineProperty/Proxy（2.0/3.0）重新定义data中属性，当页面使用对应属性时，手机当前组件的watcher，若属性变化则通知相关依赖进行更新操作。</p>
<p>Object.defineProperty缺点</p>
<a id="more"></a>
<ol>
<li><p>无法检测到对象属性的动态添加和删除</p>
</li>
<li><p>无法检测到数组下标和length属性的变更</p>
</li>
</ol>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><p>beforeCreate：在<code>beforeCreated</code>方法中无法访问<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>等属性，只能访问<code>props</code>、<code>attrs</code>、<code>setupState</code>等内容。</p>
</li>
<li><p>created阶段，组件初始化，当组件完成初始化并设置完成后到达此阶段</p>
</li>
<li><p>beforeMount阶段：当组件为第一次渲染时，首先调用生命周期beforeMount方法。生命周期<code>beforeMount</code>在<code>created</code>之后，但两者差别不大，平时可以在这两个生命周期做一些渲染前的准备工作。如网络请求，页面初始数据的操作等</p>
</li>
<li><p>Mount阶段：vue实例挂载到真实DOM上，表示组件渲染工作完成</p>
</li>
<li><p>beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</p>
</li>
<li><p>Updated阶段：虚拟DOM重新渲染和打补丁后调用，组件新的DOM更新</p>
</li>
<li><p>beforeDestroy阶段：实例销毁前调用，常用于销毁定时器，解绑事件</p>
</li>
<li><p>Destroy阶段：实例销毁后调用。</p>
</li>
</ul>
<h3 id="Vue和React区别"><a href="#Vue和React区别" class="headerlink" title="Vue和React区别"></a>Vue和React区别</h3><ul>
<li><p>React整体时函数式思想，把组件设计成纯组件，状态和逻辑通过参数传入，故在react中时单项数据流</p>
</li>
<li><p>Vue是响应式思想，基于数据可变，通过对每个属性建立watcher监听，当属性变化时，响应式的更新</p>
</li>
</ul>
<h3 id="Vuex流程"><a href="#Vuex流程" class="headerlink" title="Vuex流程"></a>Vuex流程</h3><p>一种专为vue使用的状态管理模式，采用集中式存储管理应用所有组件的状态，并通过相应的规则保证状态以一种可预测的方式发生变化</p>
<p>主要包括3个部分</p>
<ul>
<li><p>state：驱动应用的数据源</p>
</li>
<li><p>view：以声明的方式将state映射到视图</p>
</li>
<li><p>actions：响应在view上用户输入导致的变化</p>
</li>
</ul>
<p>流程：</p>
<ol>
<li><p>页面通过mapAction异步提交事件到action。</p>
</li>
<li><p>action通过commit把对应参数同步提交到mutation</p>
</li>
<li><p>mutation修改state中对应的值</p>
</li>
<li><p>通过getter把对应的值传出去</p>
</li>
<li><p>在页面计算属性中通过mapGetter动态获取state中的值</p>
</li>
</ol>
<p>状态和属性</p>
<ul>
<li><p>state：保存共有数据，数据是响应的</p>
</li>
<li><p>getter：对state进行计算操作，主要用来过滤一些数据</p>
</li>
<li><p>mutations：定义方法动态修改state中的数据，通过commit提交方法，方法必须是同步的</p>
</li>
<li><p>actions：将mutations里的处理数据的方法变成异步的，即异步操作数据</p>
</li>
<li><p>modules：模块化vuex</p>
</li>
</ul>
<p>若没有vuex发生的情况</p>
<ol>
<li><p>遇到多个组件共享状态时，传参的方法对于多层嵌套的组件会很繁琐，且对兄弟组件件的状态传递无能为力。</p>
</li>
<li><p>当不同视图的行为需要变更同一个状态时，通过采用父子组件直接引用或通过事件来变更和同步状态的多份拷贝会导致很多无法维护的代码</p>
</li>
</ol>
<h3 id="vue-router路由的两种方式"><a href="#vue-router路由的两种方式" class="headerlink" title="vue-router路由的两种方式"></a>vue-router路由的两种方式</h3><p>vue-router是但也应用的路径管理器，用于设定访问路径，并将路由和组件映射起来。</p>
<ol>
<li><p>hash：使用URL的hash来模拟一个完整的URL。改变hash不会重新加载页面。通过hash锚点值的改变渲染指定dom位置的不同数据</p>
</li>
<li><p>history：在配置路由规则时，加入mode：“history”即可。此模式充分利用history.pushState API完成URL跳转且无需重新加载页面。此方式需要在服务端增加一个覆盖所有情况的候选资源，若URL匹配不到任何静态资源，则返回同一个index.html页面。</p>
</li>
</ol>
<h3 id="route和-router区别"><a href="#route和-router区别" class="headerlink" title="$route和$router区别"></a>$route和$router区别</h3><ol>
<li><p>$route是路由信息对象，包括path/params/hash/query/fullPath/matched/name等路由信息参数</p>
</li>
<li><p>$router是路由实例对象，包括了路由的跳转方法，钩子函数等</p>
</li>
</ol>
<h3 id="vue-router守卫"><a href="#vue-router守卫" class="headerlink" title="vue-router守卫"></a>vue-router守卫</h3><ol>
<li><p>全局前置守卫：通过在main.js入口文件定义router.beforeEach</p>
</li>
<li><p>路由独享守卫：在路由配置上直接定义beforeEnter</p>
</li>
<li><p>组件内守卫：在路由组件内直接定义beforeRouterEnter/beforeRouteUpdate等</p>
<ul>
<li><p>to：即将进入的目标（路由对象）</p>
</li>
<li><p>from：当前导航正要离开的路由</p>
</li>
<li><p>next：function。调用该方法来resolve钩子，即通过此函数跳转路由，若不用则拦截，执行效果依赖next方法的调用参数</p>
</li>
</ul>
</li>
</ol>
<h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><p>axios是请求后台资源的模块，通过npm install命令安装</p>
<p>实现登陆功能</p>
<ol>
<li><p>跨域，现在config/index.js文件中设置跨域</p>
</li>
<li><p>js使用import将axios导入，通过.get/.post发送请求，若成功，调用.then函数中内容，若失败，调用.catch函数中内内容</p>
</li>
</ol>
<h3 id="vue项目性能优化"><a href="#vue项目性能优化" class="headerlink" title="vue项目性能优化"></a>vue项目性能优化</h3><ol>
<li><p>模版内不要写太多表达式</p>
</li>
<li><p>虚幻调用子组件时添加key</p>
</li>
<li><p>频繁切换使用v-show，不频繁切换使用v-if</p>
</li>
<li><p>按需加载，用require或import按需加载需要的组件</p>
</li>
<li><p>路由懒加载（用到时再加载）</p>
</li>
</ol>
<h3 id="v-if和v-show区别"><a href="#v-if和v-show区别" class="headerlink" title="v-if和v-show区别"></a>v-if和v-show区别</h3><ol>
<li><p>v-if控制dom节点的存在与否来控制元素的显示；v-show通过设置dom元素的display样式隐藏来控制元素显示</p>
</li>
<li><p>v-if切换有局部编译/卸载的过程，初始条件为假时什么也不做，只有条件第一次为真时才开始局部编译</p>
</li>
<li><p>v-if有更高的切换消耗，v-show有更高的初始渲染消耗</p>
</li>
</ol>
<h3 id="常见的兼容问题"><a href="#常见的兼容问题" class="headerlink" title="常见的兼容问题"></a>常见的兼容问题</h3><p>浏览器默认的margin和padding不同。 解决方案是加一个全局的*{margin:0;padding:0;}来统一。</p>
<h3 id="vue2和vue3区别"><a href="#vue2和vue3区别" class="headerlink" title="vue2和vue3区别"></a>vue2和vue3区别</h3><ol>
<li><p>vue3支持多个根节点，vue2只能有一个根节点</p>
</li>
<li><p>增加组合式api，将相同功能的变量进行集中管理</p>
</li>
<li><p>自定义渲染其，可用于app/小城需和游戏开发</p>
</li>
<li><p>使用ts重写了源码</p>
</li>
<li><p>数据响应重新实现，使用proxy替代了Object.defineProperty</p>
</li>
</ol>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><ol>
<li><p>父子组件</p>
<ul>
<li><p>通过v-bind属性绑定的方式，将data属性的值传给子组件</p>
</li>
<li><p>子组件通过props属性接收父组件传递的数据，该属性的值为数组</p>
</li>
</ul>
</li>
<li><p>兄弟组件</p>
<ul>
<li><p>使用eventBus，穿件VUe实例，使各兄弟公用一个事件机制，传递数据放通过事件触发bus.$emit方法，接收数据方通过mounted触发bus.$on接收数据。</p>
</li>
<li><p>借助父组件，让两个兄弟组件可以联动，子组件A将值传递给父组件，父组件再将值传递给子组件B</p>
</li>
</ul>
</li>
</ol>
<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li><p>Mounting：已插入真实DOM</p>
</li>
<li><p>Updating：正在被重新渲染</p>
</li>
<li><p>Unmounting：已移除真实DOM</p>
</li>
</ul>
<h3 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h3><p>父组件通过props向子组件传值，子组件调用父组件给他的函数给父组件传值</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h3><p>setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列<br>而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值<br>那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="webpack打包体积大"><a href="#webpack打包体积大" class="headerlink" title="webpack打包体积大"></a>webpack打包体积大</h3><ol>
<li><p>异步加载模块</p>
</li>
<li><p>提取第三方库</p>
</li>
<li><p>代码压缩</p>
</li>
<li><p>去除不必要的插件</p>
</li>
</ol>
<h3 id="优化webpack构建性能"><a href="#优化webpack构建性能" class="headerlink" title="优化webpack构建性能"></a>优化webpack构建性能</h3><ol>
<li><p>减少代码体积</p>
</li>
<li><p>减少目录检索范围</p>
</li>
<li><p>减少检索路径</p>
</li>
</ol>
<h3 id="移动端性能优化"><a href="#移动端性能优化" class="headerlink" title="移动端性能优化"></a>移动端性能优化</h3><ol>
<li><p>按需加载，懒加载</p>
</li>
<li><p>资源预加载</p>
</li>
<li><p>图片压缩处理，使用base64内嵌图片</p>
</li>
<li><p>合理缓存dom对象</p>
</li>
<li><p>使用touchstart代替click，减少300ms的延迟</p>
</li>
<li><p>不滥用web字体</p>
</li>
<li><p>尽量使用事件代理，避免直接事件绑定</p>
</li>
<li><p>使用viewport固定屏幕渲染，加速页面渲染内容</p>
</li>
</ol>
<h3 id="vue的spa优化"><a href="#vue的spa优化" class="headerlink" title="vue的spa优化"></a>vue的spa优化</h3><ol>
<li><p>减少入口文件体积</p>
</li>
<li><p>静态资源本地缓存</p>
</li>
<li><p>开启gzip压缩</p>
</li>
</ol>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>尽可能避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输更快更稳定</p>
<p>基本原理是广泛使用各种缓存服务器，将这些缓存服务器分不到用户访问相对的地区或网络中，当用户访问网络时、利用全局负载技术将用户访问指向距离最近的缓存服务器，由该服务器直接响应用户的饿请求</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>面经</tag>
        <tag>http</tag>
        <tag>HTML</tag>
        <tag>浏览器</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经总结（四）</title>
    <url>/post/94915a58.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/23bc433d.html">前端面经总结（三）</a></p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="typeof和instance-of区别"><a href="#typeof和instance-of区别" class="headerlink" title="typeof和instance of区别"></a>typeof和instance of区别</h3><p>二者都用来判断变量是否为空</p>
<ul>
<li><p>typeof返回值为字符串，说明变量的数据类型</p>
</li>
<li><p>instanceof判断变量是否属于某个对象的实例。判断逻辑为从当前引用的proto一层一层顺着原型链向上找，若能找到对应的prototype则返回true</p>
</li>
</ul>
<h3 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝/浅拷贝"></a>深拷贝/浅拷贝</h3><ul>
<li><p>浅拷贝：只是拷贝了基本类型的数据，而引用类型数据，复制后也会发生引用。即浅拷贝仅指向被复制的内存地址，若原地址对象改变，则复制后的对象也相应改变。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用&#x3D;直接赋值</span><br><span class="line">let newArr &#x3D; arr;</span><br><span class="line">&#x2F;&#x2F;使用slice()</span><br><span class="line">let newArr &#x3D; arr.slice();</span><br><span class="line">&#x2F;&#x2F;使用concat()</span><br><span class="line">let newArr &#x3D;  arr.concat();</span><br></pre></td></tr></table></figure>
</li>
<li><p>深拷贝：创建新对象，属性中引用的其他对象也会被克隆，且不再指向原对象地址。使用JSON.parse()/JSON.stringfy()</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用JSON.stringify和JSON.parse</span><br><span class="line">var newArr &#x3D; JSON.parse(JSON.stringify(arr));&#x2F;&#x2F;该方法可以拷贝数组和对象，但不能拷贝函数。对于RegExp类型和Function类型无法完全满足，且不支持有循环引用的对象。</span><br><span class="line">&#x2F;&#x2F;拷贝时判断属性类型</span><br><span class="line">var deepCopy &#x3D; function(obj) &#123;</span><br><span class="line">    &#x2F;&#x2F; 只拷贝对象</span><br><span class="line">    if (typeof obj !&#x3D;&#x3D; &#39;object&#39;) return;</span><br><span class="line">    &#x2F;&#x2F; 根据obj的类型判断是新建一个数组还是一个对象</span><br><span class="line">    var newObj &#x3D; obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">        for (var key in obj) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历obj,并且判断是obj的属性才拷贝</span><br><span class="line">            if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断属性值的类型，如果是对象递归调用深拷贝</span><br><span class="line">                newObj[key] &#x3D; typeof obj[key] &#x3D;&#x3D;&#x3D; &#39;object&#39; ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝用法"><a href="#深拷贝用法" class="headerlink" title="深拷贝用法"></a>深拷贝用法</h4><ol>
<li>解决循环引用</li>
</ol>
<p>使用哈希表存储已拷贝过的对象，再进行循环检测，检测到当前对象已存在于哈希表中则直接取出该值并返回</p>
<ol start="2">
<li>深拷贝只能拷贝一层原型链的属性和方法</li>
</ol>
<h3 id="es6新特性"><a href="#es6新特性" class="headerlink" title="es6新特性"></a>es6新特性</h3><ol>
<li><p>let/const/var</p>
<ul>
<li><p>let：块级作用域，没有变量提升，函数内部使用let后，对函数外部无影响，必须先声明后使用。</p>
</li>
<li><p>const：定义的变量不可修改，必须初始化，块级作用域，没有变量提升</p>
</li>
<li><p>var：定义的变量可以修改，不初始化默认为<code>undefined</code>，不会报错，存在变量提升，不是块级作用域，其声明变量是全局的。</p>
</li>
</ul>
</li>
<li><p>展开运算符…</p>
</li>
<li><p>箭头函数，即匿名函数，不能作为构造函数。</p>
<ul>
<li>和普通函数区别：不能作为构造函数，不能被<code>new</code>，没有<code>arguments</code>实参集合，也没有自己的<code>this</code>，箭头函数的<code>this</code>继承当前上下文中的<code>this</code>，且不能使用<code>call</code>/<code>apply</code>/<code>bind</code>改变<code>this</code></li>
</ul>
</li>
<li><p>模版字面量，即包含嵌入式表达式的字符串字面量，使用倒引号<code>(``)</code></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let message &#x3D; &#96;$&#123;student.name&#125; please see $&#123;teacher.name&#125; in $&#123;teacher.room&#125; to pick up your report card.&#96;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>数组/对象解构，提取值并赋值</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const point &#x3D; [10, 25, -34];</span><br><span class="line">const [x, y, z] &#x3D; point;</span><br><span class="line">console.log(x, y, z);</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>for…of循环，可以循环任何可迭代类型的数据，<code>String</code>/<code>Array</code>/<code>Map</code>/<code>Set</code>，不包含<code>Object</code>，默认情况下对象不可迭代</li>
</ol>
<h3 id="和-区别"><a href="#和-区别" class="headerlink" title="==和===区别"></a>==和===区别</h3><ol>
<li><p>=：赋值</p>
</li>
<li><p>==：返回布尔值，允许不同数据类型的比较，若不同类型先默认转换为相同的数据类型，若为对象比较，则比较空间地址</p>
</li>
<li><p>===：数据和数据类型完全相等</p>
</li>
</ol>
<h3 id="call-bind-apply区别"><a href="#call-bind-apply区别" class="headerlink" title="call/bind/apply区别"></a>call/bind/apply区别</h3><ol>
<li><p>call/apply第一个参数相同，即指定的对象，为该函数的执行上下文</p>
</li>
<li><p>call/apply第二个参数不同，call传入的是所有的参数，apply传入参数的数组</p>
</li>
<li><p>bind返回执行上下文被改变的函数而不会立即执行，call/apply直接执行该函数</p>
</li>
</ol>
<h3 id="js继承方法"><a href="#js继承方法" class="headerlink" title="js继承方法"></a>js继承方法</h3><ol>
<li><p>原型链继承：父类的实例作为子类的原型</p>
</li>
<li><p>构造继承：使用父类的构造函数来继承，相当于复制父类的实例属性给子类</p>
</li>
<li><p>实例继承：为父类实例添加新特性作为子类实例返回</p>
</li>
<li><p>拷贝继承：把父类中的属性或方法复制给子类</p>
</li>
<li><p>组合继承：通过调用父类构造函数，继承父类的属性并保留传参，通过将父类实例作为子类原型实现函数复用，会调用两次父类构造函数，一次创建子类原型，一次子类构造函数内部</p>
</li>
<li><p>寄生组合继承：通过借用构造函数来继承属性，通过原型链的混成形式继承方法。相当于借用构造函数+浅拷贝父类的原型对象，不会初始化两次实例方法和属性</p>
</li>
</ol>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一种特殊的函数，绑定了外部环境变量的函数，允许在一个内层函数中访问到其外层函数的作用域。可以保护变量不受外界污染，一直存在内存中</p>
<h3 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h3><ol>
<li>原型</li>
</ol>
<blockquote>
<p>原型prototype是一个简单的对象，用于实现对象的属性继承，可以理解为对象的父级。</p>
</blockquote>
<p>每个JavaScipt对象包含一个<code>__proto__</code>的属性指向该对象的原型，通过<code>obj.__proto__</code>访问。</p>
<ol start="2">
<li>其他概念</li>
</ol>
<ul>
<li><p>构造函数：通过<code>new</code>新建对象的函数</p>
</li>
<li><p>实例：通过构造函数和<code>new</code>创建的对象，即实例</p>
</li>
</ul>
<p>实例通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建实例</span><br><span class="line">const instance  &#x3D; new Object();&#x2F;&#x2F;Object()为构造函数</span><br><span class="line">&#x2F;&#x2F;原型</span><br><span class="line">const prototype &#x3D; Object.prototype;</span><br></pre></td></tr></table></figure>

<p>由上：</p>
<ul>
<li><p>实例.<strong>proto</strong> = 原型</p>
</li>
<li><p>原型.constructor = 构造函数</p>
</li>
<li><p>构造函数.prototype = 原型</p>
</li>
<li><p>实例.constructor = 构造函数：实例并不真正拥有<code>constructor</code>指针，而是从原型链上获取</p>
</li>
</ul>
<ol start="2">
<li>原型链</li>
</ol>
<p>除<code>null</code>和<code>undefined</code>外，每个对象都有原型，即<code>__proto__</code>属性，指向创建该对象的构造函数的原型。<code>__proto__</code>将对象连接起来组成了原型链，即一个用来实现继承和共享属性的有限的对象链。</p>
<ul>
<li><p>属性查找机制：原型链依赖对象的<code>_proto_</code>指向，当访问对象的成员时，若自身没有，则去原型链指向对象的构造函数的<code>prototype</code>中一层一层找，找到后使用，没找到则返回<code>undefined</code>或报错。</p>
</li>
<li><p>属性修改机制：</p>
<ul>
<li><p>基本数据类型(<code>Number</code>/<code>String</code>/<code>Boolean</code>/<code>Undefined</code>/<code>Null</code>/<code>Symbol</code>)：通过实例对象修改原型属性，不会修改原型对象的属性，若该属性不存在，则<strong>在该实例对象上创建一个同名属性</strong>。</p>
</li>
<li><p>引用类型(<code>Object</code>/<code>Array</code>/…): <code>a.info = {name: &quot;xxx&quot;, age: 18}</code></p>
<ul>
<li><p>整体修改：若通过实例对象<strong>整体修改</strong>引用类型，则不会修改原型对象对应的引用类型，而<strong>在该实例对象创建一个同名属性</strong>。即修改<code>a.info = {name: &quot;xxx&quot;, sex: &quot;girl&quot;}</code></p>
</li>
<li><p>部分修改：若通过实例对象<strong>部分修改</strong>引用类型，即修改该引用类型的属性，则会<strong>直接修改原型上的引用类型</strong>。即修改<code>a.info.age = 20</code>，则原型上的<code>a.__proto__.info = {name: &quot;xxx&quot;, age: 20}</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function A() &#123;</span><br><span class="line">this.name &#x3D; &#39;a&#39;;</span><br><span class="line">this.background &#x3D; &#123; color: &#39;green&#39; &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> function B()&#123;&#125;</span><br><span class="line"></span><br><span class="line"> B.prototype &#x3D; new A();&#x2F;&#x2F;B的原型为A</span><br><span class="line"> var b1 &#x3D; new B();&#x2F;&#x2F;b1为B的实例</span><br><span class="line"> var b2 &#x3D; new B();&#x2F;&#x2F;b2为B的实例</span><br><span class="line"> </span><br><span class="line"> b1.name &#x3D; &#39;change&#39;;&#x2F;&#x2F;仅修改实例b1的属性值，若不存在则添加属性</span><br><span class="line"> b1.background.color &#x3D; &#39;red&#39;;&#x2F;&#x2F;修改实例b1的属性background的属性值color，此时原型A的background也被修改了</span><br><span class="line"></span><br><span class="line">console.log(b1.name);&#x2F;&#x2F;change</span><br><span class="line">console.log(b2.name);&#x2F;&#x2F;b2本身不存在属性name，故到原型链上找，即输出a</span><br><span class="line">console.log(b1. background);&#x2F;&#x2F;&#123;color: &quot;red&quot;&#125;</span><br><span class="line">console.log(b2. background);&#x2F;&#x2F;通过b1部分修改引用类型background的属性，则原型A改变，b2不存在background属性，则到原型链上找，即输出&#123;color: &quot;red&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若实现console.log(b2. background);输出&#123;color: &quot;green&quot;&#125;，则b1如下修改</span><br><span class="line">b1.background &#x3D; &#123;color: &quot;red&quot;&#125;;&#x2F;&#x2F;整体修改b1属性background，b1不存在此属性，故在b1创建同名属性background，不改变原型的属性background</span><br><span class="line">console.log(b1. background);&#x2F;&#x2F;&#123;color: &quot;red&quot;&#125;</span><br><span class="line">console.log(b2. background);&#x2F;&#x2F;&#123;color: &quot;green&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="浏览器渲染的流程"><a href="#浏览器渲染的流程" class="headerlink" title="浏览器渲染的流程"></a>浏览器渲染的流程</h3><ol>
<li><p>将html代码按深度优先比例生成dom树</p>
</li>
<li><p>渲染css文件生成css渲染树</p>
</li>
<li><p>dom树和css渲染树生成render树</p>
</li>
<li><p>浏览器通过render树将所有节点位置计算出来呈现到屏幕上</p>
</li>
</ol>
<h3 id="从输入url到页面发生了什么"><a href="#从输入url到页面发生了什么" class="headerlink" title="从输入url到页面发生了什么"></a>从输入url到页面发生了什么</h3><ol>
<li><p>输入url，浏览器查找当前url是否存在缓存，并比较缓存是否过期</p>
</li>
<li><p>若没有缓存，DNS解析url查找对应IP</p>
</li>
<li><p>根据IP通过三次握手建立TCP连接</p>
</li>
<li><p>HTTP发起请求，服务器处理请求，浏览器接受响应</p>
</li>
<li><p>渲染页面构造DOM树和CSS渲染树</p>
</li>
<li><p>四次挥手关闭TCP连接，浏览器将渲染结果呈现在屏幕上</p>
</li>
</ol>
<h3 id="跨域方法"><a href="#跨域方法" class="headerlink" title="跨域方法"></a>跨域方法</h3><ol>
<li>通过jsonp跨域-只能处理get</li>
</ol>
<p>动态创建<code>script</code>标签，利用<code>script</code>的<code>src</code>不受同源策略限制，故可以请求第三方服务器资源内容</p>
<ol start="2">
<li>document.domain+iframe跨域：仅限主域相同，子域不同的场景</li>
</ol>
<p>两个页面都通过js强者设置document.domain为基础主域实现同域</p>
<ol start="3">
<li>window.name+iframe跨域：name在不同页面加载后依然存在</li>
</ol>
<p>通过<code>iframe</code>的<code>src</code>属性由外域转本地域。跨域数据由<code>iframe</code>的<code>window.name</code>从外域传入本地域</p>
<ol start="4">
<li><p>使用postMessage(data, origin)跨域：html5的新特性</p>
</li>
<li><p>使用CORS跨域资源共享跨域</p>
</li>
</ol>
<p>服务器设置<code>Access-Control-Allow-Origin</code>HTTP响应头后，浏览器允许跨域请求</p>
<ol start="6">
<li><p>使用websocket协议跨域</p>
</li>
<li><p>通过node.js中间件代理跨域：启动一个代理服务器，实现数据的转发。</p>
</li>
</ol>
<h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>一种约定，同源指<code>协议</code>/<code>域名</code>/<code>端口</code>三者相同</p>
<p>限制：</p>
<ol>
<li><p>Cookie/LocalStorage/IndexDB无法读取</p>
</li>
<li><p>DOM和JS对象无法获得</p>
</li>
<li><p>Ajax请求无法发送</p>
</li>
</ol>
<h3 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h3><ol>
<li><p>减少HTTP请求</p>
</li>
<li><p>页面设计时简化页面</p>
</li>
<li><p>合理设置HTTP缓存</p>
</li>
<li><p>资源合并压缩</p>
</li>
<li><p>多图片网页使用图片懒加载</p>
</li>
<li><p>减少DOM操作</p>
</li>
<li><p>JS中避免嵌套循环和死循环</p>
</li>
</ol>
<h3 id="ajax步骤"><a href="#ajax步骤" class="headerlink" title="ajax步骤"></a>ajax步骤</h3><ol>
<li><p>创建ajax实例</p>
</li>
<li><p>执行open确定要访问的连接和同步异步</p>
</li>
<li><p>监听请求状态</p>
</li>
<li><p>发送请求</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">console.log(xhr.readyState);&#x2F;&#x2F;0</span><br><span class="line">xhr.open(&quot;GET&quot;,&quot;.&#x2F;data.json&quot;);</span><br><span class="line">console.log(xhr.readyState);&#x2F;&#x2F;1</span><br><span class="line">xhr.send(null);</span><br><span class="line">console.log(xhr.readyState);&#x2F;&#x2F;1</span><br><span class="line">xhr.onreadystatechange &#x3D; function (res)&#123;</span><br><span class="line">  if(this.readyState &#x3D;&#x3D;&#x3D; 4)</span><br><span class="line">    console.log(xhr.readyState);&#x2F;&#x2F;4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，ajax请求状态有：</p>
<ul>
<li>0：xhr被创建，但没有使用open方法</li>
<li>1：open方法被调用，建立了链接</li>
<li>2：send方法被调用，取得了响应的状态值和响应头</li>
<li>3：响应题正在下载中</li>
<li>4：下载体已经完成，可以直接使用responseText</li>
</ul>
<h3 id="ajax实现"><a href="#ajax实现" class="headerlink" title="ajax实现"></a>ajax实现</h3><ol>
<li>前端</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; import&#x3D;&quot;java.util.*&quot; pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String path &#x3D; request.getContextPath();</span><br><span class="line">String basePath &#x3D; request.getScheme()+&quot;:&#x2F;&#x2F;&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;&#x2F;&quot;;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href&#x3D;&quot;&lt;%&#x3D;basePath%&gt;&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;My JSP &#39;index.jsp&#39; starting page&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;cache-control&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;0&quot;&gt;    </span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;keywords&quot; content&#x3D;&quot;keyword1,keyword2,keyword3&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv&#x3D;&quot;description&quot; content&#x3D;&quot;This is my page&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;styles.css&quot;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">       function TestAjax()&#123;</span><br><span class="line">           var xmlHttp;</span><br><span class="line">           if (window.XMLHttpRequest) &#123;</span><br><span class="line">               xmlHttp &#x3D; new XMLHttpRequest();</span><br><span class="line">               </span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               xmlHttp &#x3D; new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           xmlHttp.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">               if (xmlHttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlHttp.status&#x3D;&#x3D;200) &#123;</span><br><span class="line">                  document.getElementById(&quot;sp&quot;).innerHTML &#x3D; xmlHttp.responseText; </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           xmlHttp.open(&quot;GET&quot;, &quot;TestAjax?name&#x3D;Ouyang&quot;, true);</span><br><span class="line">           xmlHttp.send();</span><br><span class="line">       &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;button onclick&#x3D;&quot;TestAjax()&quot;&gt;利用Ajax获取数据&lt;&#x2F;button&gt; &lt;br&gt;</span><br><span class="line">    &lt;span id &#x3D; &quot;sp&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>后端</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.ajax;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.annotation.WebServlet;</span><br><span class="line">import javax.servlet.http.HttpServlet;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import javax.swing.RepaintManager;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Servlet implementation class TestAjax</span><br><span class="line"> *&#x2F;</span><br><span class="line">@WebServlet(&quot;&#x2F;TestAjax&quot;)</span><br><span class="line">public class TestAjax extends HttpServlet &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 1L;</span><br><span class="line">       </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @see HttpServlet#HttpServlet()</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public TestAjax() &#123;</span><br><span class="line">        super();</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        &#x2F;&#x2F;response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());</span><br><span class="line">        response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">        PrintWriter out &#x3D; response.getWriter();</span><br><span class="line">        out.println(&quot;Hello &quot; + request.getParameter(&quot;name&quot;));</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="移动端兼容"><a href="#移动端兼容" class="headerlink" title="移动端兼容"></a>移动端兼容</h3><ol>
<li><p>设置缓存，手机页面在第一次加载会进行缓存，每次刷新会使用缓存而不会重新向服务器发送请求，不使用缓存设置<code>no-cache</code></p>
</li>
<li><p>添加点击事件时引用fastclick.js文件，解决延迟问题</p>
</li>
<li><p>设置meta中的viewport</p>
</li>
</ol>
<h3 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h3><ul>
<li><p>同步：在同一时间内做一件事</p>
</li>
<li><p>异步：在同一时间内做多件事，常见的异步任务：定时器/ajax/事件绑定/回调函数/async await/promise。实现方式：回调函数/发布订阅/事件绑定/promise</p>
</li>
</ul>
<h4 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h4><blockquote>
<p>异步编程的一种解决方案</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var promise &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line"></span><br><span class="line">    if (&#x2F;* 异步操作成功 *&#x2F;) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>resolve：将Promise对象状态由未完成变为成功，在异步操作成功时调用，将异步操作的结果作为参数传递出去</p>
</li>
<li><p>reject：将Promise对象状态由未完成变为失败，在异步操作失败时调用，传递错误error</p>
</li>
<li><p>then：then方法在Promise实例生成后分别指定两种状态回调函数。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let promise &#x3D; new Promise(function(resolve, reject)&#123;</span><br><span class="line">    console.log(&quot;AAA&quot;);</span><br><span class="line">    resolve()</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(() &#x3D;&gt; console.log(&quot;BBB&quot;));</span><br><span class="line">console.log(&quot;CCC&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AAA</span><br><span class="line">&#x2F;&#x2F; CCC</span><br><span class="line">&#x2F;&#x2F; BBB</span><br></pre></td></tr></table></figure>

<p>Promise优点是可以解决回调/链式调用/减少嵌套。缺点为无法检测进行状态/新建立刻执行且无法取消/内部错误无法抛出。</p>
<h4 id="Promise-all-Promise-race"><a href="#Promise-all-Promise-race" class="headerlink" title="Promise.all/Promise.race"></a>Promise.all/Promise.race</h4><ul>
<li><p>Promise.all：将多个Promise实例包装成一个新的Promise实例，成功时返回结果数组，结果顺序与数组中数据顺序一致，失败时返回最先reject的值</p>
</li>
<li><p>Promise.race：多个Promise哪个结果先到达，则返回此结果，不考虑结果本身成功或失败。</p>
</li>
</ul>
<h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><ul>
<li><p>async：异步，必定返回Promise</p>
</li>
<li><p>await：等待。</p>
<ul>
<li><p>await命令后接Promise对象，返回该对象的结果</p>
</li>
<li><p>await命令后接非Promise对象，返回对应的值</p>
</li>
<li><p>await命令后接thenable对象(定义then方法的对象)，await将其等同于Promise对象</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sleep(ms) &#123;</span><br><span class="line">    return new Promise(function(resolve, reject) &#123;</span><br><span class="line">        setTimeout(resolve,ms);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async function handle()&#123;</span><br><span class="line">    console.log(&quot;AAA&quot;)</span><br><span class="line">    await sleep(5000)</span><br><span class="line">    console.log(&quot;BBB&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handle();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AAA</span><br><span class="line">&#x2F;&#x2F; BBB (5000ms后)</span><br></pre></td></tr></table></figure>

<h3 id="DOM-diff原理"><a href="#DOM-diff原理" class="headerlink" title="DOM diff原理"></a>DOM diff原理</h3><ol>
<li><p>从根节点开始遍历所有节点</p>
</li>
<li><p>对于不同类型的标签，删除原标签，新建标签</p>
</li>
<li><p>对于类型相同属性不同的标签，只修改属性</p>
</li>
<li><p>对于同一个父节点下的复数同类型标签(列表类型)，基于key对比修改</p>
</li>
</ol>
<p>完全的DOM diff算法事件复杂度为O(n3)，Vue中将其简化，只对比同级元素，将时间复杂度降低至O(n)</p>
<h3 id="进程线程"><a href="#进程线程" class="headerlink" title="进程线程"></a>进程线程</h3><ul>
<li><p>进程：并发执行的程序在执行过程中分配和管理资源的基本单位，一个程序至少一个进程</p>
</li>
<li><p>线程：是进程的一个执行单元，处理器调度的基本单位。一个进程至少一个线程。</p>
</li>
</ul>
<p>区别：</p>
<ol>
<li><p>进程之间是独立的地址空间，同一进程的线程共享进程的地址空间</p>
</li>
<li><p>进程之间资源独立，同一进程的线程共享进程的资源</p>
</li>
<li><p>每个独立的进程有一个程序入口，线程不能独立执行，必须依存在程序中</p>
</li>
<li><p>进程是分配和管理资源的基本单位，线程是处理器调度的基本单位</p>
</li>
</ol>
<h3 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h3><ul>
<li><p>宏任务：由Node/浏览器发起的任务，每次从宏任务事件队列中获取一个放入执行栈中执行</p>
<ul>
<li><p>script</p>
</li>
<li><p>setTimeout/setInterval</p>
</li>
<li><p>I/O</p>
</li>
<li><p>UI交互事件</p>
</li>
<li><p>postMessage()</p>
</li>
<li><p>setImmediate: 遇到setTimeout，先于它执行</p>
</li>
</ul>
</li>
<li><p>微任务：由JavaScript发起的任务，当前任务执行后立刻执行，无需等渲染。</p>
<ul>
<li><p>Promise</p>
</li>
<li><p>process.nextTick</p>
</li>
<li><p>Object.observe</p>
</li>
</ul>
</li>
</ul>
<h4 id="代码输出判断"><a href="#代码输出判断" class="headerlink" title="代码输出判断"></a>代码输出判断</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;主线程执行，输出start</span><br><span class="line">console.log(&#39;start&#39;)</span><br><span class="line">&#x2F;&#x2F;宏任务1，放入宏任务队列</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;setTimeout&#39;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">&#x2F;&#x2F;new Promise执行输出Promise</span><br><span class="line">new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;promise&#39;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)&#x2F;&#x2F;then为微任务1，放入微任务队列</span><br><span class="line">  .then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;then1&#39;)</span><br><span class="line">  &#125;)&#x2F;&#x2F;then为微任务2，放入微任务队列</span><br><span class="line">  .then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;then2&#39;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#x2F;&#x2F;输出end</span><br><span class="line">console.log(&#39;end&#39;)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>循环1:start -&gt; promise -&gt; end</p>
</li>
<li><p>执行微任务队列：then1 -&gt; then2</p>
</li>
<li><p>执行宏任务队列：setTimeout</p>
</li>
</ol>
<h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><ol>
<li><p>执行一个宏任务</p>
</li>
<li><p>执行中遇到宏任务，将其放入宏任务队列，遇到微任务，将其放入微任务队列</p>
</li>
<li><p>宏任务执行完毕，立即执行微任务队列中所有微任务</p>
</li>
<li><p>全部微任务执行完毕，检查渲染，完毕后开始下一个宏任务</p>
</li>
</ol>
<h4 id="nextTick作用"><a href="#nextTick作用" class="headerlink" title="$nextTick作用"></a>$nextTick作用</h4><p>vm.$nextTick接受一个回调函数作为参数，用于将回调延迟到下次DOM更新周期(下次微任务执行时更新DOM)后进行，即将回调函数添加到微任务中。</p>
<h3 id="判断变量是对象还是数组"><a href="#判断变量是对象还是数组" class="headerlink" title="判断变量是对象还是数组"></a>判断变量是对象还是数组</h3><p>使用<code>array instanceof Array</code>方法，返回true则为数组，否则对象</p>
<p>不能使用<code>typeof</code>，它判断对象和数组都返回<code>Object</code>，只用来判断基本类型<code>Boolean</code>/<code>Number</code>/<code>Symbol</code>/<code>Undefined</code>/<code>String</code>，其他引用类型，除了<code>function</code>外其他都返回<code>object</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 执行上下文</span><br><span class="line"></span><br><span class="line">&gt; 执行上下文EC可简单理解为一个包含&#96;&#96;&#96;变量对象&#96;&#96;&#96;&#x2F;&#96;&#96;&#96;作用域链&#96;&#96;&#96;&#x2F;&#96;&#96;&#96;this指向&#96;&#96;&#96;的对象，可分为3类：&#96;&#96;&#96;全局执行上下文&#96;&#96;&#96;&#x2F;&#96;&#96;&#96;函数上下文&#96;&#96;&#96;&#x2F;&#96;&#96;&#96;eval上下文</span><br></pre></td></tr></table></figure>

<ol>
<li><p>全局执行上下文：即window对象。window对象也是var声明的全局变量的载体，即通过var创建的全局对象，都能通过window直接访问</p>
</li>
<li><p>函数上下文：每当一个函数被调用时，都会创建一个函数上下文，通过一个函数都被多次调用，都会创建一个新的上下文</p>
</li>
</ol>
<h4 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h4><blockquote>
<p>执行上下文栈，即调用栈。用于存储代码执行期间创建的所有上下文，具有先进后出LIFO的特性</p>
</blockquote>
<p>js代码首次运行时，先创建一个全局执行上下文压入执行栈中，没胆该函数被调用，则创建一个新的函数执行上下文压入栈中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  f2(); </span><br><span class="line">  console.log(&quot;1&quot;); </span><br><span class="line">&#125;</span><br><span class="line">function f2()&#123;</span><br><span class="line">  f3();</span><br><span class="line">  console.log(&quot;2&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function f3()&#123;</span><br><span class="line">  console.log(&quot;3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">f1();&#x2F;&#x2F;3 2 1</span><br></pre></td></tr></table></figure>

<h4 id="执行上下文创建阶段"><a href="#执行上下文创建阶段" class="headerlink" title="执行上下文创建阶段"></a>执行上下文创建阶段</h4><p>执行上下文创建分为<strong>创建阶段</strong>和<strong>执行阶段</strong>。</p>
<p>创建阶段主要负责：</p>
<ol>
<li>确定this指向</li>
</ol>
<p>在全局执行上下文中，this总是指向全局对象。在函数执行上下文中，this的值取决于函数的调用方式，若被对象调用，则this指向此对象，否则this一般指向全局对象window或undefined</p>
<ol start="2">
<li>创建词法环境组件</li>
</ol>
<p>词法环境是包含标志符变量映射的结构，此标识符表示变量/函数的名称，变量是对实际对象或原始值的引入。</p>
<p>词法环境由<strong>环境记录</strong>和<strong>对外部环境引入记录</strong>两部分组成。</p>
<ul>
<li>环境记录：用于存储当前环境中的变量和函数声明的实际位置</li>
<li>外部环境引入记录：用于保存自身环境可以访问到的其他外部环境</li>
</ul>
<p>词法环境分为<strong>全局词法环境</strong>和<strong>函数词法环境</strong></p>
<ul>
<li>全局词法环境：对外部环境引入记录为<code>null</code>，全局词法环境本身即为最外层环境，此外，它还记录了当前环境下的所有属性和方法的位置</li>
<li>函数词法环境：包含用户在函数定义的所有属性、方法、<code>arguments</code>对象。其外部环境引入由实际代码决定。</li>
</ul>
<ol start="3">
<li>创建变量环境组件</li>
</ol>
<p>变量环境具备词法环境所有属性。ES6中唯一的区别在于<strong>词法环境用于存储函数声明与let/const声明的变量</strong>，而<strong>变量环境仅存储var声明的变量</strong>。</p>
<p>在执行上下文创建阶段，函数声明与var声明的变量在创建阶段已经被赋予了一个值，var被设置为undefined，函数被设置为自身函数。但let/const被设置为未初始化。即<strong>变量提升</strong>，在声明之前可以访问var定义的变量，因为其已经在创建阶段就被初始化为undefined，而let/const没有被赋值，故声明之前访问会提示引用错误。</p>
<p>而在执行阶段，则根据之前的环境记录对应赋值，若有值则对应赋值，若没有值，则赋予undefined</p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>面经</tag>
        <tag>http</tag>
        <tag>HTML</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（三）-链表</title>
    <url>/post/7475bf8d.html</url>
    <content><![CDATA[<blockquote>
<p>一种线性结构表，数据元素在内存中分散存储，采用链式表示结构，即链表。</p>
</blockquote>
<p>顺序表的存储结构是逻辑位置和物理位置都相邻，但链表是逻辑位置相邻，物理位置不一定相邻，且不能随机存取，但在插入和删除时，不需要移动元素。</p>
<p>链表存储结构由结点组成，每个结点包括一个数据域和一个指针域（指向下一个后继元素的地址）。除单链表外还有循环链表和双向链表，循环链表的最后一个结点的指针指向头结点，形成环。双向链表多了一个指向前驱元素的指针。</p>
<h2 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<a id="more"></a>

<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>按JavaScript数据结构，链表使用对象存储，数据结构为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ListNode(val) &#123;</span><br><span class="line">    this.val &#x3D; val;</span><br><span class="line">    this.next &#x3D; null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后输出数组，故可以通过遍历将链表中的数据存入数组后再使用<code>reverse()</code>反转，或使用<code>unshift()</code>方法每次从数组头插入数据。</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var reversePrint &#x3D; function(head) &#123;</span><br><span class="line">    if(!head )</span><br><span class="line">        return [];</span><br><span class="line">    let arr &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F;方法1</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        arr.push(head.val);</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr.reverse();</span><br><span class="line">    &#x2F;&#x2F;方法2</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        arr.unshift(head.val);</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除链表的节点"><a href="#删除链表的节点" class="headerlink" title="删除链表的节点"></a>删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>
<p>返回删除后的链表的头节点。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br></pre></td></tr></table></figure>

<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>删除链表节点，即将要删除结点的前驱结点的<code>next</code>指针指向删除节点的<code>next</code>结点。需要注意的是要删除的结点是头结点和末尾结点的问题。</p>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @param &#123;number&#125; val</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var deleteNode &#x3D; function(head, val) &#123;</span><br><span class="line">    if(!head)</span><br><span class="line">        return [];</span><br><span class="line">    &#x2F;&#x2F;删除结点是头结点</span><br><span class="line">    if(head.val &#x3D;&#x3D;&#x3D; val)&#123;</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">       &#x2F;&#x2F; return head;</span><br><span class="line">    let current &#x3D; head;</span><br><span class="line">    let nextnode &#x3D; current.next;</span><br><span class="line">    while(current)&#123;</span><br><span class="line">        if(nextnode.val &#x3D;&#x3D;&#x3D; val &amp;&amp; nextnode.next)&#123;&#x2F;&#x2F;删除非尾结点</span><br><span class="line">            current.next &#x3D; nextnode.next;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;else if(nextnode.val &#x3D;&#x3D;&#x3D; val &amp;&amp; !nextnode.next)&#123;&#x2F;&#x2F;删除尾结点</span><br><span class="line">            current.next &#x3D; null;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        current &#x3D; nextnode;</span><br><span class="line">        nextnode &#x3D; nextnode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a>链表中倒数第k个节点</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>
<p>例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.</span><br><span class="line"></span><br><span class="line">返回链表 4-&gt;5.</span><br></pre></td></tr></table></figure>

<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>使用<strong>快慢指针</strong>，快指针先走k步，慢指针再开始走，等快指针走到链表尾，慢指针即为倒数第k个结点。注意k大于链表长度的情况</p>
<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var getKthFromEnd &#x3D; function(head, k) &#123;</span><br><span class="line">    let fast &#x3D; head;</span><br><span class="line">    let slow &#x3D; head;</span><br><span class="line">    let path &#x3D; 1;</span><br><span class="line">    while(fast)&#123;</span><br><span class="line">        if(path &lt;&#x3D; k)&#123;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">            path ++;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">            slow &#x3D; slow.next;</span><br><span class="line">            path ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(path &lt;&#x3D; k)&#123;</span><br><span class="line">        &#x2F;&#x2F;k大于链表长度的情况</span><br><span class="line">        slow &#x3D; null;</span><br><span class="line">    &#125;</span><br><span class="line">    return slow;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>方法一：使用数组保存链表所有的值，再重新新建一个反转的链表</p>
<p>方法二：使用<code>prev</code>/<code>current</code>/<code>nextnode</code>指针。使<code>current</code>指针的<code>next</code>指向<code>prev</code>且<code>current = nextnode</code>向后遍历链表。使<code>prev = current</code>一直指向<code>current</code>的前一个，使反转链表成立。</p>
<h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; head</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var reverseList &#x3D; function(head) &#123;</span><br><span class="line">    &#x2F;&#x2F;方法一</span><br><span class="line">    let arr &#x3D; [];</span><br><span class="line">    let result &#x3D; null;</span><br><span class="line">    if(!head)&#123;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    while(head)&#123;</span><br><span class="line">        arr.unshift(head.val);</span><br><span class="line">        head &#x3D; head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    result &#x3D; new ListNode(arr[0]);</span><br><span class="line">    let p &#x3D; result;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; arr.length - 1; i++)&#123;</span><br><span class="line">        p.next &#x3D; new ListNode(arr[i+1]);</span><br><span class="line">        p &#x3D; p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;方法二</span><br><span class="line">    let prev &#x3D; null;</span><br><span class="line">    let current &#x3D; head;</span><br><span class="line">    let nextnode &#x3D; null;</span><br><span class="line">    if(!head)&#123;</span><br><span class="line">        return prev;</span><br><span class="line">    &#125;</span><br><span class="line">    while(current)&#123;</span><br><span class="line">        nextnode &#x3D; current.next;</span><br><span class="line">        if(!prev)&#123;</span><br><span class="line">            current.next &#x3D; null;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            current.next &#x3D; prev;</span><br><span class="line">        &#125;</span><br><span class="line">        prev &#x3D; current;</span><br><span class="line">        current &#x3D; nextnode;</span><br><span class="line">    &#125;</span><br><span class="line">    return prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h2><p>输入两个无环的单链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>
<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>两种解释，公共节点即val值相同的两个节点，或两个链表的第一个交点</p>
<p>若为解释一，则可以通过保存链表1的值和所在位置，再遍历链表2找值相同且位置最前的节点，即为公共节点。</p>
<p>解释一和解释二都可以使用双指针解答。双指针公共遍历，若再某节点第一次相遇，则该节点为公共节点。</p>
<h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;解释一</span><br><span class="line">&#x2F;*function ListNode(x)&#123;</span><br><span class="line">    this.val &#x3D; x;</span><br><span class="line">    this.next &#x3D; null;</span><br><span class="line">&#125;*&#x2F;</span><br><span class="line">function FindFirstCommonNode(pHead1, pHead2)</span><br><span class="line">&#123;</span><br><span class="line">    let list &#x3D; &#123;&#125;;</span><br><span class="line">    let path &#x3D; 1;</span><br><span class="line">    while(pHead1)&#123;</span><br><span class="line">        list[pHead1.val] &#x3D; path;</span><br><span class="line">        pHead1 &#x3D; pHead1.next;</span><br><span class="line">        path ++;</span><br><span class="line">    &#125;</span><br><span class="line">    let min &#x3D; path;</span><br><span class="line">    let result &#x3D; null;</span><br><span class="line">    while(pHead2)&#123;</span><br><span class="line">        if(list[pHead2.val] &amp;&amp; list[pHead2.val] &lt;&#x3D; min)&#123;</span><br><span class="line">            result &#x3D; pHead2;</span><br><span class="line">            min &#x3D; list[pHead2.val];</span><br><span class="line">        &#125;</span><br><span class="line">        pHead2 &#x3D; pHead2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通用解法</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; headA</span><br><span class="line"> * @param &#123;ListNode&#125; headB</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var getIntersectionNode &#x3D; function(headA, headB) &#123;</span><br><span class="line">    let nodeA &#x3D; headA;</span><br><span class="line">    let nodeB &#x3D; headB;</span><br><span class="line">    while(nodeA!&#x3D;&#x3D;nodeB)&#123;</span><br><span class="line">        nodeA &#x3D; nodeA ? nodeA.next : headB;</span><br><span class="line">        nodeB &#x3D; nodeB ? nodeB.next : headA;</span><br><span class="line">    &#125;</span><br><span class="line">    return nodeA;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>

<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>使用归并排序，通过两个链表的指针，依次将较小的值放入新链表中</p>
<h3 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; l1</span><br><span class="line"> * @param &#123;ListNode&#125; l2</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var mergeTwoLists &#x3D; function(l1, l2) &#123;</span><br><span class="line">    let list &#x3D; new ListNode();</span><br><span class="line">    let p &#x3D; list;</span><br><span class="line">    while(l1 &amp;&amp; l2)&#123;</span><br><span class="line">        if(l1.val&lt;&#x3D;l2.val)&#123;</span><br><span class="line">            p.next &#x3D; l1;</span><br><span class="line">            l1 &#x3D; l1.next;</span><br><span class="line">            p &#x3D; p.next;</span><br><span class="line">        &#125;else if(l2.val &lt;&#x3D; l1.val)&#123;</span><br><span class="line">            p.next &#x3D; l2;</span><br><span class="line">            p &#x3D; p.next;</span><br><span class="line">            l2 &#x3D; l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(l1)&#123;</span><br><span class="line">        p.next &#x3D; l1;</span><br><span class="line">        l1 &#x3D; l1.next;</span><br><span class="line">        p &#x3D; p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(l2)&#123;</span><br><span class="line">        p.next &#x3D; l2;</span><br><span class="line">        l2 &#x3D; l2.next;</span><br><span class="line">        p &#x3D; p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return list.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="删除链表中重复的结点"><a href="#删除链表中重复的结点" class="headerlink" title="删除链表中重复的结点"></a>删除链表中重复的结点</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">&#123;1,2,3,3,4,4,5&#125;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">&#123;1,2,5&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>使用<code>prev</code>指针指向当前节点的上一个节点，注意由空指针开始，<code>next</code>指向链表的头指针，防止无法删除从头指针开始重复的元素。在判断时，若出现重复元素，将<code>prev</code>指针的<code>next</code>指向下一个不重复的元素。</p>
<h3 id="解答-6"><a href="#解答-6" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*function ListNode(x)&#123;</span><br><span class="line">    this.val &#x3D; x;</span><br><span class="line">    this.next &#x3D; null;</span><br><span class="line">&#125;*&#x2F;</span><br><span class="line">function deleteDuplication(pHead)</span><br><span class="line">&#123;</span><br><span class="line">    let node &#x3D; pHead;</span><br><span class="line">    let p &#x3D; null;</span><br><span class="line">    let head &#x3D; new ListNode(0);</span><br><span class="line">    head.next &#x3D; pHead;</span><br><span class="line">    let prev &#x3D; head;</span><br><span class="line">    while(node &amp;&amp; node.next)&#123;</span><br><span class="line">        if(node.val &#x3D;&#x3D;&#x3D; node.next.val)&#123;</span><br><span class="line">            while(node.next &amp;&amp; node.next.val &#x3D;&#x3D;&#x3D; node.val)&#123;</span><br><span class="line">                node &#x3D; node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev.next &#x3D; node.next;</span><br><span class="line">            node &#x3D; node.next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            prev&#x3D; prev.next;</span><br><span class="line">            node &#x3D; node.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head.next;</span><br><span class="line">    &#x2F;&#x2F; write code here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h2><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p>
<h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>使用数组保存每个节点，若某节点已经在数组中存在，则该节点为环的入口节点</p>
<h3 id="解答-7"><a href="#解答-7" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*function ListNode(x)&#123;</span><br><span class="line">    this.val &#x3D; x;</span><br><span class="line">    this.next &#x3D; null;</span><br><span class="line">&#125;*&#x2F;</span><br><span class="line">function EntryNodeOfLoop(pHead)</span><br><span class="line">&#123;</span><br><span class="line">    let arr &#x3D; [];</span><br><span class="line">    if(!pHead)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    let node &#x3D; pHead;</span><br><span class="line">    while(node)&#123;</span><br><span class="line">        if(arr.includes(node))</span><br><span class="line">            return node;</span><br><span class="line">        arr.push(node);</span><br><span class="line">        node &#x3D; node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;快慢指针</span><br><span class="line">&#x2F;&#x2F;若存在环，则快慢指针会在环入口点相遇</span><br><span class="line">var hasCycle &#x3D; function(head) &#123;</span><br><span class="line">    if(!head)</span><br><span class="line">        return null;</span><br><span class="line">    let slow &#x3D; head,fast &#x3D; head.next;</span><br><span class="line">    while(slow)&#123;</span><br><span class="line">        if(!fast || !fast.next)</span><br><span class="line">            return false;</span><br><span class="line">        if(slow &#x3D;&#x3D;&#x3D; fast)</span><br><span class="line">            return slow;</span><br><span class="line">        slow &#x3D; slow.next;</span><br><span class="line">        fast &#x3D; fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="两个链表生成相加链表"><a href="#两个链表生成相加链表" class="headerlink" title="两个链表生成相加链表"></a>两个链表生成相加链表</h2><ol>
<li>给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照<strong>逆序</strong>的方式存储的，并且每个节点只能存储<strong>一位</strong>数字。</li>
</ol>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 &#x3D; 807.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>假设链表中每一个节点的值都在 0 - 9 之间，那么链表整体就可以代表一个整数。</li>
</ol>
<p>给定两个这种链表，请生成代表两个整数相加值的结果链表。</p>
<p>例如：链表 1 为 9-&gt;3-&gt;7，链表 2 为 6-&gt;3，最后生成新的结果链表为 1-&gt;0-&gt;0-&gt;0。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[9,3,7],[6,3]</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">&#123;1,0,0,0&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>两个题目整体思路相同，即将两个链表的各个节点相加，并保存进位放入下个节点的相加中，将结果放入新链表中。若最后一位仍有进位，则新建一个节点保存进位放入新链表中。</p>
<p>题目1节点顺序为数字逆序，故每位相加的和放入新链表时即为数字相加和的顺序。</p>
<p>题目2节点顺序与数字顺序相同，故结果需要倒序插入每位的结果。且需要在相加前将链表的节点值存入栈中，保证栈顶的值为数字末尾的值。</p>
<h3 id="解答-8"><a href="#解答-8" class="headerlink" title="解答"></a>解答</h3><ol>
<li>两个链表的顺序为数字逆序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * function ListNode(val, next) &#123;</span><br><span class="line"> *     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line"> *     this.next &#x3D; (next&#x3D;&#x3D;&#x3D;undefined ? null : next)</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;ListNode&#125; l1</span><br><span class="line"> * @param &#123;ListNode&#125; l2</span><br><span class="line"> * @return &#123;ListNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var addTwoNumbers &#x3D; function(l1, l2) &#123;</span><br><span class="line">    let list &#x3D; new ListNode();</span><br><span class="line">    let p &#x3D; list;</span><br><span class="line">    let carry &#x3D; 0;</span><br><span class="line">    while(l1 || l2)&#123;</span><br><span class="line">        let sum &#x3D; (l1 ? l1.val : 0) + (l2? l2.val : 0) + carry;</span><br><span class="line">        p.next &#x3D; new ListNode(sum % 10);</span><br><span class="line">        carry &#x3D; Math.floor(sum&#x2F;10);</span><br><span class="line">        p &#x3D; p.next;</span><br><span class="line">        if(l1) l1 &#x3D; l1.next;</span><br><span class="line">        if(l2) l2 &#x3D; l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(carry)&#123;</span><br><span class="line">        p.next &#x3D; new ListNode(carry);</span><br><span class="line">        p &#x3D; p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return list.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>两个链表的顺序即数字的顺序 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * function ListNode(x)&#123;</span><br><span class="line"> *   this.val &#x3D; x;</span><br><span class="line"> *   this.next &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * </span><br><span class="line"> * @param head1 ListNode类 </span><br><span class="line"> * @param head2 ListNode类 </span><br><span class="line"> * @return ListNode类</span><br><span class="line"> *&#x2F;</span><br><span class="line">function addInList( head1 ,  head2 ) &#123;</span><br><span class="line">    let num1 &#x3D; [],num2 &#x3D; [];</span><br><span class="line">    let p1 &#x3D;head1,p2&#x3D;head2;</span><br><span class="line">    while(p1)&#123;</span><br><span class="line">        num1.push(p1.val);</span><br><span class="line">        p1 &#x3D; p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(p2)&#123;</span><br><span class="line">        num2.push(p2.val);</span><br><span class="line">        p2 &#x3D;p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    let p &#x3D; null;</span><br><span class="line">    let carry &#x3D; 0;</span><br><span class="line">    while(num1.length || num2.length)&#123;</span><br><span class="line">        let sum &#x3D; (num1.length ? num1.pop() : 0) + (num2.length ? num2.pop() : 0) + carry;</span><br><span class="line">        carry &#x3D; Math.floor(sum &#x2F; 10);</span><br><span class="line">        let node &#x3D; new ListNode(sum % 10);</span><br><span class="line">        node.next &#x3D; p;</span><br><span class="line">        p &#x3D;node;</span><br><span class="line">        &#x2F;&#x2F;if(head1) head1 &#x3D; head1.next;</span><br><span class="line">        &#x2F;&#x2F;if(head2) head2 &#x3D; head2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(carry)&#123;</span><br><span class="line">        let node &#x3D; new ListNode(carry);</span><br><span class="line">        node.next &#x3D; p;</span><br><span class="line">        p &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    addInList : addInList</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经总结（三）</title>
    <url>/post/23bc433d.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/45e5d827.html">前端面经总结（二）</a></p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><blockquote>
<p>用来装页面上的元素的矩形区域。包括<strong>IE盒子模型</strong>和<strong>标准W3C盒子模型</strong></p>
</blockquote>
<p>盒模型包含4层，<code>content</code>/<code>padding</code>/<code>border</code>/<code>margin</code></p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><a id="more"></a>

<ul>
<li>IE盒子模型</li>
</ul>
<pre><code>- width = ```content_width``` + ```padding-left``` + ```padding-right``` +  ```border-left``` + ```border-right```;

- height = ```content_height``` + ```padding-top``` + ```padding-bottom``` + ```border-top``` + ```border-bottom```;</code></pre><ul>
<li><p>标准W3C盒子模型</p>
<ul>
<li><p>width = <code>content-width</code>;</p>
</li>
<li><p>height = <code>content-height</code>;</p>
</li>
</ul>
</li>
</ul>
<h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p>CSS3中引入<code>box-sizing</code>属性，有两种取值：<code>border-box</code>/<code>content-box</code></p>
<ul>
<li><p>border-box: 即IE盒子模型</p>
</li>
<li><p>content-box: 即标准W3C盒子模型</p>
</li>
</ul>
<h3 id="link-import标签的区别"><a href="#link-import标签的区别" class="headerlink" title="link/import标签的区别"></a>link/import标签的区别</h3><blockquote>
<p>link和import标签都在加载CSS时使用</p>
</blockquote>
<ol>
<li><p>link标签属于HTML，@import标签为CSS提供</p>
</li>
<li><p>link标签在页面加载时同时被加载，@import引用的CSS在页面加载结束后才被加载</p>
</li>
<li><p>link没有兼容性，import在IE5以上才被识别</p>
</li>
<li><p>link标签权重大于import</p>
</li>
</ol>
<h3 id="transition-animation区别"><a href="#transition-animation区别" class="headerlink" title="transition/animation区别"></a>transition/animation区别</h3><blockquote>
<p>transition和animation均随时间改变元素的属性值。</p>
</blockquote>
<ol>
<li><p>transtition需要触发一个事件改变属性，animation不需要</p>
</li>
<li><p>transition为2帧，from/to，animation可以一帧一帧改变</p>
</li>
</ol>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><blockquote>
<p>flex为弹性布局，用来为盒子模型提供最大的灵活性</p>
</blockquote>
<p>任何容器都可以指定为flex布局，但指定为flex布局以后，子元素的<code>float</code>/<code>clear</code>/<code>vertical-align</code>属性失效</p>
<p>采用flex布局的元素为flex容器，其所有自动成为容器成员，即flex项目。容器默认存在两根轴<code>main axis</code>和<code>cross axis</code>。项目默认沿主轴排列。</p>
<h4 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h4><ol>
<li><p>flex-direction：决定主轴方向，即项目排列方向</p>
<ul>
<li><p>row(默认)：主轴水平，起点在左边，项目从左至右排列</p>
</li>
<li><p>row-reverse：主轴水平，起点在右边，项目从右至左排列</p>
</li>
<li><p>column：主轴垂直，起点在上沿，项目从上而下排列</p>
</li>
<li><p>column-reverse：主轴垂直，起点在下沿，项目从下而上排列</p>
</li>
</ul>
</li>
<li><p>flex-wrap：默认时项目排在一条线上，使用flex-wrap属性定义一条轴线排不下时如何换行</p>
<ul>
<li><p>nowrap(默认)：不换行</p>
</li>
<li><p>wrap：换行，第一行在上，第二行在下…</p>
</li>
<li><p>wrap-reverse：换行，第一行在下，第二行在第一行上面，…</p>
</li>
</ul>
</li>
<li><p>flex-flow：为<code>flex-direction</code>和<code>flex-wrap</code>的简写方式，如<code>flex-flow: row wrap;</code></p>
</li>
<li><p>justify-content：定义项目在主轴（水平）上的对齐方式</p>
<ul>
<li><p>flex-start(默认)：左对齐</p>
</li>
<li><p>flex-end：右对齐</p>
</li>
<li><p>center：居中</p>
</li>
<li><p>space-between：两端对齐，项目之间的间隔都相等</p>
</li>
<li><p>space-around：每个项目两侧的间隔相等</p>
</li>
</ul>
</li>
<li><p>align-items：定义项目在交叉轴（垂直）上的对齐方式</p>
<ul>
<li><p>stretch(默认)：若项目未设置高度或设为auto，则占满整个容器高度</p>
</li>
<li><p>flex-start：项目在交叉轴起点对齐</p>
</li>
<li><p>flex-end：项目在交叉轴终点对齐</p>
</li>
<li><p>center：项目在交叉轴中点对齐</p>
</li>
<li><p>baseline：项目在项目的第一行文字基线对齐</p>
</li>
</ul>
</li>
<li><p>align-content：定义多根轴线的对齐方式，若项目只有一根轴线，该属性无用</p>
<ul>
<li><p>stretch(默认)：轴线占满整个交叉轴</p>
</li>
<li><p>flex-start：轴线与交叉轴起点对齐</p>
</li>
<li><p>flex-end：轴线与交叉轴终点对齐</p>
</li>
<li><p>center：轴线与交叉轴中点对齐</p>
</li>
<li><p>space-between：轴线与交叉轴两端对齐，轴线之间间隔相等</p>
</li>
<li><p>space-around：轴线两侧间隔相等</p>
</li>
</ul>
</li>
</ol>
<h4 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h4><ol>
<li><p>order：定义项目的排列顺序，数值越小，排列越靠前，默认为<code>0</code></p>
</li>
<li><p>flex-grow：定义项目的放大比例，默认为<code>0</code>，即若存在剩余空间也不放大。若所有项目的<code>flex-grow: 1;</code>，则所有项目等分剩余空间。</p>
</li>
<li><p>flex-shrink：定义项目的缩小比例，默认为<code>1</code>，即若空间不足，则该项目将缩小。若所有项目的<code>flex-shrink: 1;</code>，则空间不足时，所有项目等比例缩小。若一个项目的<code>flex-shrink: 0;</code>，其他的为<code>1</code>，则为<code>0</code>的项目不缩小。负值无效。</p>
</li>
<li><p>flex-basis：定义在分配多余空间前，项目占据的主轴空间。浏览器通过此属性计算主轴是否有多余空间。默认为<code>auto</code>，即项目本来大小。<code>flex-basis</code>可以设为跟<code>width</code>和<code>height</code>一样的值，则项目占据固定空间。</p>
</li>
<li><p>flex：为<code>flex-grow</code>/<code>flex-shrink</code>/<code>flex-basis</code>的简写，默认为<code>flex: 0 1 auto</code>。其中<code>flex-shrink</code>/<code>flex-basis</code>可选</p>
<ul>
<li><p>auto：即<code>flex: 1 1 auto;</code></p>
</li>
<li><p>none：即<code>flex: 0 0 auto;</code></p>
</li>
</ul>
</li>
<li><p>align-self: 允许单个项目与其他项目有不同的对齐方式，覆盖该项目的<code>align-items</code>属性，默认为<code>auto</code>，即继承父元素的<code>align-item</code>属性，若没有父元素，则等同于<code>stretch</code>。</p>
</li>
</ol>
<p>可选值为：<code>align-self: auto | flex-start | flex-end | center | baseline | stretch;</code></p>
<h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><blockquote>
<p>grid布局将网页划分成一个个网格，可以任意组合不同网格作出不同的布局。</p>
</blockquote>
<p>采用网格布局的区域为容器，容器内部采用网格定位的子元素为项目，项目只代表容器的顶层子元素，不包括项目的子元素。容器里水平区域为行row，垂直区域为列column</p>
<h4 id="grid布局与flex区别"><a href="#grid布局与flex区别" class="headerlink" title="grid布局与flex区别"></a>grid布局与flex区别</h4><p>flex布局为轴线布局，指定项目针对轴线的位置，即一维布局。</p>
<p>grid布局将容器分为行和列，产生单元格，指定项目所在的单元格，即二维布局。</p>
<h4 id="容器属性-1"><a href="#容器属性-1" class="headerlink" title="容器属性"></a>容器属性</h4><ol>
<li><p>display：指定网页的布局</p>
<ul>
<li><p>grid：采用网格布局，默认容器元素都是块级元素</p>
</li>
<li><p>inline-grid：指定元素为行内元素，元素内部采用网格布局</p>
</li>
</ul>
</li>
</ol>
<p>设置为网格布局后，<code>float</code>/<code>display: inline-block;</code>/<code>display: table-cell;</code>/<code>vertical-align</code>/<code>column-*</code>等设置失效</p>
<ol start="2">
<li><p>grid-template-columns/grid-template-rows：定义每一列列宽/每一行行高。几行几列就设置几个数值，如<code>grid-template-columns: 100px 100px 100px;</code>。</p>
<ul>
<li><p>repeat()：如<code>grid-template-rows: repeat(3, 33.33%);</code>第一个参数为重复次数，即行数，第二个参数为重复的值，即行高。也可写为重复某模式<code>grid-template-columns: repeat(2, 100px 20px 80px);</code></p>
</li>
<li><p>auto-fill：使用<code>auto-fill</code>自动填充尽可能多的单元格，如<code>grid-template-columns: repeat(auto-fill, 100px);</code></p>
</li>
<li><p>fr：即片段，若宽度为1fr和2fr，则2fr是1fr的两倍。<code>grid-template-columns: 1fr 1fr;</code></p>
</li>
<li><p>auto：由浏览器自己决定长度。<code>grid-template-columns: 100px auto 100px;</code>，即第二列宽度等于该列单元格的最大宽度</p>
</li>
<li><p>…</p>
</li>
</ul>
</li>
<li><p>row-gap/column-gap/gap：行间距/列间距/行列间距的简写，如<code>grid-gap: 20px 20px;</code></p>
</li>
<li><p>grid-template-areas：定义区域，如</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &quot;header header header&quot;</span><br><span class="line">                    &quot;main main sidebar&quot;</span><br><span class="line">                    &quot;footer footer footer&quot;;</span><br></pre></td></tr></table></figure>

<p>若某些区域不需要使用，则使用<code>.</code>表示，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grid-template-areas: &#39;a . c&#39;</span><br><span class="line">                     &#39;d . f&#39;</span><br><span class="line">                     &#39;g . i&#39;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>grid-auto-flow：设置子元素的放置顺序</p>
<ul>
<li><p>row(默认)：先行后列</p>
</li>
<li><p>column：先列后行</p>
</li>
<li><p>row dense：当某些项目指定位置后，其他项目先行后列，尽可能不出现空格</p>
</li>
<li><p>column dense：当某些项目指定位置后，其他项目先列后行，尽可能不出现空格</p>
</li>
</ul>
</li>
<li><p>justify-item/align-items/place-items：设置单元格内容的水平位置/垂直位置/水平垂直位置简写，如<code>place-items: start end;</code></p>
<ul>
<li><p>start：对齐单元格的起始边缘</p>
</li>
<li><p>end：对齐单元格的结束边缘</p>
</li>
<li><p>center：单元格内部居中</p>
</li>
<li><p>stretch：拉伸，占满单元格的整个宽度</p>
</li>
</ul>
</li>
<li><p>justify-content/align-content/place-content：设置单元格内容在容器里的水平位置/垂直位置/水平垂直位置的简写</p>
<ul>
<li><p>start：对齐容器的起始边缘</p>
</li>
<li><p>end：对齐容器的结束边缘</p>
</li>
<li><p>center：容器内部居中</p>
</li>
<li><p>stretch：项目大小没有指定时，拉伸占据整个网格容器</p>
</li>
<li><p>space-around：每个项目两侧间隔相等</p>
</li>
<li><p>space-between：项目间间隔相等，项目与容器边框间没有间隔</p>
</li>
<li><p>space-evenly：项目间间隔、项目与容器边框之间间隔都相等</p>
</li>
</ul>
</li>
<li><p>grid-template/grid</p>
<ul>
<li><p>grid-template = grid-template-columns + grid-template-rows + grid-template-areas</p>
</li>
<li><p>grid = grid-template-rows + grid-template-columns + grid-template-areas + grid-auto-rows + grid-auto-columns + grid-auto-flow</p>
</li>
</ul>
</li>
<li><p>…</p>
</li>
</ol>
<h4 id="项目属性-1"><a href="#项目属性-1" class="headerlink" title="项目属性"></a>项目属性</h4><ol>
<li><p>justify-self/align-self/place-self：设置<strong>单个</strong>单元格内容的水平位置/垂直位置/水平垂直位置简写。其用法与<code>justify-items</code>/<code>align-items</code>/<code>place-items</code>一致。</p>
</li>
<li><p>…</p>
</li>
</ol>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><blockquote>
<p>用来指定一个元素在网页上的位置</p>
</blockquote>
<ul>
<li><p>static(默认)：浏览器按照源码的顺序决定每个元素的位置（<strong>正常页面流</strong>）。每个块级元素占据自己的区块，元素之间不产生重叠。此时<code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code>属性无效</p>
</li>
<li><p>relative：相对于默认位置进行偏移，即<strong>定位基点为元素的默认位置</strong>，必须搭配<code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code>属性指定偏移的方向与距离</p>
</li>
<li><p>absolute：相对于上级元素进行偏移，即<strong>定位基点为父元素</strong>，且<strong>定位基点不能是static定位</strong>，否则基点会变成网页的根元素html。必须搭配<code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code>使用。<code>absolute</code>定位的元素会被<strong>正常页面流</strong>忽略，即在<strong>正常页面流</strong>中，元素所占空间为<code>0</code>，周边元素不受影响。</p>
</li>
<li><p>fixed：相对于视口（浏览器窗口）进行偏移，即<strong>定位基点为浏览器窗口</strong>，此时元素的位置不随页面滚动而变化，搭配<code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code>使用时，表示元素初始位置<strong>基于视口</strong>计算，否则<strong>初始位置为元素的默认位置</strong>。</p>
</li>
<li><p>sticky：此属性产生动态效果，类似于<code>relative</code>和<code>fixed</code>的结合。必须搭配<code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code>使用。当页面滚动，父元素开始脱离视口（部分不可见）时，只要与<code>sticky</code>元素达到生效门槛（即设置的<code>top</code>/…等值），则<code>relative</code>定位自动切换为<code>fixed</code>定位。等父元素完全脱离视口（完全不可见）时，<code>fixed</code>定位自动切换回<code>relative</code>定位</p>
</li>
</ul>
<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><blockquote>
<p>FC（Formatting Context）是W3C CSS2.1规范中的概念，是页面中一块渲染区域，并有一套渲染规则，它决定了其子元素如何定位以及和其他元素的关系和相互作用。BFC即块级格式化上下文，属于FC的普通流，即元素按照其在HTML中的先后位置自上而下布局。行内元素水平排列，占满后换行，块级元素被渲染为完整的新行。</p>
</blockquote>
<p>具有BFC特性的元素可看作隔离的独立容器，容器内元素的任何布局都不会影响外面的元素。</p>
<h4 id="触发BFC"><a href="#触发BFC" class="headerlink" title="触发BFC"></a>触发BFC</h4><p>元素只要满足以下任意一个条件即可触发BFC</p>
<ol>
<li><p>body根元素</p>
</li>
<li><p>浮动元素：<code>float</code>设置除<code>none</code>以外的值</p>
</li>
<li><p>绝对定位元素：<code>position</code>设置<code>absolute</code>/<code>fixed</code></p>
</li>
<li><p>属性<code>display</code>设置<code>inline-block</code>/<code>table-cell</code>/<code>flex</code></p>
</li>
<li><p>属性<code>overflow</code>设置除<code>visible</code>以外的值，如<code>hidden</code>/<code>auto</code>/<code>scroll</code></p>
</li>
</ol>
<h4 id="BFC特性"><a href="#BFC特性" class="headerlink" title="BFC特性"></a>BFC特性</h4><ol>
<li><p>同一个BFC下外边距<code>margin</code>会折叠，即设置<code>margin</code>为<code>100px</code>，但两个盒子之间的间距为<code>100px</code>，而非<code>200px</code>。故若需要避免外边距<code>margin</code>折叠，可以将元素放入不同的BFC容器中。</p>
<ul>
<li><p>外边距折叠：多个相邻普通流的快元素垂直方向<code>margin</code>会折叠。</p>
<ul>
<li><p>两外边距为正数：折叠结果取较大的值</p>
</li>
<li><p>两外边距为负数：折叠结果取绝对值较大的值</p>
</li>
<li><p>两外边距一正一负：折叠结果取两者之和</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>BFC可以清除浮动。</p>
</li>
</ol>
<p>浮动的元素会脱离普通文档流，为元素设置触发BFC的条件，使容器包裹浮动元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置前</span><br><span class="line">&lt;div style&#x3D;&quot;border: 1px solid #000;&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置后</span><br><span class="line">&lt;div style&#x3D;&quot;border: 1px solid #000;overflow: hidden&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>为元素添加<code>overflow: hidden</code>触发其BFC特性，清除浮动。</p>
<ul>
<li><p>清除浮动其他的方法</p>
<ul>
<li><p>在浮动元素添加一个块级元素并设置属性<code>clear: both;</code>即可清除浮动。</p>
</li>
<li><p>给浮动元素父级元素添加伪类<code>after</code>或双伪类<code>before</code>/<code>after</code>清除浮动</p>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li>BFC阻止元素被浮动元素覆盖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置前</span><br><span class="line">&lt;div style&#x3D;&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;左浮动元素&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;height: 200px;background: #eee&quot;&gt;没有浮动, 没有触发 BFC 元素&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置后</span><br><span class="line">&lt;div style&#x3D;&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;左浮动元素&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div style&#x3D;&quot;height: 200px;background: #eee;overflow: hidden&quot;&gt;没有浮动, 触发了 BFC 元素&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>设置后第二个元素出发了BFC特性，其内容不会被浮动元素覆盖，使用此方法可以实现两列自适应布局。左边宽度固定，右边内容自适应宽度。</p>
<h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><ol>
<li>利用flex</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用<code>display: table-cell</code>和<code>vertical-align</code>对容器内文字垂直居中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  display: table-cell;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用<code>position: absolute</code>和<code>margin: auto</code>实现垂直居中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  position: absolute;&#x2F;&#x2F;此时父元素position为relative</span><br><span class="line">  margin: auto;</span><br><span class="line">  top: 0;</span><br><span class="line">  bottom: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法将元素相对父元素处于绝对定位，设置<code>top</code>和<code>bottom</code>为相等的值，再设置<code>margin: auto</code>即可实现垂直居中</p>
<ol start="4">
<li>使用<code>position: absolute</code>和负外边距<code>margin</code>实现垂直居中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  height: 100px;</span><br><span class="line">  width: 100px;</span><br><span class="line">  position: absolute;&#x2F;&#x2F;此时父元素position为relative</span><br><span class="line">  top: 50%;</span><br><span class="line">  margin-top: -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法必须要知道被居中块级元素的尺寸</p>
<h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><ol>
<li><p>已知宽度，且为block元素，添加<code>margin: 0 auto;</code></p>
</li>
<li><p>已知宽度，<code>position: absolute</code>，设置<code>top</code>/<code>bottom</code>/<code>left</code>/<code>right</code>为<code>0</code>，且<code>margin：auto</code></p>
</li>
<li><p>使用<code>flex</code>容器，设置<code>justify-content: center;</code></p>
</li>
<li><p>行内元素：<code>text-align: center;</code></p>
</li>
</ol>
<h4 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h4><ol>
<li>已知高宽</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父元素</span><br><span class="line">position: relative;</span><br><span class="line">&#x2F;&#x2F;子元素</span><br><span class="line">position: absolute;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>未知高宽</p>
<ul>
<li><p>定位属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父元素</span><br><span class="line">position: relative;</span><br><span class="line">&#x2F;&#x2F;子元素</span><br><span class="line">position: absolute;</span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">transform: translateX(-50%) translateY(-50%);</span><br></pre></td></tr></table></figure>
</li>
<li><p>flex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">justify-content: center;</span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="块级元素和行内元素"><a href="#块级元素和行内元素" class="headerlink" title="块级元素和行内元素"></a>块级元素和行内元素</h3><ol>
<li><p>块级元素独占一行，行内元素不会独占一行</p>
</li>
<li><p>块级元素自动填满父元素，且可以设置<code>margin</code>/<code>padding</code>/<code>width</code>/<code>height</code>，行内元素的<code>width</code>和<code>height</code>失效，且垂直方向的<code>margin</code>和<code>padding</code>失效。</p>
</li>
</ol>
<h3 id="设置元素消失"><a href="#设置元素消失" class="headerlink" title="设置元素消失"></a>设置元素消失</h3><ol>
<li><p>display: none; 隐藏对应元素，在文档布局中不再分配空间，各边元素合拢</p>
</li>
<li><p>visibility: hidden; 隐藏对应元素，在文档布局中仍保留原空间，只是不可见</p>
</li>
<li><p>z-index = -1;</p>
</li>
<li><p>opacity: 0; 元素被隐藏，不会改变页面布局，若元素绑定了事件，则事件仍然可以触发</p>
</li>
</ol>
<h3 id="CSS3新特性"><a href="#CSS3新特性" class="headerlink" title="CSS3新特性"></a>CSS3新特性</h3><ol>
<li><p>transition：当元素变换样式时添加效果</p>
<ul>
<li><p>transition-duration：规定完成过渡效果需要的时间</p>
</li>
<li><p>transition-delay：规定过渡何时开始</p>
</li>
<li><p>transition-property：规定应用过渡的CSS属性的名称</p>
</li>
</ul>
</li>
<li><p>transform：用来向元素应用各种2D和3D转换，如缩放、旋转、移动等</p>
</li>
<li><p>animation：制作动画</p>
</li>
<li><p>增加边框属性：</p>
<ul>
<li><p>border-radius：创建圆角边框</p>
</li>
<li><p>box-shadow：为元素添加阴影</p>
</li>
<li><p>border-image：使用图片绘制边框</p>
</li>
</ul>
</li>
<li><p>word-wrap：强制文本换行</p>
</li>
<li><p>text-shadow：向文本应用阴影</p>
</li>
<li><p>box-sizing：设置盒模型，有<code>content-box</code>/<code>border-box</code>/<code>inherit</code></p>
</li>
</ol>
<h3 id="CSS选择器及优先级"><a href="#CSS选择器及优先级" class="headerlink" title="CSS选择器及优先级"></a>CSS选择器及优先级</h3><p>优先级：</p>
<p>!important &gt; 行内样式 &gt; ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 默认属性</p>
<p>选择器解析顺序：<strong>从右向左</strong></p>
<h3 id="calc函数"><a href="#calc函数" class="headerlink" title="calc函数"></a>calc函数</h3><blockquote>
<p>CSS3的<code>calc()</code>函数允许我们在属性值中执行数学操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.foo &#123;</span><br><span class="line">  width: calc(100px + 50px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><blockquote>
<p>display 属性规定元素应该生成的框的类型。</p>
</blockquote>
<ul>
<li>none:此元素不会被显示。</li>
<li>block:此元素将显示为块级元素，此元素前后会带有换行符。</li>
<li>inline:默认。此元素会被显示为内联元素，元素前后没有换行符。</li>
<li>inline-block:行内块元素。（CSS2.1 新增的值）</li>
<li>…<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3></li>
</ul>
<blockquote>
<p>层叠上下文是HTML中一个三维概念，即每个元素的位置都是三维的，若元素含有层叠上下文，即它在<strong>z轴</strong>上有层叠关系</p>
</blockquote>
<ol>
<li><p>层叠等级</p>
<ul>
<li><p>在同一层叠上下文中，层叠等级描述在此上下文中的元素在Z轴上的上下顺序</p>
</li>
<li><p>在普通元素中，层叠等级描述普通元素在Z轴上的上下顺序</p>
</li>
<li><p>普通元素的层叠等级优先由所在层叠上下文决定</p>
</li>
<li><p>层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级没有意义。</p>
</li>
</ul>
</li>
<li><p>层叠顺序</p>
</li>
</ol>
<p>层叠上下文的背景和边框<code>background/border</code> =&gt; <code>z-index &lt; 0</code> =&gt; <code>block</code>块级水平盒子 =&gt; <code>float</code>浮动盒子 =&gt; <code>inline/inlink-block</code>水平盒子 =&gt; <code>z-index：auto/0</code> =&gt; <code>z-index &gt; 0</code></p>
<ol start="3">
<li>层叠上下文的产生</li>
</ol>
<p>层叠上下文满足以下任意一个条件即可形成：</p>
<ul>
<li>文档根元素<code>html</code></li>
<li>属性<code>position</code>值为<code>absolute/relative</code>且<code>z-index</code>不为<code>auto</code></li>
<li>属性<code>position</code>值为<code>fixed/sticky</code></li>
<li>属于<code>fiex</code>容器的子元素，且<code>z-index</code>不为<code>auto</code></li>
<li>属于<code>grid</code>容器的子元素，且<code>z-index</code>不为<code>auto</code></li>
<li>属性<code>opacity</code>值不是<code>1</code>的元素</li>
<li>属性<code>transform</code>不为<code>none</code>的元素</li>
<li>属性<code>mix-blend-mode</code>值不是<code>normal</code></li>
<li>属性<code>isolation</code>值不是<code>isolate</code></li>
<li>属性<code>filter</code>值不是<code>none</code></li>
<li>属性<code>will-change</code>指定的属性值为上面任意一个</li>
<li>元素<code>-webkit-overflow-scrolling</code>属性值设置为<code>touch</code></li>
</ul>
<h3 id="设置元素的背景颜色会填充哪些区域"><a href="#设置元素的背景颜色会填充哪些区域" class="headerlink" title="设置元素的背景颜色会填充哪些区域"></a>设置元素的背景颜色会填充哪些区域</h3><p>css盒子模型中的<code>background-color</code>能控制的盒子模型内的<code>content</code>、<code>padding</code>和<code>border</code>中的颜色。</p>
<h3 id="重绘重排，如何减少，如何让文档脱离文档流"><a href="#重绘重排，如何减少，如何让文档脱离文档流" class="headerlink" title="重绘重排，如何减少，如何让文档脱离文档流"></a>重绘重排，如何减少，如何让文档脱离文档流</h3><ol>
<li><p>回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流</p>
</li>
<li><p>当页面布局和几何属性改变时就需要回流<br>比如：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变</p>
</li>
</ol>
<p>减少重绘重排：</p>
<ol>
<li>使用cssText合并所有的改变一次型处理或切换类名</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; javascript</span><br><span class="line">var el &#x3D; document.querySelector(&#39;.el&#39;);</span><br><span class="line">el.style.borderLeft &#x3D; &#39;1px&#39;;</span><br><span class="line">el.style.borderRight &#x3D; &#39;2px&#39;;</span><br><span class="line">el.style.padding &#x3D; &#39;5px&#39;;</span><br><span class="line">&#x2F;&#x2F;cssText</span><br><span class="line">var el &#x3D; document.querySelector(&#39;.el&#39;);</span><br><span class="line">el.style.cssText &#x3D; &#39;border-left: 1px; border-right: 2px; padding: 5px&#39;;</span><br><span class="line">&#x2F;&#x2F;切换类名</span><br><span class="line">&#x2F;&#x2F; css </span><br><span class="line">.active &#123;</span><br><span class="line">    padding: 5px;</span><br><span class="line">    border-left: 1px;</span><br><span class="line">    border-right: 2px;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; javascript</span><br><span class="line">var el &#x3D; document.querySelector(&#39;.el&#39;);</span><br><span class="line">el.className &#x3D; &#39;active&#39;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>批量修改DOM：使元素脱离文档流，对其进行多重改变，再将元素带回文档流</p>
<ul>
<li><p>隐藏元素，修改后再显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let ul &#x3D; document.querySelector(&#39;#mylist&#39;);</span><br><span class="line">ul.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">appendNode(ul, data);</span><br><span class="line">ul.style.display &#x3D; &#39;block&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用文档片段Fragment创建子树，再copy到文档中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let fragment &#x3D; document.createDocumentFragment();</span><br><span class="line">appendNode(fragment, data);</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将原始元素copy到独立节点中，操作后在覆盖原始元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let old &#x3D; document.querySelector(&#39;#mylist&#39;);</span><br><span class="line">let clone &#x3D; old.cloneNode(true);</span><br><span class="line">appendNode(clone, data);</span><br><span class="line">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>float</code>脱离文档流，设置<code>float: left/right/...;</code></p>
</li>
<li><p>使用绝对定位<code>absolute</code>脱离文档流，此时父类<code>position</code>必须为非<code>static</code></p>
</li>
<li><p>使用<code>position: fixed</code>完全脱离文档流，相对于浏览器窗口定位</p>
</li>
</ul>
</li>
</ol>
<h3 id="overflow原理"><a href="#overflow原理" class="headerlink" title="overflow原理"></a>overflow原理</h3><h3 id="CSS布局"><a href="#CSS布局" class="headerlink" title="CSS布局"></a>CSS布局</h3><ol>
<li>两栏布局，左侧固定，右侧自适应</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>左侧元素浮动，右侧设置margin</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.left&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    height:300px;</span><br><span class="line">    width: 100%;&#x2F;&#x2F;宽度为100%</span><br><span class="line">    margin-left: 310px;&#x2F;&#x2F;盒子被覆盖区域变成margin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>flex</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;father&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>给两栏布局添加父元素，并设置flex布局，左侧盒子宽度固定，右侧盒子占据所有空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>定位+margin</li>
</ul>
<p>给左侧盒子绝对定位，即不占页面空间，再设置右侧盒子margin-left为左侧盒子宽度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.left&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    position: absolute;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    margin-left: 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>三栏布局，两边固定，中间自适应（圣杯布局/双飞翼布局）</li>
</ol>
<ul>
<li><p>圣杯布局</p>
<ul>
<li><p>header/footer各自占领屏幕所有宽度，高度固定</p>
</li>
<li><p>中间container是三栏布局</p>
</li>
<li><p>三栏布局两侧宽度固定，中间自适应布局且高度为三栏中最高区域的高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>使用flex实现：</p>
</li>
<li><p>container设置弹性布局flex</p>
</li>
<li><p>left/right定宽，main设置flex: 1;填满剩余区域</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left</span><br><span class="line">.right&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>双飞翼布局</p>
<ul>
<li><p>left/main/right都设置左浮动</p>
</li>
<li><p>main宽度100%</p>
</li>
<li><p>设置left负边距为100%，right负边距为自身宽度，margin负边距使文档流发生偏移，改变元素大小。当为浮动元素之间设置负边距magin-left，则被设置的内容会在原有border-left基础上左移。</p>
</li>
<li><p>设置container的margin为左右两栏流出空间，大小为left/right宽度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;center&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">.container&#123;</span><br><span class="line">    overflow: hidden;&#x2F;&#x2F;消除浮动</span><br><span class="line">&#125;</span><br><span class="line">.left</span><br><span class="line">.right</span><br><span class="line">.main&#123;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.main&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    margin-left: -100%;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    margin-left: -200px;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    margin: 0 200px 0 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h3><h3 id="img中alt和title区别"><a href="#img中alt和title区别" class="headerlink" title="img中alt和title区别"></a>img中alt和title区别</h3><ul>
<li><p>alt：当图片不能正常显示时出现的文本提示</p>
</li>
<li><p>title：鼠标移动到元素上的文本提示</p>
</li>
</ul>
<h3 id="px-em-rem-vh-vw-vmin-vmax的区别"><a href="#px-em-rem-vh-vw-vmin-vmax的区别" class="headerlink" title="px,em,rem,vh,vw,vmin,vmax的区别"></a>px,em,rem,vh,vw,vmin,vmax的区别</h3><ul>
<li>px：像素，绝对单位</li>
<li>em：相对单位，基准点为父节点字体大小</li>
<li>rem：相对单位，相对于根节点html字体大小来计算</li>
<li>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%</li>
<li>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%</li>
<li>vmin：vw和vh中较小的值</li>
<li>vmax：vw和vh中较大的值</li>
</ul>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>面经</tag>
        <tag>http</tag>
        <tag>HTML</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（二）-字符串</title>
    <url>/post/1b6cf8a2.html</url>
    <content><![CDATA[<h2 id="请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。"><a href="#请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。" class="headerlink" title="请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。"></a>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。</h2><p>数值（按顺序）可以分成以下几个部分：</p>
<ul>
<li><p>若干空格</p>
</li>
<li><p>一个<strong>小数</strong>或者<strong>整数</strong></p>
</li>
<li><p>（可选）一个<code>e</code>或<code>E</code>，后面跟着一个<strong>整数</strong></p>
</li>
<li><p>若干空格</p>
<a id="more"></a>
<p>小数（按顺序）可以分成以下几个部分：</p>
</li>
<li><p>（可选）一个符号字符（<code>+</code> 或 <code>-</code>）</p>
</li>
</ul>
<p>下述格式之一：</p>
<ul>
<li>至少一位数字，后面跟着一个点 <code>.</code></li>
<li>至少一位数字，后面跟着一个点 <code>.</code> ，后面再跟着至少一位数字</li>
<li>一个点 <code>.</code> ，后面跟着至少一位数字</li>
</ul>
<p>整数（按顺序）可以分成以下几个部分：</p>
<ul>
<li>（可选）一个符号字符（<code>+</code> 或 <code>-</code>）</li>
<li>至少一位数字</li>
</ul>
<p>部分数值列举如下：</p>
<figure class="highlight plain"><figcaption><span>"5e2", "-123", "3.1416", "-1E-16", "0123"]```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">部分非数值列举如下：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;[&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;]</span><br></pre></td></tr></table></figure>

<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;0&quot;</span><br><span class="line">输出：true</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;e&quot;</span><br><span class="line">输出：false</span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;.&quot;</span><br><span class="line">输出：false</span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;    .1  &quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>该题使用正则表达式匹配符合条件的数值，需要考虑的测试用例众多，除了示例中的内容，还有<code>3.</code>/<code>e3</code>/<strong>空字符串</strong>/<strong>纯空格</strong>等</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isNumber &#x3D; function(s) &#123;</span><br><span class="line">    s &#x3D; s.trim();</span><br><span class="line">    if(s &#x3D;&#x3D;&#x3D; &quot;&quot; || !s)</span><br><span class="line">        return false;</span><br><span class="line">    let rex1 &#x3D; &#x2F;^([+-]?)((\d+(\.\d*)?)|(\.\d+))$&#x2F;;</span><br><span class="line">    let rex2 &#x3D; &#x2F;^[+-]?((\d+)?\.)?\d+\.?e[+-]?\d+$&#x2F;i;&#x2F;&#x2F;带e的匹配</span><br><span class="line"></span><br><span class="line">    return rex1.test(s) || rex2.test(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="翻转单词顺序"><a href="#翻转单词顺序" class="headerlink" title="翻转单词顺序"></a>翻转单词顺序</h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;the sky is blue&quot;</span><br><span class="line">输出: &quot;blue is sky the&quot;</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br><span class="line"></span><br><span class="line">输入: &quot;a good   example&quot;</span><br><span class="line">输出: &quot;example good a&quot;</span><br><span class="line">解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><br></pre></td></tr></table></figure>

<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>通过<code>split(“ ”)</code>将单词字符串按空格分割转化为数组，再使用方法<code>reverse()</code>翻转单词顺序，再使用<code>join(&quot; &quot;)</code>输出相应的反转字符串。</p>
<p>需要注意的点是<strong>最终输出的字符头尾不能有空格</strong>，且<strong>每个单词间只能有一个空格</strong>。</p>
<p>最终的字符串可以使用<code>正则表达式</code>去除头尾空格</p>
<p>单词间的空格由于转化为数组时通过空格分割，故若原字符串中单词间有多个空格，则会再数组中出现多个空数据，故可以通过删除单词数组中的空数据来删除多余的空格。</p>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var reverseWords &#x3D; function(s) &#123;</span><br><span class="line">    let arr &#x3D; s.split(&quot; &quot;);</span><br><span class="line">    for(let i &#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        if(arr[i] &#x3D;&#x3D;&#x3D; &quot;&quot;)&#123;</span><br><span class="line">            arr.splice(i,1);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr.reverse();</span><br><span class="line">    return arr.join(&quot; &quot;).replace(&#x2F;^\s+|\s+$&#x2F;g,&quot;&quot;);&#x2F;&#x2F;去除两头空格</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a>把字符串转换成整数</h2><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p>
<p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p>
<p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>
<p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p>
<p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p>
<p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p>
<p>说明：</p>
<p>假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br><span class="line"></span><br><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#39;-&#39;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br><span class="line"></span><br><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#39;3&#39; ，因为它的下一个字符不为数字。</span><br><span class="line"></span><br><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#39;w&#39;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br><span class="line"></span><br><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>

<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>js的<code>parseInt()</code>可将字符串转化为数字，该题字符串需要考虑<strong>删除开头的空格</strong>和<strong>转换后数字的大小</strong>。当字符串中数字不合规时，<code>parseInt()</code>方法返回<code>NaN</code>值。</p>
<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; str</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var strToInt &#x3D; function(str) &#123;</span><br><span class="line">    str &#x3D; str.replace( &#x2F;^\s*&#x2F;, &#39;&#39;);&#x2F;&#x2F;去除开头空格</span><br><span class="line">    let num &#x3D; parseInt(str);</span><br><span class="line">    if(isNaN(num))</span><br><span class="line">        return 0;</span><br><span class="line">    if(num &gt;&#x3D; Math.pow(-2, 31) &amp;&amp; num &lt;&#x3D; Math.pow(2, 31)-1)</span><br><span class="line">        return num;</span><br><span class="line">    else if(num &lt; Math.pow(-2, 31))</span><br><span class="line">        return Math.pow(-2, 31);</span><br><span class="line">    else</span><br><span class="line">        return Math.pow(2, 31) - 1;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="类似题型"><a href="#类似题型" class="headerlink" title="类似题型"></a>类似题型</h3><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<p>输入一个字符串,包括数字字母符号,可以为空</p>
<p>如果是合法的数值表达则返回该数字，否则返回0</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">&quot;+2147483647&quot;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">2147483647</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">&quot;1a33&quot;</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h4><p>该题没有上述需要考虑的点，直接使用正则表达式判断是否字符串符合数值表达即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function StrToInt(str)</span><br><span class="line">&#123;</span><br><span class="line">    str &#x3D; str.replace( &#x2F;^\s*&#x2F;, &#39;&#39;);&#x2F;&#x2F;去除开头空格</span><br><span class="line">    if(str.match(&#x2F;^[+-]?[\d]+([\.][\d]+)?([Ee][+-]?[\d]+)?$&#x2F;))&#123;</span><br><span class="line">        let num &#x3D; parseInt(str);</span><br><span class="line">        if(isNaN(num))</span><br><span class="line">            return 0;</span><br><span class="line">        if(num &gt;&#x3D; Math.pow(-2, 31) &amp;&amp; num &lt;&#x3D; Math.pow(2, 31)-1)</span><br><span class="line">            return num;</span><br><span class="line">        else if(num &lt; Math.pow(-2, 31))</span><br><span class="line">            return Math.pow(-2, 31);</span><br><span class="line">        else</span><br><span class="line">            return Math.pow(2, 31) - 1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-05-替换空格"><a href="#剑指-Offer-05-替换空格" class="headerlink" title="剑指 Offer 05. 替换空格"></a>剑指 Offer 05. 替换空格</h2><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>使用正则表达式全局匹配<code>g</code>，再使用<code>replace()</code>方法替换空格。</p>
<h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var replaceSpace &#x3D; function(s) &#123;</span><br><span class="line">    return s.replace(&#x2F;\s&#x2F;g,&quot;%20&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="第一个只出现一次的字符"><a href="#第一个只出现一次的字符" class="headerlink" title="第一个只出现一次的字符"></a>第一个只出现一次的字符</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s &#x3D; &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure>

<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>方法一可以通过查找字符串中每个字符第一次出现的位置和最后一次出现的位置是否匹配来确定是否只出现一次</p>
<p>方法二通过哈希表，若出现一次则+1，最后遍历查询第一个等于一的字符即为所求</p>
<h3 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;character&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var firstUniqChar &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F;et result &#x3D; -1;</span><br><span class="line">    let map &#x3D; &#123;&#125;;</span><br><span class="line">    for(let i &#x3D; 0;i&lt;s.length;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;方法一</span><br><span class="line">        let str &#x3D; s.charAt(i);</span><br><span class="line">        if(s.lastIndexOf(str) &#x3D;&#x3D;&#x3D; s.indexOf(str))&#123;</span><br><span class="line">            return str;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;方法二</span><br><span class="line">        if(map[s.charAt(i)])</span><br><span class="line">            map[s.charAt(i)]++;</span><br><span class="line">        else</span><br><span class="line">            map[s.charAt(i)] &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;方法二</span><br><span class="line">    for(let ch in map)&#123;</span><br><span class="line">        if(map[ch] &#x3D;&#x3D;&#x3D; 1)</span><br><span class="line">            return ch;</span><br><span class="line">    &#125;</span><br><span class="line">    return &quot; &quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">输入: s &#x3D; &quot;lrloseumgh&quot;, k &#x3D; 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>左旋转字符串即为将被旋转的子字符串移到字符串的右边，通过<code>slice()</code>方法切割被旋转的字串，再与切割后子串拼接即可。</p>
<h3 id="解答-6"><a href="#解答-6" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var reverseLeftWords &#x3D; function(s, n) &#123;</span><br><span class="line">    let str &#x3D; s.slice(0,n);</span><br><span class="line">    return s.slice(n,s.length) + str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer（一）-数组</title>
    <url>/post/1858604b.html</url>
    <content><![CDATA[<h2 id="数组中只出现一次的两个数字"><a href="#数组中只出现一次的两个数字" class="headerlink" title="数组中只出现一次的两个数字"></a>数组中只出现一次的两个数字</h2><p>一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[1,4,1,6]</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">[4,6]</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">返回的结果中较小的数排在前面</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>方法一通过哈希表，若出现一次则+1，最后遍历查询值等于一的数字，输出排序后的数组即可。</p>
<p>方法二可以通过查找数组中每个数字第一次出现的位置和最后一次出现的位置是否匹配来确定是否只出现一次，最后再去重排序即可。</p>
<h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="line"> *</span><br><span class="line"> * </span><br><span class="line"> * @param array int整型一维数组 </span><br><span class="line"> * @return int整型一维数组</span><br><span class="line"> *&#x2F;</span><br><span class="line">function FindNumsAppearOnce( array ) &#123;</span><br><span class="line">    let map &#x3D; &#123;&#125;;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for(let i &#x3D; 0; i&lt; array.length;i++)&#123;</span><br><span class="line">        &#x2F;&#x2F;方法一</span><br><span class="line">        if(map[array[i]])</span><br><span class="line">            map[array[i]]++</span><br><span class="line">        else</span><br><span class="line">            map[array[i]] &#x3D; 1;</span><br><span class="line">        &#x2F;&#x2F;方法二</span><br><span class="line">        if(array.indexOf(array[i]) &#x3D;&#x3D;&#x3D; array.lastIndexOf(array[i]))</span><br><span class="line">            result.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;方法一</span><br><span class="line">    for(let num in map)&#123;</span><br><span class="line">        if(map[num] &#x3D;&#x3D;&#x3D; 1)</span><br><span class="line">        result.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;方法二</span><br><span class="line">    result &#x3D; [...new Set(result)];&#x2F;&#x2F;去重</span><br><span class="line">    return result.sort((a,b) &#x3D;&gt; a-b);;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    FindNumsAppearOnce : FindNumsAppearOnce</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a>数组中重复的数字</h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3</span><br></pre></td></tr></table></figure>

<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>将数组排序，遍历排序后的数组，若出现连续相同的数字，则为重复的数字</p>
<h3 id="解答-1"><a href="#解答-1" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findRepeatNumber &#x3D; function(nums) &#123;</span><br><span class="line">    nums.sort((a,b)&#x3D;&gt;a-b);</span><br><span class="line">    for(let i &#x3D; 1;i&lt;nums.length;i++)&#123;</span><br><span class="line">        if(nums[i] &#x3D;&#x3D;&#x3D; nums[i-1])&#123;</span><br><span class="line">            return nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br></pre></td></tr></table></figure>

<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>方法一，使用方法<code>flat()</code>将二维数组展开，再使用<code>include()</code>方法查询是否存在整数</p>
<p>方法二，从左下角或右上角开始寻找, 如果元素相等则退出, 若不等，则根据大小按不同方向查找，即若从左下角开始，target大于当前位置，则向右，否则向上查。</p>
<h3 id="解答-2"><a href="#解答-2" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[][]&#125; matrix</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findNumberIn2DArray &#x3D; function(matrix, target) &#123;</span><br><span class="line">    &#x2F;&#x2F;方法1</span><br><span class="line">    return matrix.flat(2).includes(target);</span><br><span class="line">    &#x2F;&#x2F;方法2</span><br><span class="line">    if(!matrix || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0)</span><br><span class="line">        return false;</span><br><span class="line">    let i &#x3D; matrix.length - 1,j&#x3D;0;</span><br><span class="line">    while(i&gt;&#x3D;0 &amp;&amp; j&lt;matrix[0].length)&#123;</span><br><span class="line">        if(matrix[i][j] &#x3D;&#x3D;&#x3D; target)</span><br><span class="line">            return true;</span><br><span class="line">        else if(matrix[i][j] &gt; target)&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;else if(matrix[i][j] &lt; target)&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="在排序数组中查找数字-I"><a href="#在排序数组中查找数字-I" class="headerlink" title="在排序数组中查找数字 I"></a>在排序数组中查找数字 I</h2><p>统计一个数字在排序数组中出现的次数。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 8</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>查看该数字再数组中第一次<code>indexOf()</code>和最后一次出现的位置<code>lastIndexOf()</code>，若第一次出现的位置为-1，则不存在，否则<code>lastIndexOf() - indexOf() + 1</code>即为数字出现的次数</p>
<h3 id="解答-3"><a href="#解答-3" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @param &#123;number&#125; target</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var search &#x3D; function(nums, target) &#123;</span><br><span class="line">    let index &#x3D; nums.indexOf(target);</span><br><span class="line">    let lastIndex &#x3D; nums.lastIndexOf(target);</span><br><span class="line">    if(index &#x3D;&#x3D; -1)</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">        return lastIndex - index + 1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="构建乘积数组"><a href="#构建乘积数组" class="headerlink" title="构建乘积数组"></a>构建乘积数组</h2><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 <code>B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]</code>。不能使用除法。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: [120,60,40,30,24]</span><br></pre></td></tr></table></figure>

<h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>从两头遍历数组，先计算当前元素之前的乘积值，再计算当前元素之后的乘积值。两值相乘即为当前元素B[i]的值</p>
<h3 id="解答-4"><a href="#解答-4" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; a</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var constructArr &#x3D; function(a) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    let right &#x3D; 1;&#x2F;&#x2F;当前元素后边的值</span><br><span class="line">    result[0] &#x3D; 1;&#x2F;&#x2F;A[0]的值</span><br><span class="line">    if(!a || !a.length)</span><br><span class="line">        return [];</span><br><span class="line">    for(let i &#x3D; 1;i&lt;a.length;i++)&#123;</span><br><span class="line">        result[i] &#x3D; result[i-1] * a[i-1];&#x2F;&#x2F;当前元素之前的乘积值</span><br><span class="line">    &#125;</span><br><span class="line">    for(let j &#x3D; a.length - 2;j&gt;&#x3D;0;j--)&#123;</span><br><span class="line">        right *&#x3D; a[j+1];</span><br><span class="line">        result[j] *&#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="把数组排成最小的数"><a href="#把数组排成最小的数" class="headerlink" title="把数组排成最小的数"></a>把数组排成最小的数</h2><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: &quot;102&quot;</span><br><span class="line"></span><br><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>

<h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>构造一个新的sort方法，若数组中数字位数相同，则按从小到大排列，若数组中位数不同，则查看两个数字合起来a+b/b+a哪个最小则按哪个排。</p>
<p>最后使用<code>join()</code>方法输出排序好的数组组成的字符串即可</p>
<h3 id="解答-5"><a href="#解答-5" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var minNumber &#x3D; function(nums) &#123;</span><br><span class="line">   nums.sort((a,b)&#x3D;&gt;&#123;</span><br><span class="line">       if(a.toString().length &#x3D;&#x3D;&#x3D; b.toString().length)</span><br><span class="line">            return a-b;</span><br><span class="line">        else&#123;</span><br><span class="line">            return parseInt(a.toString() + b.toString()) - parseInt(b.toString() + a.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;);</span><br><span class="line">   return nums.join(&quot;&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a>数组中出现次数超过一半的数字</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。 </p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>先将数组排序，再遍历数组查询每个数字第一次<code>indexOf()</code>和最后一次出现的位置<code>lastIndexOf()</code>，查看两者之差<code>lastIndexOf() - indexOf() + 1</code>，即出现的次数。</p>
<p>若出现的次数&lt;数组长度的一半，则跳过，</p>
<p>若出现的次数&gt;数组长度的一半，则与当前出现次数的最大值对比，存储更大的值。</p>
<p>最后输出出现次数最多的数字。</p>
<h3 id="解答-6"><a href="#解答-6" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var majorityElement &#x3D; function(nums) &#123;</span><br><span class="line">    nums.sort((a,b)&#x3D;&gt;&#123;return a-b;&#125;);</span><br><span class="line">    let len &#x3D; nums.length &#x2F;2;</span><br><span class="line">    let max &#x3D; 0;</span><br><span class="line">    let index &#x3D; 0;</span><br><span class="line">    if(nums.length &#x3D;&#x3D;&#x3D; 1)</span><br><span class="line">        return nums[0];</span><br><span class="line">    for(let i &#x3D; 0;i&lt;nums.length;i++)&#123;</span><br><span class="line">        let first &#x3D; nums.indexOf(nums[i]);</span><br><span class="line">        let last &#x3D; nums.lastIndexOf(nums[i]);</span><br><span class="line">        let dif &#x3D; last - first + 1;</span><br><span class="line">        if(dif &#x3D;&#x3D;&#x3D; 0 || dif &lt;&#x3D; len)&#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;else if(dif &gt; len)&#123;</span><br><span class="line">            if(dif &gt; max)&#123;</span><br><span class="line">                max &#x3D; dif;</span><br><span class="line">                index &#x3D; i;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            return nums[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br></pre></td></tr></table></figure>

<h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>使用双指针从数组头尾开始搜索，若左边遇到偶数则与右边出现的奇数交换。</p>
<h3 id="解答-7"><a href="#解答-7" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;number[]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var exchange &#x3D; function(nums) &#123;</span><br><span class="line">    let i&#x3D;0,j&#x3D;nums.length-1;</span><br><span class="line">    while(i&lt;j)&#123;</span><br><span class="line">        while(nums[i]%2 &#x3D;&#x3D;&#x3D; 1)</span><br><span class="line">            i++;</span><br><span class="line">        while(nums[j]%2 &#x3D;&#x3D;&#x3D; 0)</span><br><span class="line">            j--;</span><br><span class="line">        if(i&lt;j)&#123;</span><br><span class="line">            </span><br><span class="line">            [nums[i],nums[j]] &#x3D; [nums[j],nums[i]];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="寻找两个正序数组的中位数"><a href="#寻找两个正序数组的中位数" class="headerlink" title="寻找两个正序数组的中位数"></a>寻找两个正序数组的中位数</h2><p>给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,3], nums2 &#x3D; [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3] ，中位数 2</span><br><span class="line"></span><br><span class="line">输入：nums1 &#x3D; [1,2], nums2 &#x3D; [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 &#x3D; [1,2,3,4] ，中位数 (2 + 3) &#x2F; 2 &#x3D; 2.5</span><br></pre></td></tr></table></figure>

<h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>合并两个数组，并排序，若新数组长度为奇数，则中位数为其中间的一个值<code>num[num.length/2]</code>。若长度为偶数，则为中间两个数的平均值</p>
<h3 id="解答-8"><a href="#解答-8" class="headerlink" title="解答"></a>解答</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; nums1</span><br><span class="line"> * @param &#123;number[]&#125; nums2</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var findMedianSortedArrays &#x3D; function(nums1, nums2) &#123;</span><br><span class="line">    let num &#x3D; nums1.concat(nums2);   </span><br><span class="line">    if(num.length &amp;&amp; num)&#123;</span><br><span class="line">        num.sort((a,b)&#x3D;&gt;&#123;</span><br><span class="line">            return a-b;</span><br><span class="line">        &#125;);</span><br><span class="line">        let a &#x3D; Math.floor(num.length &#x2F; 2);</span><br><span class="line">        if(num.length % 2 &#x3D;&#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return (num[a] + num[a-1])&#x2F;2;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return num[a];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="和为S的两个数字"><a href="#和为S的两个数字" class="headerlink" title="和为S的两个数字"></a>和为S的两个数字</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<p>返回值描述：<br>对应每个测试案例，输出两个数，小的先输出。</p>
<p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[1,2,4,7,11,15],15</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">[4,11]</span><br></pre></td></tr></table></figure>

<h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>循环遍历数组，计算和与当前元素的差，构建对象存储所有的差值，若当前差值存在，则计算差值和当前值的乘积，并与当前最小乘积对比，存储更小的值。若当前差值不存在，则将当前差值织wei</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>近期知识点总结</title>
    <url>/post/a3c7594b.html</url>
    <content><![CDATA[<p>js基本类型</p>
<p>基本类型：string null undefined number boolean symbol（es6引入）复杂类型：object array date regexp function 基本包装类型：boolean number string 单体内置对象：global math</p>
<p>数组flat方法</p>
<p>es6数组交换</p>
<a id="more"></a>

<p>[a,b]=[b,a]</p>
<p>数组sort()方法对于number元素是按字符sort，按number大小需要自己写方法</p>
<p>arr.sort((a,b)=&gt;a-b)</p>
<p>a-b====顺序</p>
<p>b-a====逆序</p>
<p>split方法属于str，其他不可用</p>
<p>splice方法属于数组，添加或删除元素</p>
<p>includes()数组，找是否存在某值，存在true 不存在false</p>
<p>原生js父节点  element.parentNode</p>
<p>Ajax技术核心就是XMLHttpRequest对象。<br>Ajax技术的工作原理：可以分成3步<br>1.创建Ajax对象：var xhr = new XMLHttpRequest();<br>2.xhr 发送请求：xhr.open(‘get’,’test.html’,’true’);<br>    xhr.send();<br>3.xhr获取响应：<br>    xhr.onreadystatechange = function(){<br>        if(xhr.readystate == 4){//请求的状态码<br>            /*<br>                        0:请求还没有建立（open执行前）<br>                        1：请求建立了还没发送（执行了open）<br>                        2：请求正式发送（执行了send）<br>                        3：请求已受理，有部分数据可以用，但还没有处理完成<br>                        4：请求完全处理完成<br>                */<br>                alert(xhr.responseText);//返回的数据<br>        }<br>    }<br>可以看到，send()前是open()</p>
<p>javascript中实现跨域的方式总结<br>第一种方式：jsonp请求；jsonp的原理是利用<script>标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有<img>.<br>第二种方式：document.domain；这种方式用在主域名相同子域名不同的跨域访问中<br>第三种方式：window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。<br>第四种方式：window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。<br>第五种方式：CORS；CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。<br>第六种方式：Web Sockets；web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</p>
<p>js原型遵循5个规则： 1、所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null”以外）； 2、所有的引用类型（数组、对象、函数），都有一个<strong>proto</strong>（隐式原型）属性，属性值是一个普通的对象； 3、所有的函数，都有一个prototype（显式原型）属性，属性值也是一个普通对象； 4、所有的引用类型（数组、对象、函数），<strong>proto</strong>属性值指向（完全相等）它的构造函数的“prototype”属性值； 5、当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去<strong>proto</strong>（即它的构造函数的prototype中）寻找。</p>
]]></content>
  </entry>
  <entry>
    <title>前端面经总结（二）</title>
    <url>/post/45e5d827.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/5eb40cb7.html">前端面经总结（一）</a></p>
<h3 id="HTML语义化标签理解"><a href="#HTML语义化标签理解" class="headerlink" title="HTML语义化标签理解"></a>HTML语义化标签理解</h3><p>语义化即元素本身穿大了关于标签所包含内容类型的一些信息。如<code>&lt;header&gt;</code>、<code>&lt;nav&gt;</code>、<code>&lt;article&gt;</code>、<code>&lt;aside&gt;</code>、<code>&lt;footer&gt;</code>等，使用语义化标签<strong>有利于呈现更好的内容结构</strong>，<strong>有利于SEO</strong>，并<strong>提升用户体验</strong>，<strong>便于团队开发维护</strong>，以及<strong>方便其他设备解析渲染页面</strong>，如屏幕阅读器，移动设备等。</p>
<h3 id="RESTful理解"><a href="#RESTful理解" class="headerlink" title="RESTful理解"></a>RESTful理解</h3><p>URL中使用名词定位资源，用HTTP动词（GET,POST,DELETE等）描述操作。</p>
<a id="more"></a>
<h3 id="iframe通信"><a href="#iframe通信" class="headerlink" title="iframe通信"></a>iframe通信</h3><ul>
<li><p>父子页面通信</p>
<p>  互相调用对方的方法。如<code>window.parent.父级方法</code>、<code>document.getElementById(&quot;id&quot;).contentWindow.子页面方法</code>.</p>
</li>
<li><p>localStorage/sessionStorage</p>
</li>
<li><p>不同源</p>
<ul>
<li><p>postMessage()</p>
<p>  父页面使用<code>addEventListener()</code>，子页面通过<code>window.parent</code>获取父页面后使用<code>window.postMessage()</code>。</p>
</li>
<li><p>在window上注册方法，在子iframe中调用。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父页面：window[&quot;messageStr&quot;]&#x3D;function(arg)&#123;console.log(arg)&#125;；</span><br><span class="line">    　　 子页面：window.parent.messageStr(&quot;from child&quot;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><blockquote>
<p>浏览器缓存：浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器可以直接从本地磁盘加载文档</p>
</blockquote>
<h4 id="分类：强缓存-协商缓存"><a href="#分类：强缓存-协商缓存" class="headerlink" title="分类：强缓存/协商缓存"></a>分类：强缓存/协商缓存</h4><p>浏览器进行资源请求时，判断<code>response headers</code>是否命中<code>强缓存</code>，若命中，资源的<code>State</code>状态码为<code>200(from cache)</code>，直接从本地读取缓存，不向服务器发送请求。若没有命中，发送请求到<code>服务端</code>，判断<code>协商缓存</code>是否命中，若命中，资源<code>State</code>状态码为<code>304(not modified)</code>，服务器将请求返回，不返回资源，告诉浏览器从本地读取缓存，若没命中则服务器直接返回资源。</p>
<p>两者都是从客户端读取资源，但强缓存不会发请求。</p>
<ul>
<li><p>强缓存</p>
<p>  强缓存利用http头中<code>Expires</code>和<code>Cache-Control</code>两个字段控制，用来表示资源的缓存时间。强缓存被普通刷新忽略但不清除它，需要强制刷新清除。强制刷新请求<code>Cache-Control:no-cache</code>和<code>Pragma=no-cache</code>。只有在地址栏或收藏夹输入网址或通过链接引用资源等情况，强缓存才会被浏览器启用。</p>
<ul>
<li><p>Expires：失效时间</p>
<p>  http1.0的规范，一个绝对时间的GMT格式的时间字符串。用来表示资源的失效时间，但当同时出现<code>Cache-Control:max-age</code>时，优先<code>max-age</code>。</p>
</li>
<li><p>Cache-Control</p>
<p>  http1.1的规范，利用其<code>max-age</code>值来判断，是一个相对时间，代表资源的有效期。其他值有<code>no-cache</code>-不使用缓存、<code>no-store</code>-禁止浏览器缓存数据、<code>public</code>-可以被所有用户缓存、<code>private</code>-只能被终端用户的浏览器缓存，不允许中继缓存服务器对其缓存。</p>
</li>
</ul>
</li>
<li><p>协商缓存</p>
<p>  由服务器确定缓存资源是否可用。涉及两组头部字段<code>Etag</code>+<code>If-None-Match</code>、<code>Last-Modified</code>+<code>If-Modified-Since</code>。</p>
<ul>
<li><p>Etag/If-None-Match</p>
<p>  Etag/If-None-Match返回一个校验码。<code>Etag</code>保证每个资源是唯一的，资源变化则<code>Etag</code>变化。服务器根据<code>If-None-Match</code>判断是否命中缓存。当服务器返回<code>304</code>时，<code>Etag</code>仍会返回，但跟之前的相同，没有变化。</p>
</li>
<li><p>Last-Modify/If-Modified-Since</p>
<p>  Last-Modify表示资源的最后修改时间。当浏览器再次请求资源时，request请求头包含<code>If-Modify-Since</code>，为缓存之前返回的<code>Last-Modify</code>，服务器收到后根据资源最后修改时间判断是否命中缓存。</p>
<p>当<code>Last-Modify</code>和<code>Etag</code>一起使用时，优先验证<code>Etag</code>，验证一致才会对比<code>Last-Modify</code>。</p>
</li>
</ul>
</li>
</ul>
<h4 id="如何判断什么时候用强缓存，什么时候用协商缓存"><a href="#如何判断什么时候用强缓存，什么时候用协商缓存" class="headerlink" title="如何判断什么时候用强缓存，什么时候用协商缓存"></a>如何判断什么时候用强缓存，什么时候用协商缓存</h4><p>在缓存有效期内命中缓存，浏览器直接读取本地缓存。当缓存过期后与服务器协商，判断<code>Etag/Last-Modify</code>，若服务器返回<code>304</code>则读取本地缓存。</p>
<h3 id="地址栏输入一个URL到页面呈现中间发生什么"><a href="#地址栏输入一个URL到页面呈现中间发生什么" class="headerlink" title="地址栏输入一个URL到页面呈现中间发生什么"></a>地址栏输入一个URL到页面呈现中间发生什么</h3><ol>
<li><p>在浏览器输入<code>URL</code></p>
</li>
<li><p>浏览器查看缓存是否有此<code>URL</code>相关的信息，若有，直接显示页面内容。</p>
</li>
<li><p>若没有，浏览器将请求的<code>URL</code>交给<code>DNS</code>解析获取网址的<code>IP地址</code>。</p>
</li>
<li><p>浏览器向服务器发起<code>tcp连接</code>，通过<code>三次握手</code>建立连接。</p>
</li>
<li><p>连接成功后向服务器发送<code>http请求</code>，请求数据包</p>
</li>
<li><p>服务器处理请求，若浏览器之前访问过，且缓存有对应资源，便与服务器最后修改时间对比，若一致返回<code>304</code>，告诉浏览器使用本地缓存。</p>
</li>
<li><p>浏览器接收到报文后开始下载网页。</p>
</li>
<li><p>下载完的网页交给浏览器内核渲染，其中将<code>HTML</code>网页和资源构建成节点，组建<code>DOM树</code>，同时<code>CSS解释器</code>将<code>CSS文件</code>解释成内部表示结构，生成<code>CSS规则树</code>。</p>
</li>
<li><p>合并<code>CSS规则树</code>和<code>DOM树</code>，生成<code>render渲染树</code>，最后将其布局绘制最终显示。</p>
</li>
</ol>
<h3 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h3><ol>
<li><p>减少<code>HTTP</code>请求次数，即压缩<code>JS</code>、<code>CSS</code>源码，控制图片大小，合并资源等。</p>
</li>
<li><p>避免多余的中间访问，即重定向</p>
</li>
<li><p>减少<code>DOM</code>元素、<code>iframe</code>、<code>404</code>页面数量</p>
</li>
<li><p>减小<code>cookie</code></p>
</li>
<li><p>从外部引入<code>JavaScript</code>和<code>CSS</code></p>
</li>
<li><p>合理设计事件监听</p>
</li>
<li><p>优化<code>CSS Sprites</code></p>
</li>
<li><p>减少<code>DNS</code>查询次数（不要嵌入过多推案和脚本）</p>
</li>
</ol>
<h4 id="首页加载缓慢，如何优化"><a href="#首页加载缓慢，如何优化" class="headerlink" title="首页加载缓慢，如何优化"></a>首页加载缓慢，如何优化</h4><ol>
<li><p>设置浏览器缓存：添加expires/cache-control</p>
</li>
<li><p>使用CDN加速</p>
</li>
<li><p>使用redis等手段快速获取数据</p>
</li>
<li><p>提高sql查询速度</p>
</li>
<li><p>提前生成相关数据，预加载</p>
</li>
<li><p>压缩组件</p>
</li>
<li><p>按照页面或组件分块懒加载，使用到组件时，才想服务器请求文件，再次使用时即可使用缓存。</p>
</li>
<li><p>尽可能缩小打包后生成的包大小</p>
</li>
</ol>
<h3 id="GET-POST区别"><a href="#GET-POST区别" class="headerlink" title="GET/POST区别"></a>GET/POST区别</h3><ol>
<li><p>GET通过<code>url</code>传递，POST在<code>request body</code>中</p>
</li>
<li><p>GET请求传递的参数长度有限制，POST没有限制</p>
</li>
<li><p>GET安全性较差，所发送的数据是<code>URL</code>的一部分，POST更安全，参数不会保存在浏览器历史或web服务其日志</p>
</li>
<li><p>GET数据所有人可见，POST不可见</p>
</li>
<li><p>GET用于获取信息，POST用于修改服务器数据</p>
</li>
</ol>
<blockquote>
<p>HTTP支持的方法：GET、POST、HEAD、OPTIONS、DELETE、TRACE、CONNECT</p>
</blockquote>
<h3 id="HTML5新增内容"><a href="#HTML5新增内容" class="headerlink" title="HTML5新增内容"></a>HTML5新增内容</h3><ol>
<li><p>增加一些语义元素<code>header</code>、<code>section</code>、<code>footer</code>、<code>main</code>、<code>article</code>、<code>aside</code>等</p>
</li>
<li><p>增加新的表单控件<code>email</code>、<code>search</code>、<code>url</code>等和新的<code>input</code>类型<code>date</code>、<code>datetime</code>等</p>
</li>
<li><p>移除过时的标签<code>big</code>、<code>frame</code>等</p>
</li>
<li><p>增加多媒体<code>audio</code>、<code>video</code>、<code>source</code>等</p>
</li>
<li><p>web存储，<code>localStorage</code>和<code>sessionStorage</code></p>
</li>
<li><p>新增绘画元素<code>canvas</code></p>
</li>
<li><p>可伸缩矢量图形<code>svg</code></p>
</li>
</ol>
<h3 id="HTTP常见头部"><a href="#HTTP常见头部" class="headerlink" title="HTTP常见头部"></a>HTTP常见头部</h3><ol>
<li><p>请求头</p>
<ul>
<li><p>accept：可接受的响应内容类型</p>
</li>
<li><p>Authorization：用于表示HTTP协议中需要认证资源的认证信息</p>
</li>
<li><p>Cache-Control：用来指定当前请求/response中缓存机制</p>
</li>
<li><p>cookie：由服务器通过<code>Set-Cookie</code>设置的HTTP协议Cookie</p>
</li>
</ul>
</li>
<li><p>响应头</p>
<ul>
<li><p>Status：说明当前HTTP连接的响应状态</p>
</li>
<li><p>Set-Cookie：设置HTTP Cookie</p>
</li>
<li><p>Expires： 指定资源失效时间</p>
</li>
</ul>
</li>
</ol>
<h3 id="怎么看网站性能"><a href="#怎么看网站性能" class="headerlink" title="怎么看网站性能"></a>怎么看网站性能</h3><ol>
<li><p>在页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库分析</p>
</li>
<li><p>搭建受控环境，使用第三方工具模拟用户发起页面访问请求，主动采集数据分析。</p>
</li>
</ol>
<h3 id="options预检请求作用"><a href="#options预检请求作用" class="headerlink" title="options预检请求作用"></a>options预检请求作用</h3><p>浏览器对复杂跨域请求在真正发送请求之前,会先进行一次预请求,就是参数为OPTIONS的请求。其作用是检查服务器响应是否正确,即是否能接受真正的请求,如果在options请求之后获取到的响应是拒绝性质的,例如500等http状态,那么它就会停止第二次的真正请求的访问。</p>
<h3 id="浏览器的渲染原理"><a href="#浏览器的渲染原理" class="headerlink" title="浏览器的渲染原理"></a>浏览器的渲染原理</h3><ol>
<li><p>解析HTML文档生成DOM树</p>
</li>
<li><p>解析CSS样式，生成CSSOM树，和HTML无先后顺序</p>
</li>
<li><p>根据DOM树和CSSOM树生成用于渲染的渲染树render tree</p>
</li>
<li><p>对渲染树的每个节点进行布局处理，确定在屏幕上的显示位置</p>
</li>
<li><p>遍历渲染树用UI将每个节点绘制出来。</p>
</li>
</ol>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><ol>
<li><p>OSI七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<ul>
<li><p>应用层：HTTP/FTP/SMTP等</p>
</li>
<li><p>表示层：Telnet等</p>
</li>
<li><p>会话层：SMTP/DNS</p>
</li>
<li><p>传输层：TCP/UDP</p>
</li>
<li><p>网络层：IP/ICMP/ARP等</p>
</li>
<li><p>数据链路层：PPP等</p>
</li>
<li><p>物理层：IEEE 802.1等</p>
</li>
</ul>
</li>
<li><p>TCP/IP四层模型：应用层、运输层、网际层和网络接口层。</p>
<ul>
<li><p>网络接口层：网络接口</p>
</li>
<li><p>网际层：IP</p>
</li>
<li><p>运输层：TCP/UDP</p>
</li>
<li><p>应用层：HTTP/DNS/SMTP</p>
</li>
</ul>
</li>
<li><p>五层体系结构：应用层、运输层、网络层、数据链路层、物理层</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>面经</tag>
        <tag>http</tag>
        <tag>HTML</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面经总结（一）</title>
    <url>/post/5eb40cb7.html</url>
    <content><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h3><blockquote>
<p>http： 超文本传输协议，一种网络协议，一个客户端和服务器端请求和应答的标准（TCP）。</p>
</blockquote>
<blockquote>
<p>https：http的安全版，以安全为目标的HTTP通道。即在HTTP下加入SSL层。用于建立一个信息安全通道，来确保数据的传输以及网站的真实性</p>
</blockquote>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>http传输的数据是未加密的，是明文。https传输的数据通过SSL协议进行了加密处理，安全性更高。</p>
</li>
<li><p>https需要ca证书，http不需要。</p>
</li>
<li><p>http协议的端口是80，https协议的端口为443.</p>
</li>
<li><p>http的链接是无状态的，https的链接由SSL和HTTP协议构建。</p>
</li>
</ol>
<a id="more"></a>

<h4 id="https协议工作原理"><a href="#https协议工作原理" class="headerlink" title="https协议工作原理"></a>https协议工作原理</h4><ol>
<li><p>客户端使用https url访问服务器，要求web服务器建立ssl链接</p>
</li>
<li><p>web服务器收到请求，将网站包含公钥的证书返回给客户端</p>
</li>
<li><p>客户端和web服务器协商ssl链接的安全等级，即加密登记</p>
</li>
<li><p>协商一致后，建立会话密钥，通过网站公钥加密会话密钥传送给网站</p>
</li>
<li><p>web服务器使用自己的私钥解密会话密钥</p>
</li>
<li><p>web服务器通过会话密钥加密与客户端间的通信</p>
</li>
</ol>
<h4 id="https协议优缺点"><a href="#https协议优缺点" class="headerlink" title="https协议优缺点"></a>https协议优缺点</h4><ol>
<li><p>优点：加密传输，身份认证，确保数据正确安全的发送</p>
</li>
<li><p>缺点</p>
<ul>
<li><p>https握手阶段较费时，页面加载时间延长50%，增加10%～20%耗电</p>
</li>
<li><p>https缓存不如http高效，增加了数据开销</p>
</li>
<li><p>ssl证书有费用</p>
</li>
<li><p>ssl证书需要绑定ip，不能在同一个ip绑定多个域名</p>
</li>
</ul>
</li>
</ol>
<h3 id="tcp三次握手"><a href="#tcp三次握手" class="headerlink" title="tcp三次握手"></a>tcp三次握手</h3><ol>
<li><p>客户端发请求连接服务端</p>
</li>
<li><p>服务端确认连接，并发送请求链接客户端</p>
</li>
<li><p>客户端确认连接</p>
</li>
</ol>
<p>同一个域名也需要三次握手</p>
<h3 id="tcp和udp区别"><a href="#tcp和udp区别" class="headerlink" title="tcp和udp区别"></a>tcp和udp区别</h3><ol>
<li><p>tcp面向连接，udp无连接，发送数据前不需要先建立连接</p>
</li>
<li><p>tcp提供可靠服务，无差错，不丢失，不重复，按序到达。udp尽最大努力交付，不可靠。</p>
</li>
<li><p>tcp面向字节流，udp面向报文会丢包。</p>
</li>
<li><p>tcp只能1对1，udp支持1对1，1对多</p>
</li>
<li><p>tcp首部20字节，udp8字节</p>
</li>
</ol>
<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><blockquote>
<p>websocket是HTML5中的协议，基于HTTP协议，支持持久性连接。匀速服务端主动向客户端推送数据，且在Websocket API中浏览器和服务器只需要完成一次握手即可创建持久性的连接，开始双向数据传输</p>
</blockquote>
<p>建立一个<code>WebSocket</code>连接，客户端浏览器首先要向服务器发起一个<code>HTTP</code>请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息<code>Upgrade: WebSocket</code>表明这是一个申请协议升级的<code>HTTP</code>请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的WebSocket连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Upgrade:webSocket</span><br><span class="line">Connection:Upgrade</span><br></pre></td></tr></table></figure>

<h4 id="websocket和socket区别"><a href="#websocket和socket区别" class="headerlink" title="websocket和socket区别"></a>websocket和socket区别</h4><blockquote>
<p>socket是应用层与TCP/IP协议族通信的中间软件抽象层，是一组接口。当两台主机通信时，socket来组织数据，以符合指定的协议。</p>
</blockquote>
<p>websocket是应用层协议，socket是传输控制层协议。</p>
<h3 id="http中keep-alive模式"><a href="#http中keep-alive模式" class="headerlink" title="http中keep-alive模式"></a>http中keep-alive模式</h3><blockquote>
<p>keep-alive模式即持久连接、连接重用。keep-alive模式使客户端到服务端的连接持续有效，当出现对服务器的后继请求时，keep-alive避免了建立或重新建立连接。且HTTP1.1中的keep-alive将多个请求合并为一个，即发送多个request接受多个response。但每个request只能对应一个response。。</p>
</blockquote>
<p>http1.0中keep-alive模式默认关闭，需要在http头加入<code>Connection:Keep-Alive</code>启用。http1.1中默认启用keep-alive，需要加入<code>Connection:close</code>才关闭。</p>
<p>启用keep-alive模式避免了建立/释放连接的开销，故更高效，性能更高。</p>
<h4 id="与tcp中keep-alive的区别"><a href="#与tcp中keep-alive的区别" class="headerlink" title="与tcp中keep-alive的区别"></a>与tcp中keep-alive的区别</h4><p>tcp中keep-alive是一种检测tcp连接状况的定时器，用于检测连接是否丢失，即连接建立后长时间不发送数据或隔很长时间才发送数据，当超过一定时间后（tcp_keepalive_time），tcp发送一个数据为空的报文，若回应了则对方在线，连接可以继续保持，若多次发送均未回应，则说明连接丢失，不需要保持连接。</p>
<p>http中keep-alive模式是为了使连接的时间更长一些，以便在一个连接传送多个http，提高效率。</p>
<h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><blockquote>
<p>http2.0是基于1999年发布的http1.0的首次更新。</p>
</blockquote>
<p>新特性：</p>
<ul>
<li><p>提升访问速度：请求资源所需时间更少，访问速度更快</p>
</li>
<li><p>允许多路复用：在一个HTTP的连接上，多路“HTTP消息”同时工作。</p>
</li>
</ul>
<p>流程：建立tcp连接后，可乱序交错发出多个由二进制帧组成的信息流，每个流都有独一无二的标识和优先级，在接收端接受到信息流后，根据帧头的信息组装成完整的数据。</p>
<ul>
<li><p>二进制分帧：新增二进制分帧层将所有传输信息分割为更小的消息和帧，并对他们采取二进制的编码封装。其中首部信息header封装到Headers帧中，request body封装到Data帧中。</p>
</li>
<li><p>首部压缩：http/2使用hpack算法来减少传输的header大小。通讯双方格子缓存一份头部字段表，避免了重复header的传输，也减少了需要传输的大小。</p>
</li>
</ul>
<blockquote>
<p>hpack算法使用一份索引表定义常用的http Header，将常用的http Header存在表里。请求时只需要发送表里的索引位置。同时将字符串进行霍夫曼编码来压缩字符串大小。</p>
</blockquote>
<ul>
<li>服务器端推送：服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。</li>
</ul>
<h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>1**：信息，服务器收到请求，需要请求者继续执行操作</li>
<li>2**：成功，操作被成功接收并处理</li>
<li>3**：重定向，需要进一步的操作以完成请求</li>
<li>4**：客户端错误，请求包含语法错误或无法完成请求</li>
<li>5**：服务器错误，服务器在处理请求的过程中发生了错误</li>
</ul>
<h4 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h4><ol>
<li><p>200：请求成功，一般用于GET、POST请求</p>
</li>
<li><p>206：服务器成功处理了部分GET请求。可用于下载工具断点续传或将大文档分解为多个下载段同时下载。</p>
</li>
<li><p>301：永久重定向。被请求的资源已永久移动到新位置，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</p>
</li>
<li><p>302：临时重定向。被请求的资源临时从不同的URI响应请求，客户端应继续使用原有URI。</p>
</li>
<li><p>304：Not Modified未修改。所请求的资源未修改。如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。</p>
<p> 解决：</p>
<ul>
<li><p>设置强制不缓存<code>Cache-Control=no-cache</code></p>
</li>
<li><p>及时定期更新页面内容</p>
</li>
<li><p>同步更新CDN缓存</p>
<p>Cache-Control属性：常见的取值有private、no-cache、max-age、must-revalidate等，默认为private。</p>
<blockquote>
<p>cache-control是一个通用消息头字段被用于HTTP请求和响应中，通过指定指令来实现缓存机制，这个缓存指令是单向的</p>
</blockquote>
</li>
<li><p>no-cache：客户端请求携带此字段，则经过缓存服务器时不读缓存资源。</p>
</li>
<li><p>no-store：告知服务器/客户端/中间服务器，请求/响应信息中有机密信息，无需响应。</p>
</li>
<li><p>max-age：最大缓存市场。标识客户端不接收age大于此设定时间的响应。</p>
</li>
<li><p>min-fresh：最小缓存时长</p>
</li>
<li><p>no-transform：缓存不能改变实体主题的媒体类型。</p>
</li>
<li><p>等。。。</p>
</li>
</ul>
</li>
<li><p>400：请求无效。</p>
<p> 原因：前端提交数据的字段名称和类型与后端的实体不一致，或前端提交的数据不是<code>json</code>字符串类型。</p>
<p> 解决：保持数据字段的一致性，将数据通过<code>JSON.stringify</code>实现序列化。</p>
</li>
<li><p>401：未授权，当前请求需要用户验证。</p>
</li>
<li><p>403：禁止访问，服务器得到请求但拒绝执行。</p>
</li>
<li><p>404：文件未找到，无效链接。原因有url拼写错误或页面不存在等</p>
</li>
<li><p>500：内部服务器错误。</p>
</li>
<li><p>502：无效网关。</p>
</li>
</ol>
<h3 id="实用的BOM属性方法。"><a href="#实用的BOM属性方法。" class="headerlink" title="实用的BOM属性方法。"></a>实用的BOM属性方法。</h3><blockquote>
<p>BOM：浏览器对象</p>
</blockquote>
<ol>
<li><p>location对象</p>
<ul>
<li><p>location.href: 返回/设置当前文档的URL</p>
</li>
<li><p>location.search: 返回URL中查询字符串部分。即返回包括<code>?</code>及其后面的部分。</p>
</li>
<li><p>location.hash: 返回URL中<code>#</code>后面的内容，若没有返回空</p>
</li>
<li><p>location.host: 返回URL的域名部分。</p>
</li>
<li><p>location.pathname: 返回URL域名后的部分，即<code>/</code>后的内容</p>
</li>
<li><p>location.port: 返回URL的端口部分</p>
</li>
<li><p>location.reload(): 重载当前页面</p>
</li>
</ul>
</li>
<li><p>history对象</p>
<ul>
<li><p>history.go(num): 前进/后退<code>num</code>页</p>
</li>
<li><p>history.back(): 后退一页</p>
</li>
<li><p>history.forward(): 前进一页</p>
</li>
</ul>
</li>
</ol>
<h3 id="为什么fetch发送2次请求"><a href="#为什么fetch发送2次请求" class="headerlink" title="为什么fetch发送2次请求"></a>为什么fetch发送2次请求</h3><p>使用<code>fetch</code>的<code>post</code>请求时，<code>fetch</code>第一次发送<code>Options</code>请求询问服务器是否支持修改的请求头，若支持，<code>fetch</code>第二次发送真正的请求。</p>
<h3 id="cookie、session、localStorage、sessionStorage区别"><a href="#cookie、session、localStorage、sessionStorage区别" class="headerlink" title="cookie、session、localStorage、sessionStorage区别"></a>cookie、session、localStorage、sessionStorage区别</h3><ul>
<li><p>cookie：用来跟踪浏览器用户身份的会话方式。<code>cookie</code>可以在前后端进行用户的身份认证，标记用户。以文本的方式保存在客户端每次请求都带着<code>cookie</code></p>
</li>
<li><p>session：用来跟踪浏览器用户身份的会话方式。<code>session</code>由<code>cookie</code>进行标记</p>
</li>
<li><p>localStorage：本地存储，是WebStorage的API，使用<code>window.localStorage</code>获取。</p>
</li>
<li><p>sessionStorage：会话存储，是WebStorage的API，使用<code>window.sessionStorage</code>获取。</p>
</li>
</ul>
<h4 id="cookie与session区别"><a href="#cookie与session区别" class="headerlink" title="cookie与session区别"></a>cookie与session区别</h4><ol>
<li><p>保持状态：<code>cookie</code>保存在浏览器端。<code>session</code>保存在服务器端。</p>
</li>
<li><p>存储内容：<code>cookie</code>只能保存字符串类型，以文本的方式。<code>session</code>通过类似哈希表的数据结构保存，支持任何类型的对象</p>
</li>
<li><p>存储大小：单个<code>cookie</code>保存的数据不能超过<code>4kb</code>。<code>session</code>大小没有限制。</p>
</li>
<li><p>安全性：<code>session</code>安全性大于<code>cookie</code>。</p>
<p> 原因：<code>sessionID</code>保存在<code>cookie</code>中，且<code>sessionID</code>有人登陆或启动<code>session_start</code>才会有，第二次启用时，前一次的<code>session</code>过期，<code>sessionID</code>失效，且<code>sessionID</code>是加密的。</p>
</li>
<li><p>使用方式：</p>
<ul>
<li><p>cookie：若浏览器中未设置过期时间，<code>cookie</code>保存在内存中，生命周期随浏览器的关闭而结束，即<code>会话cookie</code>。若浏览器中设置了过期时间，<code>cookie</code>保存在硬盘中，关闭浏览器后<code>cookie</code>仍存在，仅当过期时间结束才消失</p>
</li>
<li><p>session：服务器收到请求创建<code>session</code>，首先检查客户端请求是否包含<code>sessionID</code>，若有，则根据该id返回对应<code>session</code>对象。若没有，则创建新的<code>session</code>对象并使用<code>cookie</code>方式存储<code>sessionID</code>并在本次响应中返回给客户端。</p>
</li>
</ul>
</li>
<li><p>应用场景：</p>
<ul>
<li><p>cookie：判断用户是否登陆过，以便下次登陆；保存上次登陆的时间等信息；保存上次查看的页面；浏览计数</p>
</li>
<li><p>session：保存每个用户的专用信息，变量的值保存在服务端，通过<code>sessionID</code>来区分不同用户。</p>
</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>cookie：大小受限、用户可以禁用<code>cookie</code>、安全性较低、每次访问都要传送，浪费带宽、<code>cookie</code>数据有路径概念，可以限制<code>cookie</code>只属于某个路径下。</p>
</li>
<li><p>session：保存的东西越多越占内存，服务器的内存压力较大、依赖于<code>cookie</code>，若禁用<code>cookie</code>，需要使用URL重写，不安全、创建<code>session</code>变量随意性大，过度使用导致代码不可读且不好维护。</p>
<p>  如果用户禁用<code>cookie</code>，则要使用URL重写，可以通过<code>response.encodeURL(url)</code>进行实现；API对<code>encodeURL</code>的结束为，当浏览器支持<code>cookie</code>时，url不做任何处理；当浏览器不支持<code>cookie</code>的时候，将会重写URL将<code>sessionID</code>拼接到访问地址后。</p>
</li>
</ul>
</li>
</ol>
<h4 id="cookie、localStorage、sessionStorage区别"><a href="#cookie、localStorage、sessionStorage区别" class="headerlink" title="cookie、localStorage、sessionStorage区别"></a>cookie、localStorage、sessionStorage区别</h4><ol>
<li><p>生命周期</p>
<ul>
<li><p>cookie：若浏览器中未设置过期时间，<code>cookie</code>保存在内存中，生命周期随浏览器的关闭而结束，即<code>会话cookie</code>。若浏览器中设置了过期时间，<code>cookie</code>保存在硬盘中，关闭浏览器后<code>cookie</code>仍存在，仅当过期时间结束才消失</p>
</li>
<li><p>localStorage：除非被清除，否则永久保存</p>
</li>
<li><p>sessionStorage：仅当前会话有效，关闭页面或浏览器后被清除。</p>
</li>
</ul>
</li>
<li><p>数据大小：<code>cookie</code>最大为<code>4kb</code>。<code>localStorage</code>和<code>sessionStorage</code>最大为<code>5MB</code></p>
</li>
<li><p>与服务器通信：</p>
<ul>
<li><p>cookie：携带在<code>HTTP</code>头上</p>
</li>
<li><p>localStorage/sessionStorage：仅在客户端保存，不参与和服务器的通信</p>
</li>
</ul>
</li>
<li><p>用途：</p>
<ul>
<li><p>cookie：判断用户是否登陆过，以便下次登陆；保存上次登陆的时间等信息；保存上次查看的页面；浏览计数</p>
</li>
<li><p>localStorage：用于长期登陆且判断用户是否已登陆。适合长期保存在本地的数据</p>
</li>
<li><p>sessionStorage：用于敏感账号一次性登陆。</p>
</li>
</ul>
</li>
<li><p>与cookie相比优点：存储空间更大；节省网络流量；显示速度更快；安全性比<code>cookie</code>高；数据操作比<code>cookie</code>方便</p>
</li>
</ol>
<h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><blockquote>
<p>iframe创建包含另一个文档的内联框架。</p>
</blockquote>
<p>缺点：</p>
<ul>
<li><p>阻塞主页面的<code>onload</code>事件</p>
</li>
<li><p>搜索引擎无法解读此种页面，不利于<code>SEO</code></p>
</li>
<li><p>iframe和主页面共享连接吃，浏览器对相同区域有限制，故会影响性能。</p>
</li>
</ul>
<h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><blockquote>
<p>XSS攻击(Cross-Site scripting)指跨站脚本攻击，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息，如cookie、sessionID等，危害数据安全。</p>
</blockquote>
<h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p>XSS攻击可分为存储型、反射型、DOM型。</p>
<ul>
<li><p>存储型：恶意代码提交到目标网站数据库，用户打开网站，服务端将代码从<code>数据库</code>取出拼接到HTML中返回给浏览器，进而攻击目标网站。常见于带用户保存数据的网站功能：论坛发帖、商品评论、用户私信等。</p>
</li>
<li><p>反射型：构造包含恶意代码的特殊<code>URL</code>。用户打开<code>URL</code>时，<code>服务端</code>将代码从<code>URL</code>取出拼接到HTML中返回给浏览器，进而攻击。常见于通过<code>URL</code>传递参数的功能，如网站搜索、跳转等。</p>
</li>
<li><p>DOM型：构造包含恶意代码的特殊<code>URL</code>，用户打开<code>URL</code>，浏览器接受响应解析执行，前端<code>JavaScript</code>取出<code>URL</code>中的恶意代码执行，进而攻击。</p>
</li>
</ul>
<p>DOM型XSS属于前端<code>JavaScript</code>自身的安全漏洞，取出和执行都由<code>浏览器端</code>完成。其他两种存储型和反射型都属于<code>服务器</code>端的安全漏洞。</p>
<h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4><blockquote>
<p>预防主要从输入过滤、防止HTML出现注入、防止JavaScript执行恶意代码三方面入手。</p>
</blockquote>
<ol>
<li>存储型攻击和发射型攻击</li>
</ol>
<ul>
<li><p>纯前端渲染，将代码与数据分开</p>
<p>  浏览器加载<code>静态HTML</code>，然后再执行<code>HTML</code>中的<code>JavaScript</code>。<code>JavaScript</code>通过<code>Ajax</code>加载业务数据，调用<code>DOM API</code>更新到页面。</p>
</li>
<li><p>转义HTML</p>
<p>  使用合适的转义库/模版引擎，对HTML模版各处插入点充分转义。</p>
</li>
</ul>
<ol start="2">
<li>DOM型攻击</li>
</ol>
<p>小心使用<code>.innerHTML</code>、<code>outerHTML</code>、<code>document.write()</code>等方法，避免将不可信的数据插入HTML页面。若使用前端框架，小心使用<code>v-html</code>/<code>dangerouslySetInnerHTML</code>功能。DOM中的内联事件监听器，如<code>onclick</code>、<code>onload</code>、<code>location</code>等，以及<code>&lt;a&gt;</code>中的<code>href</code>，和JavaScript的<code>setTimeout()</code>、<code>setInterval()</code>等均可将字符串当作代码运行。故避免将不可信的数据传递给以上API。</p>
<ol start="3">
<li>其他措施</li>
</ol>
<ul>
<li><p>使用<code>CSP(Content Security Policy)</code>防范</p>
</li>
<li><p>控制输入内容长度</p>
</li>
<li><p>使用<code>HTTP-only Cookie</code>：禁止<code>JavaScript</code>读取敏感<code>Cookie</code>。</p>
</li>
<li><p>使用验证码</p>
</li>
</ul>
<p>总结：防范XSS攻击可以利用<strong>模版引擎</strong>、<strong>避免内联事件</strong>、<strong>避免拼接HTML</strong>、通过<strong>CSP/输入长度配置/接口安全措施</strong>等方法<strong>增加攻击难度，降低攻击后果</strong>、使用<strong>XSS扫描工具</strong>自动<strong>检测发现潜在的XSS漏洞</strong>。</p>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><blockquote>
<p>CSRF(Cross-Site request forgery)跨站请求伪造：诱导用户进入第三方网站，攻击者向被攻击网站发送跨站请求，利用获取的注册凭证，绕过后台用户验证，冒充用户对被攻击网站执行某种操作的目的。</p>
</blockquote>
<h4 id="分类-2"><a href="#分类-2" class="headerlink" title="分类"></a>分类</h4><ol>
<li><p>GET类型：一个HTTP请求即可</p>
</li>
<li><p>POST类型：通常使用一个自动提交的表单。</p>
</li>
<li><p>链接类型：需要用户点击链接触发。</p>
</li>
</ol>
<h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><p>CSRF的特点有<strong>通常发生在第三方域名</strong>，且<strong>不能获取到Cookie等信息，仅使用Cookie</strong>。</p>
<ul>
<li><p>阻止不明外域的访问</p>
<ul>
<li><p>同源检测</p>
<p>  服务器可以通过解析Header中<code>Origin Header</code>和<code>Referer Header</code>的域名确定请求的来源域。</p>
<p>  若<code>Origin Header</code>存在，直接使用其中的字段确认来源域名。</p>
<p>  若<code>Origin Header</code>不存在(IE11同源策略、302重定向)使用<code>Referer Header</code>中链接的<code>Origin</code>部分可以得知请求的来源域名。</p>
<p>  通过设置<code>Referrer Policy</code>的策略为<code>same-origin</code>，对于同源的链接和引用，会发送<code>Referer</code>，referer值为<code>Host</code>不带<code>Path</code>。跨域访问不携带<code>Referer</code>。</p>
<p>  此方法相对简单，能防范大多数CSRF攻击，若有较多用户输入内容的网站，则需要额外的防护措施</p>
</li>
<li><p>Samesite Cookie</p>
<p>  为<code>Set-Cookie</code>响应头新增<code>Samesite</code>属性，用来表明此<code>Cookie</code>为<code>同站Cookie</code>，且只能作为<code>第一方Cookie</code>。</p>
<ul>
<li><p>Samesite=Strict</p>
<p>  严格模式，表明此<code>Cookie</code>在任何情况下都不可能作为<code>第三方Cookie</code>。即若网站a识别用户是否登陆的<code>Cookie</code>被设为<code>Strict</code>，其他外链发起的请求都不会带上此<code>Cookie</code>，则用户从其他外链进入网站a都不会是登陆状态。</p>
</li>
<li><p>Samesite=Lax</p>
<p>  宽松模式，若该请求<strong>改变了当前页面或打开了新页面</strong>且同时为<code>GET请求</code>，则此<code>Cookie</code>可以作为<code>第三方Cookie</code>，在链接跳转时仍会带上此<code>Cookie</code>，但对于<code>异步请求</code>或<code>POST请求</code>则不会带。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>提交时要求附加本域才能获取的信息</p>
<ul>
<li><p>CSRF Token（存在<code>session</code>中，避免存入<code>cookie</code>后被冒用）</p>
<ol>
<li><p>将<code>CSRF Token</code>输出到页面</p>
</li>
<li><p>页面提交的请求携带此<code>Token</code></p>
</li>
<li><p>服务器验证<code>Token</code>是否正确</p>
<p>此方法实现复杂，需要每个页面都写入<code>Token</code>，每个<code>Form/ajax</code>请求都携带<code>Token</code>，后端对每个接口都校验，工作量巨大且有可能遗漏。</p>
</li>
</ol>
</li>
<li><p>双重Cookie验证（要求<code>ajax</code>和<code>表单</code>请求携带一个<code>Cookie</code>中的值）</p>
<ol>
<li><p>用户访问页面向请求域名注入一个<code>Cookie</code>，内容为随机字符串</p>
</li>
<li><p>前端向后端发起请求时取出<code>Cookie</code>添加到<code>URL</code>的参数中</p>
</li>
<li><p>后端接口验证<code>Cookie</code>中的字段与<code>URL</code>参数中的字段是否一致，不一致则拒绝。</p>
<p>此方法无需使用<code>session</code>，适用面广，易于实施，且存在客户端中，没有服务器压力，且实施成本更低，可以在前后端统一拦截校验。但它在Cookie中加了额外的字段，若有其他漏洞，攻击者可以注入Cookie，此方式失效。且难于做到子域名的隔离。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>面经</tag>
        <tag>http</tag>
        <tag>HTML</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript自检问答</title>
    <url>/post/a80967e6.html</url>
    <content><![CDATA[<h2 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h2><ol>
<li>JavaScript规定了几种语言类型</li>
</ol>
<ol start="2">
<li>JavaScript对象的底层数据结构是什么</li>
</ol>
<ol start="3">
<li>Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol</li>
</ol>
<a id="more"></a>

<ol start="4">
<li>JavaScript中的变量在内存中的具体存储形式</li>
</ol>
<ol start="5">
<li>基本类型对应的内置对象，以及他们之间的装箱拆箱操作</li>
</ol>
<ol start="6">
<li>理解值类型和引用类型</li>
</ol>
<ol start="7">
<li>null和undefined的区别</li>
</ol>
<ol start="8">
<li>至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型</li>
</ol>
<ol start="9">
<li>可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用</li>
</ol>
<ol start="10">
<li>出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法</li>
</ol>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><ol>
<li>理解原型设计模式以及JavaScript中的原型规则</li>
</ol>
<ol start="2">
<li>instanceof的底层实现原理，手动实现一个instanceof</li>
</ol>
<ol start="4">
<li>实现继承的几种方式以及他们的优缺点</li>
</ol>
<ol start="5">
<li>至少说出一种开源项目(如Node)中应用原型继承的案例</li>
</ol>
<ol start="6">
<li>可以描述new一个对象的详细过程，手动实现一个new操作符</li>
</ol>
<ol start="7">
<li>理解es6 class构造以及继承的底层实现原理</li>
</ol>
<h2 id="作用域和闭包"><a href="#作用域和闭包" class="headerlink" title="作用域和闭包"></a>作用域和闭包</h2><ol>
<li>理解词法作用域和动态作用域</li>
</ol>
<ol start="2">
<li>理解JavaScript的作用域和作用域链</li>
</ol>
<ol start="3">
<li>理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题</li>
</ol>
<ol start="4">
<li>this的原理以及几种不同使用场景的取值</li>
</ol>
<ol start="5">
<li>闭包的实现原理和作用，可以列举几个开发中闭包的实际应用</li>
</ol>
<ol start="6">
<li>理解堆栈溢出和内存泄漏的原理，如何防止</li>
</ol>
<ol start="7">
<li>如何处理循环的异步操作</li>
</ol>
<ol start="8">
<li>理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理</li>
</ol>
<h2 id="执行机制"><a href="#执行机制" class="headerlink" title="执行机制"></a>执行机制</h2><ol>
<li>为何try里面放return，finally还会执行，理解其内部机制</li>
</ol>
<ol start="2">
<li>JavaScript如何实现异步编程，可以详细描述EventLoop机制</li>
</ol>
<ol start="3">
<li>宏任务和微任务分别有哪些</li>
</ol>
<ol start="4">
<li>可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法</li>
</ol>
<ol start="5">
<li>使用Promise实现串行</li>
</ol>
<ol start="6">
<li>Node与浏览器EventLoop的差异</li>
</ol>
<ol start="7">
<li>如何在保证页面运行流畅的情况下处理海量数据</li>
</ol>
<h2 id="语法和API"><a href="#语法和API" class="headerlink" title="语法和API"></a>语法和API</h2><ol>
<li>理解ECMAScript和JavaScript的关系</li>
</ol>
<ol start="2">
<li>熟练运用es5、es6提供的语法规范，</li>
</ol>
<ol start="3">
<li>熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined）</li>
</ol>
<ol start="4">
<li>熟练应用map、reduce、filter 等高阶函数解决问题</li>
</ol>
<ol start="5">
<li>setInterval需要注意的点，使用setTimeout实现setInterval</li>
</ol>
<ol start="6">
<li>JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题</li>
</ol>
<ol start="7">
<li>JavaScript异常处理的方式，统一的异常处理方案</li>
</ol>
<h2 id="JavaScript编程题"><a href="#JavaScript编程题" class="headerlink" title="JavaScript编程题"></a>JavaScript编程题</h2><ol>
<li>多种方式实现数组去重、扁平化、对比优缺点</li>
</ol>
<ol start="2">
<li>多种方式实现深拷贝、对比优缺点</li>
</ol>
<ol start="3">
<li>手写函数柯里化工具函数、并理解其应用场景和优势</li>
</ol>
<ol start="4">
<li>手写防抖和节流工具函数、并理解其内部原理和应用场景</li>
</ol>
<ol start="5">
<li>实现一个sleep函数</li>
</ol>
<h2 id="手动实现前端轮子"><a href="#手动实现前端轮子" class="headerlink" title="手动实现前端轮子"></a>手动实现前端轮子</h2><ol>
<li>手动实现call、apply、bind</li>
</ol>
<ol start="2">
<li>手动实现符合Promise/A+规范的Promise、手动实现async await</li>
</ol>
<ol start="3">
<li>手写一个EventEmitter实现事件发布、订阅</li>
</ol>
<ol start="4">
<li>可以说出两种实现双向绑定的方案、可以手动实现</li>
</ol>
<ol start="5">
<li>手写JSON.stringify、JSON.parse</li>
</ol>
<ol start="6">
<li>手写一个模版引擎，并能解释其中原理</li>
</ol>
<ol start="7">
<li>手写懒加载、下拉刷新、上拉加载、预加载等效果</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript算法题整理（二）</title>
    <url>/post/81ec75ea.html</url>
    <content><![CDATA[<h2 id="JavaScript算法题"><a href="#JavaScript算法题" class="headerlink" title="JavaScript算法题"></a>JavaScript算法题</h2><h3 id="获取url中参数"><a href="#获取url中参数" class="headerlink" title="获取url中参数"></a>获取url中参数</h3><p><strong>描述</strong></p>
<p>获取 url 中的参数</p>
<ol>
<li><p>指定参数名称，返回该参数的值 或者 空字符串</p>
</li>
<li><p>不指定参数名称，返回全部的参数对象 或者 {}</p>
</li>
<li><p>如果存在多个同名参数，则返回数组</p>
</li>
<li><p>不支持URLSearchParams方法</p>
<a id="more"></a></li>
</ol>
<p><strong>示例1</strong></p>
<p>输入：</p>
<p><a href="http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe" target="_blank" rel="noopener">http://www.nowcoder.com?key=1&amp;key=2&amp;key=3&amp;test=4#hehe</a> key</p>
<p>输出：</p>
<p>[1, 2, 3]</p>
<p><strong>分析</strong></p>
<p>获取url中参数，首先取得<code>?</code>到<code>#</code>中的部分，再使用<code>split()</code>或<code>正则表达式</code>获取参数的序列.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getUrlParam(sUrl, sKey) &#123;</span><br><span class="line">    let paramArr &#x3D; sUrl.split(&quot;?&quot;)[1].split(&quot;#&quot;)[0].split(&quot;&amp;&quot;);</span><br><span class="line">    let obj &#x3D; &#123;&#125;;</span><br><span class="line">    let arr &#x3D; [];</span><br><span class="line">    paramArr.forEach((e) &#x3D;&gt;&#123;</span><br><span class="line">        let [key,value] &#x3D; e.split(&quot;&#x3D;&quot;);</span><br><span class="line">        if(key in obj)&#123;</span><br><span class="line">            obj[key] &#x3D; [].concat(obj[key],value);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            obj[key] &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return sKey ? obj[sKey] || &quot;&quot; : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p><strong>描述</strong></p>
<p>为 Array 对象添加一个去除重复项的方法</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<p>[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’, ‘a’, NaN]</p>
<p>输出：</p>
<p>[false, true, undefined, null, NaN, 0, 1, {}, {}, ‘a’]</p>
<p><strong>分析</strong></p>
<p>使用<code>ES6</code>的<code>Set</code>去重，在使用数组的<code>from</code>方法将<code>Set</code>转化为数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.prototype.uniq &#x3D; function () &#123;</span><br><span class="line">    return Array.from(new Set(this));</span><br><span class="line">    &#x2F;&#x2F;ES6写法</span><br><span class="line">    &#x2F;&#x2F;return [...new Set(this)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p><strong>数据结构Set</strong></p>
<blockquote>
<p>类似于数组，但成员的值都是唯一的，无重复值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;初始化</span><br><span class="line">const s &#x3D; new Set();</span><br><span class="line">&#x2F;&#x2F;初始化时加入值</span><br><span class="line">const s &#x3D; new Set([1,2,3,3,4,2,5]);</span><br><span class="line">&#x2F;&#x2F;展开为(...为展开符号)</span><br><span class="line">[...s]&#x2F;&#x2F;[1,2,3,4,5]</span><br><span class="line">&#x2F;&#x2F;使用add方法加入值</span><br><span class="line">[1,2,3,3,4,2,5].forEach(x &#x3D;&gt; s.add(x))</span><br><span class="line">&#x2F;&#x2F;set大小</span><br><span class="line">s.size&#x2F;&#x2F;输出5</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;数组去重</span><br><span class="line">[...new Set(array)]</span><br><span class="line">&#x2F;&#x2F;字符串去重</span><br><span class="line">[...new Set(&#39;ababbc&#39;)].join(&#39;&#39;)&#x2F;&#x2F;abc</span><br></pre></td></tr></table></figure>

<p>Set中，判断两个值是否不同使用精确相等运算符<code>===</code>，在<code>Set</code>内部，两个<code>NaN</code>相等，但两个空对象不相等，会被视为两个值。</p>
<p><strong>一些Set方法</strong></p>
<ul>
<li><p>add(): 加入值</p>
</li>
<li><p>has(): 判断是否存在某个值，返回布尔值</p>
</li>
<li><p>delete(): 删除某个值，返回布尔值，即是否删除成功</p>
</li>
<li><p>clear(): 清空Set。</p>
</li>
<li><p>Array.from(set): 将Set结构转为数组。</p>
</li>
</ul>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p><strong>描述</strong></p>
<p>实现一个打点计时器，要求</p>
<ol>
<li><p>从 start 到 end（包含 start 和 end），每隔 100 毫秒 console.log 一个数字，每次数字增幅为 1</p>
</li>
<li><p>返回的对象中需要包含一个 cancel 方法，用于停止定时操作</p>
</li>
<li><p>第一个数需要立即输出</p>
</li>
</ol>
<p><strong>分析</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;setInterval</span><br><span class="line">function count(start, end) &#123;</span><br><span class="line">    console.log(start++);</span><br><span class="line">    let timer &#x3D; setInterval(function()&#123;</span><br><span class="line">        if(start &lt;&#x3D; end)&#123;</span><br><span class="line">            console.log(start++);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,100);</span><br><span class="line">    return &#123;</span><br><span class="line">        cancel: function()&#123;</span><br><span class="line">            clearInterval(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;setTimeout</span><br><span class="line">function count(start, end) &#123;</span><br><span class="line">    if(start &lt;&#x3D; end)&#123;</span><br><span class="line">        console.log(start);</span><br><span class="line">        start++;</span><br><span class="line">        st &#x3D; setTimeout(function()&#123;</span><br><span class="line">            count(start, end)</span><br><span class="line">        &#125;, 100);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        cancel: function()&#123;clearTimeout(st);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li>setInterval()</li>
</ol>
<blockquote>
<p>以固定的时间间隔，重复运行一段代码，每次调用之间有固定的时间延迟。返回一个时间间隔ID，该ID唯一标识时间间隔，可以通过调用<code>clearInterval()</code>来删除。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var intervalID &#x3D; setInterval(func, delay, [arg1,...,argx]);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>func: 要调用的函数，每经过指定<code>delay</code>ms后执行的函数。不接受任何参数，也没有返回值</p>
</li>
<li><p>delay: 每次延迟的毫秒数。</p>
</li>
<li><p>intervalID: 非零数值，用来标识通过<code>setInterval()</code>创建的计时器，可以作为<code>clearInterval()</code>的参数来清除计时器。</p>
</li>
</ul>
<ol start="2">
<li>setTimeout()</li>
</ol>
<blockquote>
<p>在指定的时间后执行一段代码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var timeoutID &#x3D; setTimeout(function[,delay,arg1,...,argx]);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>function: 延迟时间<code>delay</code>后执行的函数</p>
</li>
<li><p>delay(可选): 若不设置，默认为0，即马上执行。</p>
</li>
<li><p>timeoutID: 正整数，表示定时器的编号，可以传递给<code>clearTimeout()</code>来取消定时器。</p>
</li>
</ul>
<ol start="3">
<li>递归setTimeout()可以实现setInterval()的效果</li>
</ol>
<p>如上算法题解显示，在<code>setTimeout()</code>中递归调用<code>count</code>方法，等同于<code>setInterval()</code>的效果</p>
<p>区别在于：</p>
<p>递归调用方法<code>setTimeout()</code>保证执行之间的延迟<code>delay</code>相同。即上面的算法题，无论代码运行多久，间隔都是100ms。</p>
<p>但直接使用方法<code>setInterval()</code>，他的间隔<code>delay</code>包含运行代码花费的时间，即若<code>console.log(start++)</code>运行花费30ms，则间隔就为60ms。</p>
<h3 id="使用闭包"><a href="#使用闭包" class="headerlink" title="使用闭包"></a>使用闭包</h3><p><strong>描述</strong></p>
<p>实现函数 makeClosures，调用之后满足如下条件：</p>
<ol>
<li><p>返回一个函数数组 result，长度与 arr 相同</p>
</li>
<li><p>运行 result 中第 i 个函数，即 result<a href="">i</a>，结果与 fn(arr[i]) 相同</p>
</li>
</ol>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3], function (x) &#123; </span><br><span class="line">	return x * x; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function makeClosures(arr, fn) &#123;</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    for(let i &#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        result[i] &#x3D; ()&#x3D;&gt;&#123;</span><br><span class="line">            return fn(arr[i]);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><p><strong>函数闭包</strong></p>
<blockquote>
<p>函数闭包，即可以允许在一个内层函数中访问到其外层函数的作用域。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例1</span><br><span class="line">function makeAdder(x) &#123;</span><br><span class="line">  return function(y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;add5、add10为makeAdder方法返回的函数function(y)的实例</span><br><span class="line">var add5 &#x3D; makeAdder(5);&#x2F;&#x2F;即外层函数中x&#x3D;5</span><br><span class="line">var add10 &#x3D; makeAdder(10);&#x2F;&#x2F;即外层函数中x&#x3D;10</span><br><span class="line"></span><br><span class="line">console.log(add5(2));  &#x2F;&#x2F; 即function(y&#x3D;2)&#123;&#125;。输出7</span><br><span class="line">console.log(add10(2)); &#x2F;&#x2F;即function(y&#x3D;2)&#123;&#125;。输出12</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;示例二</span><br><span class="line">&#x2F;&#x2F;如下，size为makeSizer方法中外部定义的参数。</span><br><span class="line">function makeSizer(size) &#123;</span><br><span class="line">  return function() &#123;</span><br><span class="line">    document.body.style.fontSize &#x3D; size + &#39;px&#39;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;新定义的size12、size14、size16为makeSizer方法返回的匿名函数function的实例。</span><br><span class="line">var size12 &#x3D; makeSizer(12);&#x2F;&#x2F;则其设置size&#x3D;12</span><br><span class="line">var size14 &#x3D; makeSizer(14);&#x2F;&#x2F;设置size&#x3D;14</span><br><span class="line">var size16 &#x3D; makeSizer(16);&#x2F;&#x2F;设置size&#x3D;16</span><br></pre></td></tr></table></figure>

<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p><strong>描述</strong></p>
<p>已知 fn 为一个预定义函数，实现函数 curryIt，调用之后满足如下条件：</p>
<ol>
<li><p>返回一个函数 a，a 的 length 属性值为 1（即显式声明 a 接收一个参数）</p>
</li>
<li><p>调用 a 之后，返回一个函数 b, b 的 length 属性值为 1</p>
</li>
<li><p>调用 b 之后，返回一个函数 c, c 的 length 属性值为 1</p>
</li>
<li><p>调用 c 之后，返回的结果与调用 fn 的返回值一致</p>
</li>
<li><p>fn 的参数依次为函数 a, b, c 的调用参数</p>
</li>
</ol>
<p><strong>示例一</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fn &#x3D; function (a, b, c) &#123;return a + b + c&#125;; curryIt(fn)(1)(2)(3);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>6</p>
<p><strong>分析</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curryIt(fn) &#123;</span><br><span class="line">     &#x2F;&#x2F;获取fn参数的数量</span><br><span class="line">     var n &#x3D; fn.length;</span><br><span class="line">     &#x2F;&#x2F;声明一个数组args</span><br><span class="line">     var args &#x3D; [];</span><br><span class="line">     &#x2F;&#x2F;返回一个匿名函数</span><br><span class="line">     return function(arg)&#123;</span><br><span class="line">         &#x2F;&#x2F;将curryIt后面括号中的参数放入数组</span><br><span class="line">         args.push(arg);</span><br><span class="line">         &#x2F;&#x2F;如果args中的参数个数小于fn函数的参数个数，</span><br><span class="line">         &#x2F;&#x2F;则执行arguments.callee（其作用是引用当前正在执行的函数，这里是返回的当前匿名函数）。</span><br><span class="line">         &#x2F;&#x2F;否则，返回fn的调用结果</span><br><span class="line">         if(args.length &lt; n)&#123;</span><br><span class="line">            return arguments.callee;</span><br><span class="line">         &#125;else return fn.apply(&quot;&quot;,args);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript算法题整理（一）</title>
    <url>/post/b1fa9932.html</url>
    <content><![CDATA[<p>好几年没碰算法题，头次打开一脸懵逼。为了面试刷起来，以下为整理：</p>
<h2 id="JavaScript算法题"><a href="#JavaScript算法题" class="headerlink" title="JavaScript算法题"></a>JavaScript算法题</h2><h3 id="dom-节点查找"><a href="#dom-节点查找" class="headerlink" title="dom 节点查找"></a>dom 节点查找</h3><p><strong>描述</strong></p>
<p>查找两个节点的最近的一个共同父节点，可以包括节点自身</p>
<p><strong>输入描述</strong></p>
<p>oNode1 和 oNode2 在同一文档中，且不会为相同的节点</p>
<blockquote>
<p>获取node父节点，可以使用<code>node.parentNode</code></p>
</blockquote>
<p><strong>分析</strong></p>
<a id="more"></a>
<p>若oNode1节点的父节点包含oNode2，则此父节点为共同父节点。以此类推。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function commonParentNode(oNode1, oNode2) &#123;</span><br><span class="line">    let parent1 &#x3D; oNode1.parentNode;</span><br><span class="line">    let parent2 &#x3D; oNode2.parentNode;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        if(parent1.contains(oNode2))&#123;</span><br><span class="line">            return parent2;</span><br><span class="line">        &#125;</span><br><span class="line">        if(parent2.containw(oNode1))&#123;</span><br><span class="line">            return parent1;</span><br><span class="line">        &#125;</span><br><span class="line">        parent1 &#x3D; parent1.parentNode;</span><br><span class="line">        parent2 &#x3D; parent2.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p><strong>描述</strong><br>用 JavaScript 实现斐波那契数列函数,返回第n个斐波那契数。 f(1) = 1, f(2) = 1 等</p>
<blockquote>
<p>斐波那契数列，<code>f(0)=0,f(1)=1,f(2)=f(0)+(1)=1,...,f(n)=f(n-1)+f(n-2)</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    return n&lt;&#x3D;2 ? 1 : fibonacci(n-1) + fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串统计"><a href="#字符串统计" class="headerlink" title="字符串统计"></a>字符串统计</h3><p><strong>描述</strong><br>统计字符串中每个字符的出现频率，返回一个 Object，key 为统计字符，value 为出现频率</p>
<ol>
<li>不限制 key 的顺序</li>
<li>输入的字符串参数不会为空</li>
<li>忽略空白字符</li>
</ol>
<p><strong>示例1</strong><br>输入：</p>
<p>‘hello world’</p>
<p>输出：</p>
<p>{h: 1, e: 1, l: 3, o: 2, w: 1, r: 1, d: 1}</p>
<p><strong>分析</strong></p>
<ol>
<li><p>字符串分离字符可以使用<code>split</code>方法，也可以使用正则表达式<code>str.replace(/\s/,&#39;&#39;);</code>去除字符串中的空格。</p>
</li>
<li><p>判断对象中是否已含有指定对象x可以直接<code>object[x]!==undefined</code>，也可以使用对象的<code>hasOwnProperty()</code>方法，如<code>object.hasOwnProperty(x)</code>判断</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function count(str) &#123;</span><br><span class="line">    let count &#x3D; &#123;&#125;;</span><br><span class="line">    let arr &#x3D; str.split(&quot;&quot;);&#x2F;&#x2F;将字符串分离为字符数组，也可以使用正则表达式分离</span><br><span class="line">    for(let i &#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        if(arr[i]!&#x3D;&#x3D;&quot;&quot;|| arr[i]!&#x3D;&#x3D; &quot; &quot;)&#123;&#x2F;&#x2F;用split(&quot;&quot;)分离的数组会带空格，故需要排除空格的情况</span><br><span class="line">            if(count[arr[i]] !&#x3D;&#x3D; undefined)&#123;&#x2F;&#x2F;此处可以使用对象的hasOwnProperty()方法看对象中是否已包含此字符</span><br><span class="line">                count[arr[i]]++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                count[arr[i]] &#x3D; 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除数组元素"><a href="#删除数组元素" class="headerlink" title="删除数组元素"></a>删除数组元素</h3><p><strong>描述</strong></p>
<p>删除数组 arr 最后一个元素。不要直接修改数组 arr，结果返回新的数组</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<p>[1, 2, 3, 4]</p>
<p>输出：</p>
<p>[1, 2, 3]</p>
<p><strong>分析</strong> </p>
<p>不修改原数组arr，则需要将原数组copy一份到新数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function truncate(arr) &#123;</span><br><span class="line">    var newArr &#x3D; JSON.parse(JSON.stringify(arr));</span><br><span class="line">    newArr.pop();</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可能涉及的知识点"><a href="#可能涉及的知识点" class="headerlink" title="可能涉及的知识点"></a>可能涉及的知识点</h4><ol>
<li>数组的深拷贝和浅拷贝</li>
</ol>
<ul>
<li>浅拷贝：如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，无论对新旧数组的哪一个进行了修改，两者都会发生变化。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用&#x3D;直接赋值</span><br><span class="line">let newArr &#x3D; arr;</span><br><span class="line">&#x2F;&#x2F;使用slice()</span><br><span class="line">let newArr &#x3D; arr.slice();</span><br><span class="line">&#x2F;&#x2F;使用concat()</span><br><span class="line">let newArr &#x3D;  arr.concat();</span><br></pre></td></tr></table></figure>

<ul>
<li>深拷贝：完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用JSON.stringify和JSON.parse</span><br><span class="line">var newArr &#x3D; JSON.parse(JSON.stringify(arr));&#x2F;&#x2F;该方法可以拷贝数组和对象，但不能拷贝函数。对于RegExp类型和Function类型无法完全满足，且不支持有循环引用的对象。</span><br><span class="line">&#x2F;&#x2F;拷贝时判断属性类型</span><br><span class="line">var deepCopy &#x3D; function(obj) &#123;</span><br><span class="line">    &#x2F;&#x2F; 只拷贝对象</span><br><span class="line">    if (typeof obj !&#x3D;&#x3D; &#39;object&#39;) return;</span><br><span class="line">    &#x2F;&#x2F; 根据obj的类型判断是新建一个数组还是一个对象</span><br><span class="line">    var newObj &#x3D; obj instanceof Array ? [] : &#123;&#125;;</span><br><span class="line">        for (var key in obj) &#123;</span><br><span class="line">            &#x2F;&#x2F; 遍历obj,并且判断是obj的属性才拷贝</span><br><span class="line">            if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 判断属性值的类型，如果是对象递归调用深拷贝</span><br><span class="line">                newObj[key] &#x3D; typeof obj[key] &#x3D;&#x3D;&#x3D; &#39;object&#39; ? deepCopy(obj[key]) : obj[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  return newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>数组的常用方法</li>
</ol>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>concat(arrayX,arrayX,…,arrayX)</td>
<td>连接两个或更多的数组，并返回结果。</td>
</tr>
<tr>
<td>join(&amp;separator)</td>
<td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td>
</tr>
<tr>
<td>pop()</td>
<td>删除并返回数组的最后一个元素</td>
</tr>
<tr>
<td>push(newelement1,…,newelementX)</td>
<td>向数组的末尾添加一个或更多元素，并返回新的长度。</td>
</tr>
<tr>
<td>reverse()</td>
<td>颠倒数组中元素的顺序。</td>
</tr>
<tr>
<td>shift()</td>
<td>删除并返回数组的第一个元素</td>
</tr>
<tr>
<td>slice(start,&amp;end)</td>
<td>从某个已有的数组返回选定的元素</td>
</tr>
<tr>
<td>sort(&amp;sortby-fn)</td>
<td>对数组的元素进行排序</td>
</tr>
<tr>
<td>splice(index,howmany,item1,…,itemX)</td>
<td>删除元素，并向数组添加新元素。</td>
</tr>
<tr>
<td>toSource()</td>
<td>返回该对象的源代码。</td>
</tr>
<tr>
<td>toString()</td>
<td>把数组转换为字符串，并返回结果。</td>
</tr>
<tr>
<td>toLocaleString()</td>
<td>把数组转换为本地数组，并返回结果。</td>
</tr>
<tr>
<td>unshift(newelement1,…,newelementX)</td>
<td>向数组的开头添加一个或更多元素，并返回新的长度。</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回数组对象的原始值</td>
</tr>
</tbody></table>
<h3 id="正确的使用-parseInt"><a href="#正确的使用-parseInt" class="headerlink" title="正确的使用 parseInt"></a>正确的使用 parseInt</h3><p><strong>描述</strong></p>
<p>修改 js 代码中 parseInt 的调用方式，使之通过全部测试用例</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<p>‘12’</p>
<p>输出：</p>
<p>12</p>
<p><strong>示例2</strong></p>
<p>输入：</p>
<p>‘12px’</p>
<p>输出：</p>
<p>12</p>
<p><strong>示例3</strong></p>
<p>输入：</p>
<p>‘0x12’</p>
<p>输出：</p>
<p>0</p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>方法<code>parseInt()</code>若前面以<code>0x</code>开头，<code>parseInt()</code>会把它的其余部分解析为十六进制的整数。</p>
<p>方法<code>parseInt(string, radix)</code>的<code>radix</code>参数表示要解析的数字的基数。该值介于 2 ~ 36 之间。故可以设置<code>radix</code>为<code>10</code>将所有传入的字符串都以<code>十进制</code>方式解析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function parse2Int(num) &#123;</span><br><span class="line">    return parseInt(num,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用arguments"><a href="#使用arguments" class="headerlink" title="使用arguments"></a>使用arguments</h3><p><strong>描述</strong></p>
<p>函数 useArguments 可以接收 1 个及以上的参数。请实现函数 useArguments，返回所有调用参数相加后的结果。本题的测试参数全部为 Number 类型，不需考虑参数转换。</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<p>1, 2, 3, 4</p>
<p>输出：</p>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function useArguments() &#123;</span><br><span class="line">    let sum &#x3D; 0;</span><br><span class="line">    for(let i &#x3D; 0;i&lt;arguments.length;i++)&#123;</span><br><span class="line">        sum +&#x3D; arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="涉及知识点"><a href="#涉及知识点" class="headerlink" title="涉及知识点"></a>涉及知识点</h4><p>JavaScript函数传参</p>
<ol>
<li>显式参数Parameters</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn(parameter1,...,parameterx)&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JS定义显式参数时不需要指定数据类型。</p>
</blockquote>
<ol start="2">
<li>隐式参数Arguments</li>
</ol>
<blockquote>
<p>JS函数有内置的对象<code>arguments</code>，包含了函数调用的参数数组。</p>
</blockquote>
<p>JS函数对隐式参数没有类型和个数检测。若函数在调用时没有提供隐式参数，则参数默认值均为<code>undefined</code></p>
<ol start="3">
<li>ES6函数可以自带默认参数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction(x, y &#x3D; 10) &#123;</span><br><span class="line">    &#x2F;&#x2F; y is 10 if not passed or undefined</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myFunction(0, 2) &#x2F;&#x2F; 输出 2</span><br><span class="line">myFunction(5); &#x2F;&#x2F; 输出 15, y 参数的默认值</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>传递参数</li>
</ol>
<ul>
<li>通过值传参</li>
</ul>
<p>函数中调用的参数是隐式参数，其通过值来传递，函数仅是获得值。若函数修改参数的值，不会修改显式参数的初始值（在函数外定义），隐式参数的改变在函数外不可见</p>
<ul>
<li>通过对象传参</li>
</ul>
<p>JS中可以引用对象的值，在函数内部修改对象的属性会修改其初始的值，即修改对象属性可作用于函数外部。</p>
<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><p><strong>描述</strong></p>
<p>将数组 arr 中的元素作为调用函数 fn 的参数</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<p>function (greeting, name, punctuation) {return greeting + ‘, ‘ + name + (punctuation || ‘!’);}, [‘Hello’, ‘Ellie’, ‘!’]</p>
<p>输出：</p>
<p>Hello, Ellie!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function argsAsArray(fn, arr) &#123;</span><br><span class="line">    return fn.apply(this,arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="涉及到的知识点"><a href="#涉及到的知识点" class="headerlink" title="涉及到的知识点"></a>涉及到的知识点</h4><ol>
<li>JS函数调用</li>
</ol>
<blockquote>
<p>JS函数有4中调用方式，不同点在于<code>this</code>的初始化</p>
</blockquote>
<ul>
<li>作为函数调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction(a, b) &#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(10, 2);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此种方式默认的全局对象是什么，函数就属于什么对象的函数，即<code>this</code>指向全局对象</p>
</blockquote>
<ul>
<li>作为方法调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myObject &#x3D; &#123;</span><br><span class="line">    firstName:&quot;John&quot;,</span><br><span class="line">    lastName: &quot;Doe&quot;,</span><br><span class="line">    fullName: function () &#123;</span><br><span class="line">        return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myObject.fullName();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此种方式的<code>this</code>为<code>myObject</code>对象。</p>
</blockquote>
<ul>
<li>使用构造函数调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 构造函数:</span><br><span class="line">function myFunction(arg1, arg2) &#123;</span><br><span class="line">    this.firstName &#x3D; arg1;</span><br><span class="line">    this.lastName  &#x3D; arg2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; This    creates a new object</span><br><span class="line">var x &#x3D; new myFunction(&quot;John&quot;,&quot;Doe&quot;);</span><br><span class="line">x.firstName;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造函数的调用会创建一个新的对象，新对象继承构造函数的属性和方法，故<code>this</code>的值在函数调用实例话对象时创建，即在构造函数调用时被创建</p>
</blockquote>
<ul>
<li>作为函数方法调用函数</li>
</ul>
<blockquote>
<p>JS函数有其自己的属性和方法，<code>call()</code>和<code>apply()</code>是预定义的函数方法，可用于调用函数，其第一个参数必须为对象本身。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction(a, b) &#123;</span><br><span class="line">    return a * b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;call方法</span><br><span class="line">myObject &#x3D; myFunction.call(myObject,10,2);</span><br><span class="line">&#x2F;&#x2F;apply方法</span><br><span class="line">myArray &#x3D; [10,2];</span><br><span class="line">myObject &#x3D; myFunction.apply(myObject,myArray);</span><br></pre></td></tr></table></figure>

<p>由此可看出，<code>apply()</code>方法传入的第二个参数为参数数组，而<code>call()</code>方法直接传入所有的参数。这为二者的区别。</p>
<p>在JavaScript严格模式(strict mode)下, 在调用函数时第一个参数会成为<code>this</code>的值， 即使该参数不是一个对象。<br>在JavaScript非严格模式(non-strict mode)下, 如果第一个参数的值是<code>null</code>或<code>undefined</code>, 它将使用全局对象替代。</p>
<h3 id="二进制转换"><a href="#二进制转换" class="headerlink" title="二进制转换"></a>二进制转换</h3><ol>
<li>二进制转十进制</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;parseInt方法</span><br><span class="line">function base10(str) &#123;</span><br><span class="line">    return parseInt(str,2);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;一般方法</span><br><span class="line">function base10(str) &#123;</span><br><span class="line">    var sum &#x3D; 0;</span><br><span class="line">    var arr &#x3D; str.split(&quot;&quot;).reverse();&#x2F;&#x2F;避免pow()内写一大串</span><br><span class="line">    for(var i&#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        sum +&#x3D; arr[i]* Math.pow(2,i)</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>十进制转二进制</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let num &#x3D; 100;</span><br><span class="line">num.toString(2);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>其他</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">parseInt(num,8);   &#x2F;&#x2F;八进制转十进制</span><br><span class="line">parseInt(num,16);   &#x2F;&#x2F;十六进制转十进制</span><br><span class="line">parseInt(num).toString(8)  &#x2F;&#x2F;十进制转八进制</span><br><span class="line">parseInt(num).toString(16)   &#x2F;&#x2F;十进制转十六进制</span><br><span class="line">parseInt(num,2).toString(8)   &#x2F;&#x2F;二进制转八进制</span><br><span class="line">parseInt(num,2).toString(16)  &#x2F;&#x2F;二进制转十六进制</span><br><span class="line">parseInt(num,8).toString(2)   &#x2F;&#x2F;八进制转二进制</span><br><span class="line">parseInt(num,8).toString(16)  &#x2F;&#x2F;八进制转十六进制</span><br><span class="line">parseInt(num,16).toString(2)  &#x2F;&#x2F;十六进制转二进制</span><br><span class="line">parseInt(num,16).toString(8)  &#x2F;&#x2F;十六进制转八进制</span><br></pre></td></tr></table></figure>

<h3 id="使用-apply-调用函数"><a href="#使用-apply-调用函数" class="headerlink" title="使用 apply 调用函数"></a>使用 apply 调用函数</h3><p><strong>描述</strong></p>
<p>实现函数 callIt，调用之后满足如下条件</p>
<p>1、返回的结果为调用 fn 之后的结果</p>
<p>2、fn 的调用参数为 callIt 的第一个参数之后的全部参数</p>
<p><strong>分析</strong></p>
<p>隐式参数<code>arguments</code>不是数组，需要将它先转化为数组。</p>
<blockquote>
<p>转化<code>arguments</code>：<code>let args = Array.prototype.slice.call(arguments,0);</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function callIt(fn) &#123;</span><br><span class="line">    let args &#x3D; Array.prototype.slice.call(arguments,1);&#x2F;&#x2F;截取第一个参数之后的参数。</span><br><span class="line">    return fn.apply(this,args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><strong>描述</strong></p>
<p>找出对象 obj 不在原型链上的属性(注意这题测试例子的冒号后面也有一个空格~)</p>
<p>1、返回数组，格式为 key: value</p>
<p>2、结果数组不要求顺序</p>
<p><strong>示例1</strong></p>
<p>输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var C &#x3D; function() &#123;this.foo &#x3D; &#39;bar&#39;; this.baz &#x3D; &#39;bim&#39;;&#125;; </span><br><span class="line">C.prototype.bop &#x3D; &#39;bip&#39;; </span><br><span class="line">iterate(new C());</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<p>[“foo: bar”, “baz: bim”]</p>
<p><strong>分析</strong></p>
<p>对象不属于原型链上的属性，即实例属性，可以通过方法<code>hasOwnProperty()</code>方法找出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function iterate(obj) &#123;</span><br><span class="line">    let arr &#x3D; [];</span><br><span class="line">    for( let ele in obj)&#123;</span><br><span class="line">        if(obj.hasOwnProperty(ele))&#123;</span><br><span class="line">            arr.push(ele+&quot;: &quot;+obj[ele]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;更快的解法，使用Object.keys()返回可枚举的实例属性数组</span><br><span class="line">function iterate(obj) &#123;</span><br><span class="line">    return Object.keys(obj).map(function(key) &#123;</span><br><span class="line">        return key + &quot;: &quot; + obj[key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a>时间格式化</h3><p><strong>描述</strong></p>
<p>按所给的时间格式输出指定的时间</p>
<p>格式说明–对于 2014.09.05 13:14:20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yyyy: 年份，2014</span><br><span class="line">yy: 年份，14</span><br><span class="line">MM: 月份，补满两位，09</span><br><span class="line">M: 月份, 9</span><br><span class="line">dd: 日期，补满两位，05</span><br><span class="line">d: 日期, 5</span><br><span class="line">HH: 24制小时，补满两位，13</span><br><span class="line">H: 24制小时，13</span><br><span class="line">hh: 12制小时，补满两位，01</span><br><span class="line">h: 12制小时，1</span><br><span class="line">mm: 分钟，补满两位，14</span><br><span class="line">m: 分钟，14</span><br><span class="line">ss: 秒，补满两位，20</span><br><span class="line">s: 秒，20</span><br><span class="line">w: 星期，为 [&#39;日&#39;, &#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;, &#39;五&#39;, &#39;六&#39;] 中的某一个，本 demo 结果为 五</span><br></pre></td></tr></table></figure>

<p><strong>示例1</strong></p>
<p>输入：</p>
<p>formatDate(new Date(1409894060000), ‘yyyy-MM-dd HH:mm:ss 星期w’)</p>
<p>输出：</p>
<p>2014-09-05 13:14:20 星期五</p>
<p><strong>分析</strong></p>
<p>使用<code>Date</code>对象的各个<code>getXXX()</code>方法获得相应的年月日等值，再通过<code>str.replace()</code>方法替换格式中的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function formatDate(date,formate)&#123;</span><br><span class="line">    let year &#x3D; date.getFullYear(),</span><br><span class="line">        month &#x3D; date.getMonth()+1,</span><br><span class="line">        day &#x3D; date.getDate(),</span><br><span class="line">        week &#x3D; date.getDay(),</span><br><span class="line">        weekStr &#x3D; [&quot;日&quot;,&quot;一&quot;,&quot;二&quot;,&quot;三&quot;,&quot;四&quot;,&quot;五&quot;,&quot;六&quot;],</span><br><span class="line">        hour &#x3D; date.getHours(),</span><br><span class="line">        minute &#x3D; date.getMinutes(),</span><br><span class="line">        seconds &#x3D; date.getSeconds();</span><br><span class="line">    let format0 &#x3D; function(num)&#123;</span><br><span class="line">        if(num &lt; 10)&#123;</span><br><span class="line">            return 0 + &quot;&quot; + num;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    let dateObj &#x3D; &#123;</span><br><span class="line">        &quot;yyyy&quot;: year,</span><br><span class="line">        &quot;yy&quot;: year%100,</span><br><span class="line">        &quot;MM&quot;: format0(month),</span><br><span class="line">        &quot;M&quot;: month,</span><br><span class="line">        &quot;dd&quot;: format0(day),</span><br><span class="line">        &quot;d&quot;: day,</span><br><span class="line">        &quot;w&quot;: weekStr[week],</span><br><span class="line">        &quot;HH&quot;: format0(hour),</span><br><span class="line">        &quot;H&quot;: hour,</span><br><span class="line">        &quot;hh&quot;:format0(hour%12),</span><br><span class="line">        &quot;h&quot;: hour%12,</span><br><span class="line">        &quot;mm&quot;: format0(minute),</span><br><span class="line">        &quot;m&quot;: minute,</span><br><span class="line">        &quot;ss&quot;: format0(seconds),</span><br><span class="line">         &quot;s&quot;: seconds</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    for(let obj in dateObj)&#123;</span><br><span class="line">        formate &#x3D; formate.replace(obj,dateObj[obj]);</span><br><span class="line">    &#125;</span><br><span class="line">    return formate;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（六）</title>
    <url>/post/a22a7a3e.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/3341038055.html">结合Vue3-demo项目分析源码（五）</a>，完成组件的渲染，结束<code>mounted</code>生命周期。此时可以在页面看到内容了。当添加事件修改数据时，Vue进入组件更新过程。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="MVVM模型"><a href="#MVVM模型" class="headerlink" title="MVVM模型"></a>MVVM模型</h3><p><img src="https://z3.ax1x.com/2021/05/29/2APBIx.png" alt="mvvm模型"></p>
<a id="more"></a>

<ul>
<li><p>Model（模型）：表示应用程序核心</p>
</li>
<li><p>View（视图）：显示数据（数据库记录）</p>
</li>
<li><p>ViewModel（视图模型）：暴露公共属性和命令的视图的抽象</p>
</li>
</ul>
<p>按登陆demo理解:</p>
<p>App.vue：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 登录成功后的提示 --&gt;</span><br><span class="line">    &lt;div v-if&#x3D;&quot;isLogin&quot;&gt;欢迎你：&#123;&#123; user.name &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 登录操作 --&gt;</span><br><span class="line">    &lt;div v-else&gt;</span><br><span class="line">      用户名：</span><br><span class="line">      &lt;input name&#x3D;&quot;name&quot; v-model&#x3D;&quot;user.name&quot; &#x2F;&gt;</span><br><span class="line">      &lt;br &#x2F;&gt;</span><br><span class="line">      密码：</span><br><span class="line">      &lt;input name&#x3D;&quot;pwd&quot; v-model&#x3D;&quot;user.pwd&quot; type&#x3D;&quot;password&quot; &#x2F;&gt;</span><br><span class="line">      &lt;br &#x2F;&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;onLogin&quot;&gt;去登录&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref, reactive &#125; from &quot;vue&quot;;</span><br><span class="line">import * as UserModel from &quot;.&#x2F;UserModel&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;app&quot;,</span><br><span class="line">  props: [&quot;msg&quot;],</span><br><span class="line">  setup() &#123;</span><br><span class="line">    let isLogin &#x3D; ref(false); &#x2F;&#x2F; 是否已经登录</span><br><span class="line">    let user &#x3D; reactive(&#123;</span><br><span class="line">      name: &quot;&quot;, &#x2F;&#x2F; 用户名</span><br><span class="line">      pwd: &quot;&quot;, &#x2F;&#x2F; 密码</span><br><span class="line">    &#125;);</span><br><span class="line">    const onLogin &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 去登录</span><br><span class="line">      UserModel.login(user.name, user.pwd).then(</span><br><span class="line">        (res) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 登录成功</span><br><span class="line">          if (res) &#123;</span><br><span class="line">            isLogin.value &#x3D; true;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        (errorMsg) &#x3D;&gt; &#123;</span><br><span class="line">          &#x2F;&#x2F; 登录失败</span><br><span class="line">          alert(errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line">      );</span><br><span class="line">    &#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">      isLogin,</span><br><span class="line">      user,</span><br><span class="line">      onLogin,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>UserModel.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 登录业务逻辑</span><br><span class="line"> * @param &#123;*&#125; name 用户名</span><br><span class="line"> * @param &#123;*&#125; pwd 密码</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function login(name, pwd) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    if (&quot;123456&quot; &#x3D;&#x3D;&#x3D; pwd) &#123;</span><br><span class="line">      resolve(true);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      reject(&quot;用户名或密码错误&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功：</p>
<p><img src="https://z3.ax1x.com/2021/05/29/2AiGTI.png" alt="2AiGTI.png"></p>
<p>失败：</p>
<p><img src="https://z3.ax1x.com/2021/05/29/2AiYkt.png" alt="2AiYkt.png"></p>
<p>由上，<code>UserModel</code>为<code>MVVM</code>的<code>Model</code>，用来处理用户的业务逻辑；<code>App.vue</code>组件为<code>MVVM</code>的<code>View</code>，作为视图显示内容；而<code>setupState</code>为<code>MVVM</code>的<code>ViewModel</code>，用来驱动视图显示。</p>
<h3 id="分析实现代码"><a href="#分析实现代码" class="headerlink" title="分析实现代码"></a>分析实现代码</h3><h4 id="ref"><a href="#ref" class="headerlink" title="ref()"></a>ref()</h4><p>由上，<code>let isLogin = ref(false);</code>，<code>isLogin</code>是经过<code>ref</code>方法返回的对象。当点击登陆按钮时，<code>isLogin.value</code>属性被设置成<code>true</code></p>
<p>查看文件<code>vue-next/packages/reactivity/src/ref.ts</code>第41行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function ref(value?: unknown) &#123;</span><br><span class="line">  return createRef(value)</span><br><span class="line">&#125;</span><br><span class="line">function createRef(rawValue: unknown, shallow &#x3D; false) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;创建并返回一个RefImpl对象</span><br><span class="line">  return new RefImpl(rawValue, shallow)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;RefImpl对象</span><br><span class="line">class RefImpl&lt;T&gt; &#123;</span><br><span class="line">  private _value: T</span><br><span class="line"></span><br><span class="line">  public readonly __v_isRef &#x3D; true</span><br><span class="line"></span><br><span class="line">  constructor(private _rawValue: T, public readonly _shallow &#x3D; false) &#123;</span><br><span class="line">    this._value &#x3D; _shallow ? _rawValue : convert(_rawValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get value() &#123;</span><br><span class="line">    track(toRaw(this), TrackOpTypes.GET, &#39;value&#39;)</span><br><span class="line">    return this._value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set value(newVal) &#123;</span><br><span class="line">    &#x2F;&#x2F;对比新老数据，不一样时set</span><br><span class="line">    if (hasChanged(toRaw(newVal), this._rawValue)) &#123;</span><br><span class="line">      &#x2F;&#x2F;将新数据赋给原始值</span><br><span class="line">      this._rawValue &#x3D; newVal</span><br><span class="line">      this._value &#x3D; this._shallow ? newVal : convert(newVal)</span><br><span class="line">      &#x2F;&#x2F;调用trigger方法告诉Vue有数据更新</span><br><span class="line">      trigger(toRaw(this), TriggerOpTypes.SET, &#39;value&#39;, newVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="trigger"><a href="#trigger" class="headerlink" title="trigger()"></a>trigger()</h4><p>查看文件<code>vue-next/packages/reactivity/src/effect.ts</code>第167行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function trigger(</span><br><span class="line">  target: object,</span><br><span class="line">  type: TriggerOpTypes,</span><br><span class="line">  key?: unknown,</span><br><span class="line">  newValue?: unknown,</span><br><span class="line">  oldValue?: unknown,</span><br><span class="line">  oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F;根据target获取所有依赖当前target的组件</span><br><span class="line">  const depsMap &#x3D; targetMap.get(target)</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;调用组件update方法</span><br><span class="line">  const run &#x3D; (effect: ReactiveEffect) &#x3D;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    if (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;循环遍历所有组件的update方法</span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上，<code>trigger</code>方法获取了依赖<code>isLogin</code>的所有组件<code>depsMap</code>，并遍历所有组件执行这些组件的<code>update</code>方法。<code>update</code>方法即在<a href="https://awesolynn.me/post/3341038055.html">结合Vue3-demo项目分析源码（五）</a>中提到的<code>setupRenderEffect</code>中由<code>effect</code>方法定义的<code>instance.update</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const setupRenderEffect: SetupRenderEffectFn &#x3D; (</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; create reactive effect for rendering</span><br><span class="line">    &#x2F;&#x2F;定义组件的update方法，通过响应式来调用渲染组件</span><br><span class="line">    instance.update &#x3D; effect(function componentEffect() &#123;</span><br><span class="line">      &#x2F;&#x2F;组件第一次渲染</span><br><span class="line">      if (!instance.isMounted) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#x2F;&#x2F;若不是第一次渲染  </span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        let &#123; next, bu, u, parent, vnode &#125; &#x3D; instance</span><br><span class="line">        let originNext &#x3D; next</span><br><span class="line">        let vnodeHook: VNodeHook | null | undefined</span><br><span class="line">        &#x2F;&#x2F; beforeUpdate hook</span><br><span class="line">        &#x2F;&#x2F;调用beforeUpdate生命周期</span><br><span class="line">        if (bu) &#123;</span><br><span class="line">          invokeArrayFns(bu)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 调用vnode的onVnodeBeforeUpdate钩子函数</span><br><span class="line">        if ((vnodeHook &#x3D; next.props &amp;&amp; next.props.onVnodeBeforeUpdate)) &#123;</span><br><span class="line">          invokeVNodeHook(vnodeHook, parent, next, vnode)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 获取一个新节点</span><br><span class="line">        const nextTree &#x3D; renderComponentRoot(instance)</span><br><span class="line">        &#x2F;&#x2F; 老节点</span><br><span class="line">        const prevTree &#x3D; instance.subTree</span><br><span class="line">        instance.subTree &#x3D; nextTree</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;使用patch对比新老节点</span><br><span class="line">        patch(</span><br><span class="line">          prevTree,</span><br><span class="line">          nextTree,</span><br><span class="line">          &#x2F;&#x2F; parent may have changed if it&#39;s in a teleport</span><br><span class="line">          hostParentNode(prevTree.el!)!,</span><br><span class="line">          &#x2F;&#x2F; anchor may have changed if it&#39;s in a fragment</span><br><span class="line">          getNextHostNode(prevTree),</span><br><span class="line">          instance,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG</span><br><span class="line">        )</span><br><span class="line">        ...</span><br><span class="line">        next.el &#x3D; nextTree.el</span><br><span class="line">        &#x2F;&#x2F; updated hook</span><br><span class="line">        &#x2F;&#x2F;调用updated生命周期</span><br><span class="line">        if (u) &#123;</span><br><span class="line">          queuePostRenderEffect(u, parentSuspense)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 调用vnode的onVnodeUpdated钩子函数</span><br><span class="line">        if ((vnodeHook &#x3D; next.props &amp;&amp; next.props.onVnodeUpdated)) &#123;</span><br><span class="line">          queuePostRenderEffect(() &#x3D;&gt; &#123;</span><br><span class="line">            invokeVNodeHook(vnodeHook!, parent, next!, vnode)</span><br><span class="line">          &#125;, parentSuspense)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 组件更新结束</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于更新非首次渲染，故调用了<code>beforeUpdate</code>生命周期。接着使用<code>onVnodeBeforeUpdate</code>钩子函数，其作用与<code>beforeUpdate</code>生命周期类似。然后<code>update</code>调用<code>renderComponentRoot</code>方法，根据组件的不同类型调用<code>render</code>方法创建并返回一个<code>vnode</code>节点，即上述代码的<code>nextTree</code>变量。然后将新节点<code>nextTree</code>和老节点<code>prevTree</code>传入<code>patch</code>方法对比</p>
<p>由于更新后改变的元素是<code>v-if</code>和<code>v-else</code>绑定的两个<code>div</code>节点，属于<code>ELEMENT</code>类型，按<a href="https://awesolynn.me/post/1384730263.html">结合Vue3-demo项目分析源码（二）</a>中分析，<code>ELEMENT</code>类型调用方法<code>processElement</code>。由于更新非第一次渲染，故按<a href="https://awesolynn.me/post/3341038055.html">结合Vue3-demo项目分析源码（五）</a>中分析，非首次渲染调用<code>patchElement</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const processElement &#x3D; (</span><br><span class="line">  n1: VNode | null,</span><br><span class="line">  n2: VNode,</span><br><span class="line">  container: RendererElement,</span><br><span class="line">  anchor: RendererNode | null,</span><br><span class="line">  parentComponent: ComponentInternalInstance | null,</span><br><span class="line">  parentSuspense: SuspenseBoundary | null,</span><br><span class="line">  isSVG: boolean,</span><br><span class="line">  optimized: boolean</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">  isSVG &#x3D; isSVG || (n2.type as string) &#x3D;&#x3D;&#x3D; &#39;svg&#39;</span><br><span class="line">  &#x2F;&#x2F;组件第一次渲染时</span><br><span class="line">  if (n1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="patchElement"><a href="#patchElement" class="headerlink" title="patchElement()"></a>patchElement()</h4><p>查看文件<code>vue-next/packages/runtime-core/src/renderer.ts</code>第857行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const patchElement &#x3D; (</span><br><span class="line">  n1: VNode,</span><br><span class="line">  n2: VNode,</span><br><span class="line">  parentComponent: ComponentInternalInstance | null,</span><br><span class="line">  parentSuspense: SuspenseBoundary | null,</span><br><span class="line">  isSVG: boolean,</span><br><span class="line">  optimized: boolean</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  if (patchFlag &gt; 0) &#123;</span><br><span class="line">    &#x2F;&#x2F; the presence of a patchFlag means this element&#39;s render code was</span><br><span class="line">    &#x2F;&#x2F; generated by the compiler and can take the fast path.</span><br><span class="line">    &#x2F;&#x2F; in this path old node and new node are guaranteed to have the same shape</span><br><span class="line">    &#x2F;&#x2F; (i.e. at the exact same position in the source template)</span><br><span class="line">    &#x2F;&#x2F;依次对比两个元素的属性值，判断有不一样的属性时替换新属性</span><br><span class="line">    if (patchFlag &amp; PatchFlags.FULL_PROPS) &#123;</span><br><span class="line">      &#x2F;&#x2F; element props contain dynamic keys, full diff needed</span><br><span class="line">      patchProps(</span><br><span class="line">        el,</span><br><span class="line">        n2,</span><br><span class="line">        oldProps,</span><br><span class="line">        newProps,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG</span><br><span class="line">      )</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;对比两个元素的class属性</span><br><span class="line">      &#x2F;&#x2F; class</span><br><span class="line">      &#x2F;&#x2F; this flag is matched when the element has dynamic class bindings.</span><br><span class="line">      if (patchFlag &amp; PatchFlags.CLASS) &#123;</span><br><span class="line">        &#x2F;&#x2F;class有变化时替换新的class</span><br><span class="line">        if (oldProps.class !&#x3D;&#x3D; newProps.class) &#123;</span><br><span class="line">          hostPatchProp(el, &#39;class&#39;, null, newProps.class, isSVG)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; style</span><br><span class="line">      &#x2F;&#x2F; this flag is matched when the element has dynamic style bindings</span><br><span class="line">      &#x2F;&#x2F;对比两个元素的style属性有没有不同</span><br><span class="line">      if (patchFlag &amp; PatchFlags.STYLE) &#123;</span><br><span class="line">        hostPatchProp(el, &#39;style&#39;, oldProps.style, newProps.style, isSVG)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; props</span><br><span class="line">      &#x2F;&#x2F; This flag is matched when the element has dynamic prop&#x2F;attr bindings</span><br><span class="line">      &#x2F;&#x2F; other than class and style. The keys of dynamic prop&#x2F;attrs are saved for</span><br><span class="line">      &#x2F;&#x2F; faster iteration.</span><br><span class="line">      &#x2F;&#x2F; Note dynamic keys like :[foo]&#x3D;&quot;bar&quot; will cause this optimization to</span><br><span class="line">      &#x2F;&#x2F; bail out and go through a full diff because we need to unset the old key</span><br><span class="line">      &#x2F;&#x2F;对比两个元素的属性值有没有不同</span><br><span class="line">      if (patchFlag &amp; PatchFlags.PROPS) &#123;</span><br><span class="line">        &#x2F;&#x2F; if the flag is present then dynamicProps must be non-null</span><br><span class="line">        const propsToUpdate &#x3D; n2.dynamicProps!</span><br><span class="line">        for (let i &#x3D; 0; i &lt; propsToUpdate.length; i++) &#123;</span><br><span class="line">          const key &#x3D; propsToUpdate[i]</span><br><span class="line">          const prev &#x3D; oldProps[key]</span><br><span class="line">          const next &#x3D; newProps[key]</span><br><span class="line">          if (</span><br><span class="line">            next !&#x3D;&#x3D; prev ||</span><br><span class="line">            (hostForcePatchProp &amp;&amp; hostForcePatchProp(el, key))</span><br><span class="line">          ) &#123;</span><br><span class="line">            hostPatchProp(</span><br><span class="line">              el,</span><br><span class="line">              key,</span><br><span class="line">              prev,</span><br><span class="line">              next,</span><br><span class="line">              isSVG,</span><br><span class="line">              n1.children as VNode[],</span><br><span class="line">              parentComponent,</span><br><span class="line">              parentSuspense,</span><br><span class="line">              unmountChildren</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; text</span><br><span class="line">    &#x2F;&#x2F; This flag is matched when the element has only dynamic text children.</span><br><span class="line">    &#x2F;&#x2F;对比两个元素的文本内容有没有不同</span><br><span class="line">    if (patchFlag &amp; PatchFlags.TEXT) &#123;</span><br><span class="line">      &#x2F;&#x2F;若有不同，则替换成新的文本</span><br><span class="line">      if (n1.children !&#x3D;&#x3D; n2.children) &#123;</span><br><span class="line">        hostSetElementText(el, n2.children as string)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码表示，当出现两个新老节点时，会判断两个元素的<code>class</code>、<code>style</code>、<code>文本值TEXT</code>等是否一致，若有不同，则替换为新的属性。其中，判断是否一致的逻辑即为<code>差分算法</code>。</p>
<p>如上述对比两个元素的<code>sytle</code>属性，调用方法<code>hotPatchProp</code>方法</p>
<p>查看文件<code>vue-next/packages/runtime-dom/src/patchProp.ts</code>第16行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const patchProp: DOMRendererOptions[&#39;patchProp&#39;] &#x3D; (</span><br><span class="line">  el,</span><br><span class="line">  key,</span><br><span class="line">  prevValue,</span><br><span class="line">  nextValue,</span><br><span class="line">  isSVG &#x3D; false,</span><br><span class="line">  prevChildren,</span><br><span class="line">  parentComponent,</span><br><span class="line">  parentSuspense,</span><br><span class="line">  unmountChildren</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">  switch (key) &#123;</span><br><span class="line">    ...</span><br><span class="line">    case &#39;style&#39;:</span><br><span class="line">      patchStyle(el, prevValue, nextValue)</span><br><span class="line">      break</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 对比 style</span><br><span class="line">export function patchStyle(el: Element, prev: Style, next: Style) &#123;</span><br><span class="line">  const style &#x3D; (el as HTMLElement).style</span><br><span class="line">  &#x2F;&#x2F; 如果新节点没有 style 属性的话就直接移除 style 属性</span><br><span class="line">  if (!next) &#123;</span><br><span class="line">    el.removeAttribute(&#39;style&#39;)</span><br><span class="line">  &#x2F;&#x2F; 如果新节点的 style 属性是原始文本类型</span><br><span class="line">  &#125; else if (isString(next)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断两个 style 属性文本是否一致</span><br><span class="line">    if (prev !&#x3D;&#x3D; next) &#123;</span><br><span class="line">      style.cssText &#x3D; next</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果新节点中 style 属性是一个对象形式</span><br><span class="line">    for (const key in next) &#123;</span><br><span class="line">      &#x2F;&#x2F; 设置 style 属性</span><br><span class="line">      setStyle(style, key, next[key])</span><br><span class="line">    &#125;</span><br><span class="line">    if (prev &amp;&amp; !isString(prev)) &#123;</span><br><span class="line">      for (const key in prev) &#123;</span><br><span class="line">        if (next[key] &#x3D;&#x3D; null) &#123;</span><br><span class="line">          setStyle(style, key, &#39;&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="差分算法"><a href="#差分算法" class="headerlink" title="差分算法"></a>差分算法</h4><p>概念：</p>
<p>a数列：<code>a[1],a[2],a[3],...,a[n]</code></p>
<p>创建b数列，令<code>b[i] = a[i] - a[i-1]</code>，则<code>b[1] = a[1]</code>、<code>b[2] = a[2] - a[1]</code>等</p>
<p>则<code>a[i] = b[1] + b[2] + ... + b[i]</code></p>
<p>即<code>a[i] = a[1] + a[2] - a[1] + a[3] - a[2] + ... + b[i] - b[i-1]</code></p>
<p>因此，b数组为a数组的<code>差分数组</code>，a数组为b数组的<code>前缀和数组</code></p>
<p>以上，Vue3源码分析结束。</p>
<h2 id="附录-Vue3流程图"><a href="#附录-Vue3流程图" class="headerlink" title="附录-Vue3流程图"></a>附录-Vue3流程图</h2><p><img src="https://z3.ax1x.com/2021/05/26/2pvc1f.md.jpg" alt="vue流程图"></p>
<p>a[l,r]+c</p>
<p>b[l] + c = a[l] - a[l-1] + c</p>
<p>b[r] = a[r] - a[r-1]</p>
<p>b[r+1] - c = a[r+1] - a[r] -c</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（五）</title>
    <url>/post/3341038055.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/2830824608.html">结合Vue3-demo项目分析源码（四）</a>，完成组件的创建，包含创建组件实例<code>createComponentInstance</code>和设置组件实例<code>setupComponent</code>两个步骤。整个组件的创建过程涉及到两个生命周期<code>beforeCreated</code>和<code>created</code>，到<code>created</code>才算组件创建完成，此时进入组件的渲染过程。回到<code>mountComponent()</code>方法，查看方法<code>setupRenderEffect()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mountComponent: MountComponentFn &#x3D; (</span><br><span class="line">    ...</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;创建组件实例</span><br><span class="line">    const instance: ComponentInternalInstance &#x3D; (initialVNode.component &#x3D; createComponentInstance(...))</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置组件实例</span><br><span class="line">    setupComponent(instance)</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;处理setup方法</span><br><span class="line">    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense,isSVG, optimized)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="setupRenderEffect"><a href="#setupRenderEffect" class="headerlink" title="setupRenderEffect()"></a>setupRenderEffect()</h3><p>查看文件<code>vue-next/packages/runtime-core/src/renderer.ts</code>第1323行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const setupRenderEffect: SetupRenderEffectFn &#x3D; (</span><br><span class="line">    instance,</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; create reactive effect for rendering</span><br><span class="line">    &#x2F;&#x2F;定义组件的update方法，通过响应式来调用渲染组件</span><br><span class="line">    instance.update &#x3D; effect(function componentEffect() &#123;</span><br><span class="line">      &#x2F;&#x2F;组件第一次渲染</span><br><span class="line">      if (!instance.isMounted) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; beforeMount hook</span><br><span class="line">        &#x2F;&#x2F;调用beforeMount生命周期</span><br><span class="line">        if (bm) &#123;</span><br><span class="line">          invokeArrayFns(bm)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 调用Vnode的onVnodeBeforeMount钩子函数</span><br><span class="line">        if ((vnodeHook &#x3D; props &amp;&amp; props.onVnodeBeforeMount)) &#123;</span><br><span class="line">          invokeVNodeHook(vnodeHook, parent, initialVNode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; render</span><br><span class="line">        &#x2F;&#x2F;渲染组件</span><br><span class="line">        ...</span><br><span class="line">        const subTree &#x3D; (instance.subTree &#x3D; renderComponentRoot(instance))</span><br><span class="line">        if (__DEV__) &#123;</span><br><span class="line">          endMeasure(instance, &#96;render&#96;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (el &amp;&amp; hydrateNode) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          ...</span><br><span class="line">          &#x2F;&#x2F;使用patch方法对比新老节点</span><br><span class="line">          patch(</span><br><span class="line">            null,</span><br><span class="line">            subTree,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            instance,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG</span><br><span class="line">          )</span><br><span class="line">          ...</span><br><span class="line">          &#x2F;&#x2F; 设置vnode的el属性</span><br><span class="line">          initialVNode.el &#x3D; subTree.el</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; mounted hook</span><br><span class="line">        &#x2F;&#x2F;调用mounted生命周期</span><br><span class="line">        if (m) &#123;</span><br><span class="line">          queuePostRenderEffect(m, parentSuspense)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 调用Vnode节点的onVnodeMounted钩子函数</span><br><span class="line">        if ((vnodeHook &#x3D; props &amp;&amp; props.onVnodeMounted)) &#123;</span><br><span class="line">          queuePostRenderEffect(() &#x3D;&gt; &#123;</span><br><span class="line">            invokeVNodeHook(vnodeHook!, parent, initialVNode)</span><br><span class="line">          &#125;, parentSuspense)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; activated hook for keep-alive roots.</span><br><span class="line">        &#x2F;&#x2F; #1742 activated hook must be accessed after first render</span><br><span class="line">        &#x2F;&#x2F; since the hook may be injected by a child keep-alive</span><br><span class="line">        &#x2F;&#x2F;若是keep-alive类型的组件就调用activated生命周期</span><br><span class="line">        const &#123; a &#125; &#x3D; instance</span><br><span class="line">        if (</span><br><span class="line">          a &amp;&amp;</span><br><span class="line">          initialVNode.shapeFlag &amp; ShapeFlags.COMPONENT_SHOULD_KEEP_ALIVE</span><br><span class="line">        ) &#123;</span><br><span class="line">          queuePostRenderEffect(a, parentSuspense)</span><br><span class="line">        &#125;</span><br><span class="line">        instance.isMounted &#x3D; true</span><br><span class="line">        &#x2F;&#x2F;组件渲染完成</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;若不是第一次渲染  </span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; beforeUpdate hook</span><br><span class="line">        &#x2F;&#x2F;调用beforeUpdate生命周期</span><br><span class="line">        if (bu) &#123;</span><br><span class="line">          invokeArrayFns(bu)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 调用vnode的onVnodeBeforeUpdate钩子函数</span><br><span class="line">        if ((vnodeHook &#x3D; next.props &amp;&amp; next.props.onVnodeBeforeUpdate)) &#123;</span><br><span class="line">          invokeVNodeHook(vnodeHook, parent, next, vnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; render</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F;使用patch对比新老节点</span><br><span class="line">        patch(</span><br><span class="line">          prevTree,</span><br><span class="line">          nextTree,</span><br><span class="line">          &#x2F;&#x2F; parent may have changed if it&#39;s in a teleport</span><br><span class="line">          hostParentNode(prevTree.el!)!,</span><br><span class="line">          &#x2F;&#x2F; anchor may have changed if it&#39;s in a fragment</span><br><span class="line">          getNextHostNode(prevTree),</span><br><span class="line">          instance,</span><br><span class="line">          parentSuspense,</span><br><span class="line">          isSVG</span><br><span class="line">        )</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; updated hook</span><br><span class="line">        &#x2F;&#x2F;调用updated生命周期</span><br><span class="line">        if (u) &#123;</span><br><span class="line">          queuePostRenderEffect(u, parentSuspense)</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 调用vnode的onVnodeUpdated钩子函数</span><br><span class="line">        if ((vnodeHook &#x3D; next.props &amp;&amp; next.props.onVnodeUpdated)) &#123;</span><br><span class="line">          queuePostRenderEffect(() &#x3D;&gt; &#123;</span><br><span class="line">            invokeVNodeHook(vnodeHook!, parent, next!, vnode)</span><br><span class="line">          &#125;, parentSuspense)</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>effect</code>方法给当前组件实例<code>instance</code>提供了<code>update</code>方法</p>
<h3 id="effect"><a href="#effect" class="headerlink" title="effect()"></a>effect()</h3><p>查看文件<code>vue-next/packages/reactivity/src/effect.ts</code>第55行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function effect&lt;T &#x3D; any&gt;(</span><br><span class="line">  fn: () &#x3D;&gt; T,</span><br><span class="line">  options: ReactiveEffectOptions &#x3D; EMPTY_OBJ</span><br><span class="line">): ReactiveEffect&lt;T&gt; &#123;</span><br><span class="line">  if (isEffect(fn)) &#123;</span><br><span class="line">    fn &#x3D; fn.raw</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;创建一个响应式的effect方法，即fn的高阶函数</span><br><span class="line">  const effect &#x3D; createReactiveEffect(fn, options)</span><br><span class="line">  &#x2F;&#x2F;若不是懒加载模式</span><br><span class="line">  if (!options.lazy) &#123;</span><br><span class="line">    &#x2F;&#x2F;直接调用effect方法，最后调用传递的fn方法</span><br><span class="line">    effect()</span><br><span class="line">  &#125;</span><br><span class="line">  return effect</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>effect</code>方法返回一个高阶函数，高阶函数内部调用的是传入的函数，即<code>setupRenderEffect</code>中传入的<code>componentEffect</code>。最终把高阶函数传递给<code>instance</code>的update属性。若不指定懒加载<code>lazy=true</code>则，effect会立即调用传入的<code>componentEffect</code>方法。</p>
<h3 id="beforeMount生命周期"><a href="#beforeMount生命周期" class="headerlink" title="beforeMount生命周期"></a>beforeMount生命周期</h3><blockquote>
<p>当组件为第一次渲染时，首先调用生命周期beforeMount方法</p>
</blockquote>
<p>生命周期<code>beforeMount</code>在<code>created</code>之后，但两者差别不大，平时可以在这两个生命周期做一些渲染前的准备工作。如网络请求，页面初始数据的操作等</p>
<h3 id="renderComponentRoot"><a href="#renderComponentRoot" class="headerlink" title="renderComponentRoot()"></a>renderComponentRoot()</h3><p>调用完生命周期<code>beforeMount</code>，进入到组件渲染，首先调用<code>renderComponentRoot</code>方法</p>
<p>查看文件<code>vue-next/packages/runtime-core/src/componentRenderUtils.ts</code>第45行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function renderComponentRoot(</span><br><span class="line">  instance: ComponentInternalInstance</span><br><span class="line">): VNode &#123;</span><br><span class="line">  ...</span><br><span class="line">  try &#123;</span><br><span class="line">    let fallthroughAttrs</span><br><span class="line">    &#x2F;&#x2F;若为有状态组件（非函数式、element）</span><br><span class="line">    if (vnode.shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT) &#123;</span><br><span class="line">      &#x2F;&#x2F; withProxy is a proxy with a different &#96;has&#96; trap only for</span><br><span class="line">      &#x2F;&#x2F; runtime-compiled render functions using &#96;with&#96; block.</span><br><span class="line">      const proxyToUse &#x3D; withProxy || proxy</span><br><span class="line">      &#x2F;&#x2F;调用当前组件的render方法获取vnode节点</span><br><span class="line">      result &#x3D; normalizeVNode(</span><br><span class="line">        render!.call(</span><br><span class="line">          proxyToUse,</span><br><span class="line">          proxyToUse!,</span><br><span class="line">          renderCache,</span><br><span class="line">          props,</span><br><span class="line">          setupState,</span><br><span class="line">          data,</span><br><span class="line">          ctx</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">      fallthroughAttrs &#x3D; attrs</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;函数式节点</span><br><span class="line">      &#x2F;&#x2F; functional</span><br><span class="line">      const render &#x3D; Component as FunctionalComponent</span><br><span class="line">      &#x2F;&#x2F; in dev, mark attrs accessed if optional props (attrs &#x3D;&#x3D;&#x3D; props)</span><br><span class="line">      if (__DEV__ &amp;&amp; attrs &#x3D;&#x3D;&#x3D; props) &#123;</span><br><span class="line">        markAttrsAccessed()</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;直接调用函数获取vnode节点，第一个参数为props，第二个参数为[attrs,slots,emit]</span><br><span class="line">      result &#x3D; normalizeVNode(</span><br><span class="line">        render.length &gt; 1</span><br><span class="line">          ? render(</span><br><span class="line">              props,</span><br><span class="line">              __DEV__</span><br><span class="line">                ? &#123;</span><br><span class="line">                    get attrs() &#123;</span><br><span class="line">                      markAttrsAccessed()</span><br><span class="line">                      return attrs</span><br><span class="line">                    &#125;,</span><br><span class="line">                    slots,</span><br><span class="line">                    emit</span><br><span class="line">                  &#125;</span><br><span class="line">                : &#123; attrs, slots, emit &#125;</span><br><span class="line">            )</span><br><span class="line">          : render(props, null as any &#x2F;* we know it doesn&#39;t need it *&#x2F;)</span><br><span class="line">      )</span><br><span class="line">      fallthroughAttrs &#x3D; Component.props</span><br><span class="line">        ? attrs</span><br><span class="line">        : getFunctionalFallthrough(attrs)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; attr merging</span><br><span class="line">    &#x2F;&#x2F; in dev mode, comments are preserved, and it&#39;s possible for a template</span><br><span class="line">    &#x2F;&#x2F; to have comments along side the root element which makes it a fragment</span><br><span class="line">    let root &#x3D; result</span><br><span class="line">    let setRoot: ((root: VNode) &#x3D;&gt; void) | undefined &#x3D; undefined</span><br><span class="line">    if (__DEV__ &amp;&amp; result.patchFlag &amp; PatchFlags.DEV_ROOT_FRAGMENT) &#123;</span><br><span class="line">      ;[root, setRoot] &#x3D; getChildRoot(result)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;给当前节点设置继承的属性</span><br><span class="line">    if (Component.inheritAttrs !&#x3D;&#x3D; false &amp;&amp; fallthroughAttrs) &#123;</span><br><span class="line">      const keys &#x3D; Object.keys(fallthroughAttrs)</span><br><span class="line">      const &#123; shapeFlag &#125; &#x3D; root</span><br><span class="line">      if (keys.length) &#123;</span><br><span class="line">        ...</span><br><span class="line">          root &#x3D; cloneVNode(root, fallthroughAttrs)</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; inherit directives</span><br><span class="line">    &#x2F;&#x2F;给当前节点设置继承的指令</span><br><span class="line">    if (vnode.dirs) &#123;</span><br><span class="line">      ...</span><br><span class="line">      root.dirs &#x3D; root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; inherit transition data</span><br><span class="line">    &#x2F;&#x2F;给当前节点设置继承的过渡数据</span><br><span class="line">    if (vnode.transition) &#123;</span><br><span class="line">      ...</span><br><span class="line">      root.transition &#x3D; vnode.transition</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  currentRenderingInstance &#x3D; null</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法通过调用当前组件的<code>render</code>方法创建并返回了vnode节点，在调用<code>render</code>方法时分<code>函数式组件</code>和<code>普通组件</code>两种情况调用</p>
<h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>定义一个函数式组件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义一个函数式组件</span><br><span class="line"> * @param &#123;*&#125; props 组件的参数</span><br><span class="line"> * @param &#123;*&#125; renderContext 当前组件的上下文对象</span><br><span class="line">*&#x2F;</span><br><span class="line">import &#123; h &#125; from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">export default function AppFunComponent(props,&#123;attrs,slots,emit&#125;)&#123;</span><br><span class="line">    &#x2F;&#x2F;返回App.vue组件的vnode节点</span><br><span class="line">    return h(App,props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;;</span><br><span class="line">&#x2F;&#x2F; import App from &quot;.&#x2F;App&quot;; &#x2F;&#x2F; 引入 App.vue 组件</span><br><span class="line">import App from &quot;.&#x2F;AppFunComponent&quot;; &#x2F;&#x2F; 引入 AppFunComponent 函数式组件</span><br><span class="line">const app &#x3D; createApp(App, &#123; msg: &quot;hello Vue 3&quot; &#125;); &#x2F;&#x2F; 创建 App 根组件</span><br><span class="line">app.mount(&quot;#app&quot;); &#x2F;&#x2F; 渲染 App</span><br></pre></td></tr></table></figure>

<p>函数式组件属于无状态组件，即没有<code>data</code>、<code>setupState</code>等响应式的对象，比较轻量级，渲染起来比普通组件快。故当组件不需要<code>data</code>和<code>setupState</code>也能运行时，可以创建函数式组件，会提高效率</p>
<h4 id="inheritAttrs"><a href="#inheritAttrs" class="headerlink" title="inheritAttrs"></a>inheritAttrs</h4><p>给函数组件添加一个子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 定义一个函数式组件</span><br><span class="line"> * @param &#123;*&#125; props 组件的参数</span><br><span class="line"> * @param &#123;*&#125; renderContext 当前组件的上下文对象</span><br><span class="line">*&#x2F;</span><br><span class="line">import &#123; h &#125; from &#39;vue&#39;;</span><br><span class="line">import App from &#39;.&#x2F;App&#39;;</span><br><span class="line">export default function AppFunComponent(props,&#123;attrs,slots,emit&#125;)&#123;</span><br><span class="line">    &#x2F;&#x2F;返回App.vue组件的vnode节点</span><br><span class="line">    &#x2F;&#x2F; return h(App, props);</span><br><span class="line">    return h(App,&#123;...props,msg1:&quot;继承属性&quot;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当运行时，子节点属性<code>msg1</code>被绑定到根节点<code>&lt;div&gt;</code>上</p>
<p><img src="https://z3.ax1x.com/2021/05/28/2kQuwT.png" alt="继承属性"></p>
<p>若不想让Vue自动绑定这些继承的属性，可以将<code>inheritAttrs</code>设为<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">    inheritAttrs: false,</span><br><span class="line">    name: &quot;app&quot;,</span><br><span class="line">    props: [&quot;msg&quot;, &quot;testWord&quot;,&quot;user&quot;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当组件中不需要自动绑定属性到根节点，则建议将组件的<code>inheritAttr</code>设为<code>false</code>，可以优化性能。因为Vue默认会绑定所有继承的属性到组件的根节点。</p>
</blockquote>
<p>由上，调用<code>renderComponentRoot</code>即调用其<code>render</code>方法获取到一个<code>ELEMENT</code>类型的vnode节点给<code>subTree</code>对象，并使用<code>patch</code>方法进行新老节点的对比。</p>
<h3 id="processElement"><a href="#processElement" class="headerlink" title="processElement()"></a>processElement()</h3><p>按<a href="https://awesolynn.me/post/1384730263.html">结合Vue3-demo项目分析源码（二）</a>文章中提过的<code>patch</code>方法的，当节点类型为<code>ELEMENT</code>类型时，调用方法<code>processElement</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;普通的dom节点-div、span等</span><br><span class="line">if (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">    processElement(</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看文件<code>vue-next/packages/runtime-core/src/renderer.ts</code>第655行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const processElement &#x3D; (</span><br><span class="line">  n1: VNode | null,</span><br><span class="line">  n2: VNode,</span><br><span class="line">  container: RendererElement,</span><br><span class="line">  anchor: RendererNode | null,</span><br><span class="line">  parentComponent: ComponentInternalInstance | null,</span><br><span class="line">  parentSuspense: SuspenseBoundary | null,</span><br><span class="line">  isSVG: boolean,</span><br><span class="line">  optimized: boolean</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">  isSVG &#x3D; isSVG || (n2.type as string) &#x3D;&#x3D;&#x3D; &#39;svg&#39;</span><br><span class="line">  &#x2F;&#x2F;组件第一次渲染时</span><br><span class="line">  if (n1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">    mountElement(</span><br><span class="line">      n2,</span><br><span class="line">      container,</span><br><span class="line">      anchor,</span><br><span class="line">      parentComponent,</span><br><span class="line">      parentSuspense,</span><br><span class="line">      isSVG,</span><br><span class="line">      optimized</span><br><span class="line">    )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mountElement"><a href="#mountElement" class="headerlink" title="mountElement()"></a>mountElement()</h3><p>查看文件<code>vue-next/packages/runtime-core/src/renderer.ts</code>第681行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mountElement &#x3D; (</span><br><span class="line">  vnode: VNode,</span><br><span class="line">  container: RendererElement,</span><br><span class="line">  anchor: RendererNode | null,</span><br><span class="line">  parentComponent: ComponentInternalInstance | null,</span><br><span class="line">  parentSuspense: SuspenseBoundary | null,</span><br><span class="line">  isSVG: boolean,</span><br><span class="line">  optimized: boolean</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">  let el: RendererElement</span><br><span class="line">  let vnodeHook: VNodeHook | undefined | null</span><br><span class="line">  const &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    transition,</span><br><span class="line">    scopeId,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dirs</span><br><span class="line">  &#125; &#x3D; vnode</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;当vnode的el不为空</span><br><span class="line">  if (</span><br><span class="line">    !__DEV__ &amp;&amp;</span><br><span class="line">    vnode.el &amp;&amp;</span><br><span class="line">    hostCloneNode !&#x3D;&#x3D; undefined &amp;&amp;</span><br><span class="line">    patchFlag &#x3D;&#x3D;&#x3D; PatchFlags.HOISTED</span><br><span class="line">  ) &#123;</span><br><span class="line">    &#x2F;&#x2F; If a vnode has non-null el, it means it&#39;s being reused.</span><br><span class="line">    &#x2F;&#x2F; Only static vnodes can be reused, so its mounted DOM nodes should be</span><br><span class="line">    &#x2F;&#x2F; exactly the same, and we can simply do a clone here.</span><br><span class="line">    &#x2F;&#x2F; only do this in production since cloned trees cannot be HMR updated.</span><br><span class="line">    &#x2F;&#x2F; 创建 el 属性</span><br><span class="line">    el &#x3D; vnode.el &#x3D; hostCloneNode(vnode.el)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 el 属性</span><br><span class="line">    el &#x3D; vnode.el &#x3D; hostCreateElement(</span><br><span class="line">      vnode.type as string,</span><br><span class="line">      isSVG,</span><br><span class="line">      props &amp;&amp; props.is</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; mount children first, since some props may rely on child content</span><br><span class="line">    &#x2F;&#x2F; being already rendered, e.g. &#96;&lt;select value&gt;&#96;</span><br><span class="line">    &#x2F;&#x2F;如果当前元素的子元素为文本</span><br><span class="line">    if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) &#123;</span><br><span class="line">      hostSetElementText(el, vnode.children as string)</span><br><span class="line">    &#x2F;&#x2F;若子元素不是文本</span><br><span class="line">    &#125; else if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) &#123;</span><br><span class="line">      &#x2F;&#x2F;循环遍历子元素</span><br><span class="line">      mountChildren(</span><br><span class="line">        vnode.children as VNodeArrayChildren,</span><br><span class="line">        el,</span><br><span class="line">        null,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG &amp;&amp; type !&#x3D;&#x3D; &#39;foreignObject&#39;,</span><br><span class="line">        optimized || !!vnode.dynamicChildren</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;插入当前元素到container中  </span><br><span class="line">  hostInsert(el, container, anchor)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按demo，当第一次渲染<code>App.vue</code>并返回一个<code>&lt;div&gt;</code>元素节点时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js</span><br><span class="line">const app &#x3D; createApp(App,&#123;</span><br><span class="line">    msg:&quot;hello,这是组件渲染demo&quot;,</span><br><span class="line">    onVnodeBeforeMount: ()&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&quot;这是绑定在vnode节点上的beforeMount钩子函数&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.mount(&quot;#app&quot;)&#x2F;&#x2F;渲染app，将其挂载到id&#x3D;app的节点上</span><br><span class="line">&#x2F;&#x2F;App.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 组件渲染demo --&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">&#x2F;&#x2F; import &#123; getCurrentInstance, onMounted, ref,h &#125; from &#39;vue&#39;;</span><br><span class="line">&#x2F;&#x2F; import Hello from &quot;.&#x2F;Hello&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">    inheritAttrs: false,</span><br><span class="line">    name: &quot;app&quot;,</span><br><span class="line">    props: [&quot;msg&quot;, &quot;testWord&quot;,&quot;user&quot;],</span><br><span class="line">    beforeMount()&#123;</span><br><span class="line">        console.log(&quot;我是beforeMount生命周期&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>按源码，首先调用<code>hostCreateElement</code>方法创建<code>div</code>元素，由于<code>msg</code>为文本类型，故接着调用<code>hostSetElementText</code>方法将传递的<code>msg</code>字符串<code>&quot;hello,这是组件渲染demo&quot;</code>传递给<code>div</code>的<code>textContent</code>属性。最后调用方法<code>hostInsert</code>将该<code>div</code>元素插入到<code>div#app</code>根元素中。</p>
<p>按方法<code>setupRenderEffect</code>流程，调用完<code>patch</code>方法，会设置当前节点vnode的<code>el</code>属性，然后开始调用<code>mounted</code>生命周期。<code>mounted</code>执行完后整个组件的渲染过程结束。</p>
<h2 id="附录-Vue3流程图"><a href="#附录-Vue3流程图" class="headerlink" title="附录-Vue3流程图"></a>附录-Vue3流程图</h2><p><img src="https://z3.ax1x.com/2021/05/26/2pvc1f.md.jpg" alt="vue流程图"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（四）</title>
    <url>/post/2830824608.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/530050501.html">结合Vue3-demo项目分析源码（三）</a>，完成了组件的初始化，认识了各种类型的组件、浅层响应式对象即全局api。回到方法<code>setupStatefulComponent()</code>继续组件的创建。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>查看文件<code>vue-next/packages/runtime-core/src/component.ts</code>第538行</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setupStatefulComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const Component &#x3D; instance.type as ComponentOptions</span><br><span class="line">  &#x2F;&#x2F; 1. 创建当前组件实例的代理对象</span><br><span class="line">  instance.proxy &#x3D; new Proxy(instance.ctx, PublicInstanceProxyHandlers)</span><br><span class="line">  &#x2F;&#x2F; 2. 如果组件提供了 setup 方法</span><br><span class="line">     const &#123; setup &#125; &#x3D; Component</span><br><span class="line">  if (setup) &#123;</span><br><span class="line">    &#x2F;&#x2F; setup 的上下文对象</span><br><span class="line">    const setupContext &#x3D; (instance.setupContext &#x3D;</span><br><span class="line">      setup.length &gt; 1 ? createSetupContext(instance) : null)</span><br><span class="line"></span><br><span class="line">    currentInstance &#x3D; instance</span><br><span class="line">    pauseTracking()</span><br><span class="line">    &#x2F;&#x2F; 调用 setup 方法，获取返回值 setupResult</span><br><span class="line">    const setupResult &#x3D; callWithErrorHandling(</span><br><span class="line">      setup,</span><br><span class="line">      instance,</span><br><span class="line">      ErrorCodes.SETUP_FUNCTION,</span><br><span class="line">      [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext]</span><br><span class="line">    )</span><br><span class="line">    resetTracking()</span><br><span class="line">    currentInstance &#x3D; null</span><br><span class="line">        &#x2F;&#x2F; 处理 setup 方法返回值</span><br><span class="line">    if (isPromise(setupResult)) &#123;</span><br><span class="line">      if (isSSR) &#123;</span><br><span class="line">        &#x2F;&#x2F; return the promise so server-renderer can wait on it</span><br><span class="line">        return setupResult.then((resolvedResult: unknown) &#x3D;&gt; &#123;</span><br><span class="line">          handleSetupResult(instance, resolvedResult, isSSR)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else if (__FEATURE_SUSPENSE__) &#123;</span><br><span class="line">        &#x2F;&#x2F; async setup returned Promise.</span><br><span class="line">        &#x2F;&#x2F; bail here and wait for re-entry.</span><br><span class="line">        instance.asyncDep &#x3D; setupResult</span><br><span class="line">      &#125; else if (__DEV__) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &#96;setup() returned a Promise, but the version of Vue you are using &#96; +</span><br><span class="line">            &#96;does not support it yet.&#96;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回值为非 promise 对象的类型时候，调用 handleSetupResult 方法处理返回值</span><br><span class="line">      handleSetupResult(instance, setupResult, isSSR)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 完成组件的创建</span><br><span class="line">    finishComponentSetup(instance, isSSR)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><blockquote>
<p>setup方法为Vue3提供的新方法，为了定义聚合式（组合式）api组件</p>
</blockquote>
<ul>
<li>组合式api：一种低侵入式、函数式的API。无需指定一长串选项来定义组件，允许用户像编写函数一样自由组合逻辑和代码，可以更灵活的组合组件的逻辑。</li>
</ul>
<p>方法<code>setup</code>是组合式api的入口，在<code>beforeCreate</code>钩子之前调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用setup前</span><br><span class="line">created() &#123;</span><br><span class="line">    console.log(this.$props);</span><br><span class="line">    console.log(&quot; this 就是组件实例的代理对象 proxy&quot;);</span><br><span class="line">    &#x2F;&#x2F; 调用全局的方法</span><br><span class="line">    this.$showSuccuessDialog(&quot;我是全局的 showSuccuessDialog 方法&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;&#x2F;使用setup后</span><br><span class="line">setup(props,setupContext)&#123;</span><br><span class="line">    const instance &#x3D; getCurrentInstance();</span><br><span class="line">    console.log(props)</span><br><span class="line">    console.log(&quot;instance为组件实例的代理对象proxy，即先前的this&quot;)</span><br><span class="line">    console.log(instance.proxy);&#x2F;&#x2F;即先前的this</span><br><span class="line">    &#x2F;&#x2F;调用全局方法</span><br><span class="line">    instance.proxy.$showSuccessDialog(&quot;全局showSuccessDialog方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setup参数"><a href="#setup参数" class="headerlink" title="setup参数"></a>setup参数</h4><ul>
<li><p>props: 组件的属性值</p>
</li>
<li><p>setupContext: setup方法的上下文对象</p>
</li>
</ul>
<p>对象<code>setupContext</code>定义可查看文件<code>vue-next/packages/runtime-core/src/component.ts</code>第751行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createSetupContext(</span><br><span class="line">  instance: ComponentInternalInstance</span><br><span class="line">): SetupContext &#123;</span><br><span class="line">  const expose: SetupContext[&#39;expose&#39;] &#x3D; exposed &#x3D;&gt; &#123;</span><br><span class="line">    if (__DEV__ &amp;&amp; instance.exposed) &#123;</span><br><span class="line">      warn(&#96;expose() should be called only once per setup().&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">    instance.exposed &#x3D; proxyRefs(exposed)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    &#x2F;&#x2F; We use getters in dev in case libs like test-utils overwrite instance</span><br><span class="line">    &#x2F;&#x2F; properties (overwrites should not be done in prod)</span><br><span class="line">    return Object.freeze(&#123;</span><br><span class="line">      get props() &#123;</span><br><span class="line">        return instance.props</span><br><span class="line">      &#125;,</span><br><span class="line">      get attrs() &#123;</span><br><span class="line">        return new Proxy(instance.attrs, attrHandlers)</span><br><span class="line">      &#125;,</span><br><span class="line">      get slots() &#123;</span><br><span class="line">        return shallowReadonly(instance.slots)</span><br><span class="line">      &#125;,</span><br><span class="line">      get emit() &#123;</span><br><span class="line">        return (event: string, ...args: any[]) &#x3D;&gt; instance.emit(event, ...args)</span><br><span class="line">      &#125;,</span><br><span class="line">      expose</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      attrs: instance.attrs,</span><br><span class="line">      slots: instance.slots,</span><br><span class="line">      emit: instance.emit,</span><br><span class="line">      expose</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可得，<code>setupContext</code>对象有四个属性</p>
<ul>
<li><p>attrs：除<code>props</code>之外的属性值</p>
</li>
<li><p>slots：组件插槽</p>
</li>
<li><p>emit：事件触发函数</p>
</li>
<li><p>expose：设置暴露在<code>ref</code>上的对象</p>
</li>
</ul>
<h3 id="handleSetupResult"><a href="#handleSetupResult" class="headerlink" title="handleSetupResult()"></a>handleSetupResult()</h3><blockquote>
<p>处理setup方法返回的结果</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/component.ts</code>第610行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function handleSetupResult(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  setupResult: unknown,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F;若返回值为方法</span><br><span class="line">  if (isFunction(setupResult)) &#123;</span><br><span class="line">    &#x2F;&#x2F; setup returned an inline render function</span><br><span class="line">    if (__NODE_JS__ &amp;&amp; (instance.type as ComponentOptions).__ssrInlineRender) &#123;</span><br><span class="line">      &#x2F;&#x2F; when the function&#39;s name is &#96;ssrRender&#96; (compiled by SFC inline mode),</span><br><span class="line">      &#x2F;&#x2F; set it as ssrRender instead.</span><br><span class="line">      instance.ssrRender &#x3D; setupResult</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F;返回的不是ssr函数，则把返回的方法给instance的render属性</span><br><span class="line">      instance.render &#x3D; setupResult as InternalRenderFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;返回值是对象</span><br><span class="line">  &#125; else if (isObject(setupResult)) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;直接将返回的对象给instance的setupState属性</span><br><span class="line">    instance.setupState &#x3D; proxyRefs(setupResult)</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if (__DEV__ &amp;&amp; setupResult !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      &#96;setup() should return an object. Received: $&#123;</span><br><span class="line">        setupResult &#x3D;&#x3D;&#x3D; null ? &#39;null&#39; : typeof setupResult</span><br><span class="line">      &#125;&#96;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;完成组件setup</span><br><span class="line">  finishComponentSetup(instance, isSSR)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h4><ol>
<li>返回值为方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setup(props,setupContext)&#123;</span><br><span class="line">    const instance &#x3D; getCurrentInstance();</span><br><span class="line">    console.log(props)</span><br><span class="line">    console.log(&quot;instance为组件实例的代理对象proxy，即先前的this&quot;)</span><br><span class="line">    console.log(instance.proxy);&#x2F;&#x2F;即先前的this</span><br><span class="line">    &#x2F;&#x2F;调用全局方法</span><br><span class="line">    instance.proxy.$showSuccessDialog(&quot;全局showSuccessDialog方法&quot;);</span><br><span class="line">    onMounted(()&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F;获取暴露在hello组件ref对象的name属性</span><br><span class="line">        console.log(instance.proxy.$refs[&quot;refHello&quot;].name);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;setup返回值为方法</span><br><span class="line">    return () &#x3D;&gt; h(&quot;div&quot;,&quot;setup返回了一个方法&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按<code>handleSetupResult</code>方法显示，直接传递给<code>instance</code>的<code>render</code>方法，给页面不显示原来<code>template</code>内容，而直接被渲染为返回值方法的内容</p>
<p><img src="https://z3.ax1x.com/2021/05/27/2iJJpQ.png" alt="返回方法"></p>
<ol start="2">
<li>返回值为对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setup(props,setupContext)&#123;</span><br><span class="line">    const instance &#x3D; getCurrentInstance();</span><br><span class="line">    console.log(props)</span><br><span class="line">    console.log(&quot;instance为组件实例的代理对象proxy，即先前的this&quot;)</span><br><span class="line">    console.log(instance.proxy);&#x2F;&#x2F;即先前的this</span><br><span class="line">    &#x2F;&#x2F;调用全局方法</span><br><span class="line">    instance.proxy.$showSuccessDialog(&quot;全局showSuccessDialog方法&quot;);</span><br><span class="line">    onMounted(()&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F;获取暴露在hello组件ref对象的name属性</span><br><span class="line">        console.log(instance.proxy.$refs[&quot;refHello&quot;].name);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F;setup返回值为方法</span><br><span class="line">    &#x2F;&#x2F; return () &#x3D;&gt; h(&quot;div&quot;,&quot;setup返回了一个方法&quot;);</span><br><span class="line">    &#x2F;&#x2F;返回值为对象</span><br><span class="line">    return &#123;</span><br><span class="line">        setupMsg: &quot;setup返回了一个对象，我是属性setupMsg&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按<code>handleSetupResult</code>方法显示，<code>setup</code>返回的对象直接传递给<code>instance</code>的<code>setupState</code>属性，按方法<code>setupStatefulComponent</code>，当用<code>proxy</code>获取<code>instance</code>属性时，首先从<code>setupState</code>中取。</p>
<p><img src="https://z3.ax1x.com/2021/05/27/2iJxN8.png" alt="2iJxN8.png"></p>
<h3 id="finishComponentSetup"><a href="#finishComponentSetup" class="headerlink" title="finishComponentSetup()"></a>finishComponentSetup()</h3><blockquote>
<p>当方法<code>handleSetupResult</code>处理完结果，直接调用<code>finishComponentSetup</code>方法完成组件的创建。</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/component.ts</code>第665行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function finishComponentSetup(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const Component &#x3D; instance.type as ComponentOptions</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; template &#x2F; render function normalization</span><br><span class="line">  if (__NODE_JS__ &amp;&amp; isSSR) &#123;</span><br><span class="line">    &#x2F;&#x2F;若组件有render方法，则直接将其赋予组件实例</span><br><span class="line">    if (Component.render) &#123;</span><br><span class="line">      instance.render &#x3D; Component.render as InternalRenderFunction</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (!instance.render) &#123;</span><br><span class="line">    &#x2F;&#x2F; could be set from setup()</span><br><span class="line">    &#x2F;&#x2F;若组件提供了template属性，则调用compile方法将它转换为render函数</span><br><span class="line">    if (compile &amp;&amp; Component.template &amp;&amp; !Component.render) &#123;</span><br><span class="line">      if (__DEV__) &#123;</span><br><span class="line">        startMeasure(instance, &#96;compile&#96;)</span><br><span class="line">      &#125;</span><br><span class="line">      Component.render &#x3D; compile(Component.template, &#123;</span><br><span class="line">        isCustomElement: instance.appContext.config.isCustomElement,</span><br><span class="line">        delimiters: Component.delimiters</span><br><span class="line">      &#125;)</span><br><span class="line">      if (__DEV__) &#123;</span><br><span class="line">        endMeasure(instance, &#96;compile&#96;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    instance.render &#x3D; (Component.render || NOOP) as InternalRenderFunction</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;兼容Vue2组件参数</span><br><span class="line">  &#x2F;&#x2F; support for 2.x options</span><br><span class="line">  if (__FEATURE_OPTIONS_API__) &#123;</span><br><span class="line">    currentInstance &#x3D; instance</span><br><span class="line">    pauseTracking()</span><br><span class="line">    applyOptions(instance, Component)</span><br><span class="line">    resetTracking()</span><br><span class="line">    currentInstance &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个组件最后都会有一个<code>render</code>方法，前面用<code>setup</code>返回了一个方法充当了组件的<code>render</code>方法。</p>
<p>由上述方法得知，可直接使用<code>sfc</code>组件的形式通过<code>vue-loader</code>编译<code>template</code>，或给组件提供<code>template</code>属性，由<code>compile</code>方法编译成<code>render</code>方法，或直接提供一个<code>render</code>方法。</p>
<h3 id="applyOptions"><a href="#applyOptions" class="headerlink" title="applyOptions()"></a>applyOptions()</h3><blockquote>
<p>为了兼容Vue2组件调用此方法处理Vue2一些属性的兼容。</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/componentOptions.ts</code>第438行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function applyOptions(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  options: ComponentOptions,</span><br><span class="line">  deferredData: DataFn[] &#x3D; [],</span><br><span class="line">  deferredWatch: ComponentWatchOptions[] &#x3D; [],</span><br><span class="line">  deferredProvide: (Data | Function)[] &#x3D; [],</span><br><span class="line">  asMixin: boolean &#x3D; false</span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; applyOptions is called non-as-mixin once per instance</span><br><span class="line">  &#x2F;&#x2F;开始调用beforeCreate生命周期</span><br><span class="line">  if (!asMixin) &#123;</span><br><span class="line">    isInBeforeCreate &#x3D; true</span><br><span class="line">    callSyncHook(</span><br><span class="line">      &#39;beforeCreate&#39;,</span><br><span class="line">      LifecycleHooks.BEFORE_CREATE,</span><br><span class="line">      options,</span><br><span class="line">      instance,</span><br><span class="line">      globalMixins</span><br><span class="line">    )</span><br><span class="line">    isInBeforeCreate &#x3D; false</span><br><span class="line">    &#x2F;&#x2F; global mixins are applied first</span><br><span class="line">    &#x2F;&#x2F;应用全局的mixins</span><br><span class="line">    applyMixins(</span><br><span class="line">      instance,</span><br><span class="line">      globalMixins,</span><br><span class="line">      deferredData,</span><br><span class="line">      deferredWatch,</span><br><span class="line">      deferredProvide</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; extending a base component...</span><br><span class="line">  &#x2F;&#x2F;处理extends属性</span><br><span class="line">  if (extendsOptions) &#123;</span><br><span class="line">    applyOptions(</span><br><span class="line">      instance,</span><br><span class="line">      extendsOptions,</span><br><span class="line">      deferredData,</span><br><span class="line">      deferredWatch,</span><br><span class="line">      deferredProvide,</span><br><span class="line">      true</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; local mixins</span><br><span class="line">  &#x2F;&#x2F;处理本地mixins</span><br><span class="line">  if (mixins) &#123;</span><br><span class="line">    applyMixins(instance, mixins, deferredData, deferredWatch, deferredProvide)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;处理inject属性</span><br><span class="line">  if (injectOptions) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理methods属性</span><br><span class="line">  if (methods) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理data属性</span><br><span class="line">  if (!asMixin) &#123;</span><br><span class="line">    if (deferredData.length) &#123;</span><br><span class="line">      deferredData.forEach(dataFn &#x3D;&gt; resolveData(instance, dataFn, publicThis))</span><br><span class="line">    &#125;</span><br><span class="line">    if (dataOptions) &#123;</span><br><span class="line">      resolveData(instance, dataOptions, publicThis)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125; else if (dataOptions) &#123;</span><br><span class="line">    deferredData.push(dataOptions as DataFn)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理computed属性</span><br><span class="line">  if (computedOptions) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理watch属性</span><br><span class="line">  if (watchOptions) &#123;</span><br><span class="line">    deferredWatch.push(watchOptions)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;处理provide属性</span><br><span class="line">  if (provideOptions) &#123;</span><br><span class="line">    deferredProvide.push(provideOptions)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; asset options.</span><br><span class="line">  &#x2F;&#x2F; To reduce memory usage, only components with mixins or extends will have</span><br><span class="line">  &#x2F;&#x2F; resolved asset registry attached to instance.</span><br><span class="line">  &#x2F;&#x2F;处理components</span><br><span class="line">  if (asMixin) &#123;</span><br><span class="line">    if (components) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;处理directives</span><br><span class="line">    if (directives) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; lifecycle options</span><br><span class="line">  &#x2F;&#x2F;调用created生命周期</span><br><span class="line">  if (!asMixin) &#123;</span><br><span class="line">    callSyncHook(</span><br><span class="line">      &#39;created&#39;,</span><br><span class="line">      LifecycleHooks.CREATED,</span><br><span class="line">      options,</span><br><span class="line">      instance,</span><br><span class="line">      globalMixins</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;处理beforeMount、mount等生命周期</span><br><span class="line">  if (beforeMount) &#123;</span><br><span class="line">    onBeforeMount(beforeMount.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  if (mounted) &#123;</span><br><span class="line">    onMounted(mounted.bind(publicThis))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;兼容Vue2的expose属性</span><br><span class="line">  if (isArray(expose)) &#123;</span><br><span class="line">    if (!asMixin) &#123;</span><br><span class="line">      if (expose.length) &#123;</span><br><span class="line">        const exposed &#x3D; instance.exposed || (instance.exposed &#x3D; proxyRefs(&#123;&#125;))</span><br><span class="line">        expose.forEach(key &#x3D;&gt; &#123;</span><br><span class="line">          exposed[key] &#x3D; toRef(publicThis, key as any)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else if (!instance.exposed) &#123;</span><br><span class="line">        instance.exposed &#x3D; EMPTY_OBJ</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (__DEV__) &#123;</span><br><span class="line">      warn(&#96;The \&#96;expose\&#96; option is ignored when used in mixins.&#96;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法主要处理Vue2的属性的兼容处理，在处理之前调用了组件的生命周期<code>beforeCreate</code>方法，处理后调用了组件的<code>created</code>方法。</p>
<h3 id="beforeCreate生命周期"><a href="#beforeCreate生命周期" class="headerlink" title="beforeCreate生命周期"></a>beforeCreate生命周期</h3><p>由上述方法<code>applyOptions</code>可得，在<code>beforeCreated</code>方法中无法访问<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>等属性，只能访问<code>props</code>、<code>attrs</code>、<code>setupState</code>等内容。</p>
<h3 id="created生命周期"><a href="#created生命周期" class="headerlink" title="created生命周期"></a>created生命周期</h3><p>当组件完成初始化并设置完成后，组件才算创建完成，调用<code>created</code>生命周期提示“组件已经创建完成”。此时可以访问除渲染过程才有的其他所有属性。</p>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul>
<li>mixin：混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（三）</title>
    <url>/post/530050501.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/1384730263.html">结合Vue3-demo项目分析源码（二）</a>，创建完App实例，开始创建组件。接上篇<code>mountComponent()</code>方法，调用了<code>createComponentInstance</code>方法创建了一个初始化状态的组件实例<code>instance</code>，接下来就根据组件的定义调用方法<code>setupComponent()</code>设置此组件实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mountComponent: MountComponentFn &#x3D; (</span><br><span class="line">    ...</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;创建组件实例</span><br><span class="line">    const instance: ComponentInternalInstance &#x3D; (initialVNode.component &#x3D; createComponentInstance(...))</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置组件实例</span><br><span class="line">    setupComponent(instance)</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;处理setup方法</span><br><span class="line">    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense,isSVG, optimized)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="setupComponent"><a href="#setupComponent" class="headerlink" title="setupComponent()"></a>setupComponent()</h3><blockquote>
<p>创建组件实例</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/component.ts</code>第520行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function setupComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR &#x3D; false</span><br><span class="line">) &#123;</span><br><span class="line">  isInSSRComponentSetup &#x3D; isSSR</span><br><span class="line"></span><br><span class="line">  const &#123; props, children, shapeFlag &#125; &#x3D; instance.vnode</span><br><span class="line">  const isStateful &#x3D; shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT</span><br><span class="line">  &#x2F;&#x2F;初始化属性</span><br><span class="line">  initProps(instance, props, isStateful, isSSR)</span><br><span class="line">  &#x2F;&#x2F;初始化插槽</span><br><span class="line">  initSlots(instance, children)</span><br><span class="line">  &#x2F;&#x2F;处理setup函数</span><br><span class="line">  const setupResult &#x3D; isStateful</span><br><span class="line">    ? setupStatefulComponent(instance, isSSR)</span><br><span class="line">    : undefined</span><br><span class="line">  isInSSRComponentSetup &#x3D; false</span><br><span class="line">  return setupResult</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="initProps"><a href="#initProps" class="headerlink" title="initProps()"></a>initProps()</h3><blockquote>
<p>初始化属性</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/componentProps.ts</code>第129行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function initProps(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  rawProps: Data | null,</span><br><span class="line">  isStateful: number, &#x2F;&#x2F; result of bitwise flag comparison</span><br><span class="line">  isSSR &#x3D; false</span><br><span class="line">) &#123;</span><br><span class="line">  const props: Data &#x3D; &#123;&#125;</span><br><span class="line">  const attrs: Data &#x3D; &#123;&#125;</span><br><span class="line">  def(attrs, InternalObjectKey, 1)</span><br><span class="line">  &#x2F;&#x2F;设置属性</span><br><span class="line">  setFullProps(instance, rawProps, props, attrs)</span><br><span class="line">  &#x2F;&#x2F; validation</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    validateProps(props, instance)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  if (isStateful) &#123; &#x2F;&#x2F;普通组件</span><br><span class="line">    &#x2F;&#x2F; stateful</span><br><span class="line">    &#x2F;&#x2F;非服务端渲染时，默认将属性变成浅层响应式对象</span><br><span class="line">    instance.props &#x3D; isSSR ? props : shallowReactive(props)</span><br><span class="line">  &#125; else &#123;  &#x2F;&#x2F;Element类型和函数组件</span><br><span class="line">    &#x2F;&#x2F;如果组件没有提供属性，则把它全部attrs当作他的属性</span><br><span class="line">    if (!instance.type.props) &#123;</span><br><span class="line">      &#x2F;&#x2F; functional w&#x2F; optional props, props &#x3D;&#x3D;&#x3D; attrs</span><br><span class="line">      instance.props &#x3D; attrs</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; functional w&#x2F; declared props</span><br><span class="line">      instance.props &#x3D; props</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  instance.attrs &#x3D; attrs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="理解普通组件和其他组件（Element类型和函数组件）属性设置"><a href="#理解普通组件和其他组件（Element类型和函数组件）属性设置" class="headerlink" title="理解普通组件和其他组件（Element类型和函数组件）属性设置"></a>理解普通组件和其他组件（Element类型和函数组件）属性设置</h4><p>方法<code>initProps()</code>中；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isStateful) &#123; &#x2F;&#x2F;普通组件</span><br><span class="line">    &#x2F;&#x2F; stateful</span><br><span class="line">    &#x2F;&#x2F;非服务端渲染时，默认将属性变成浅层响应式对象</span><br><span class="line">    instance.props &#x3D; isSSR ? props : shallowReactive(props)</span><br><span class="line">&#125; else &#123;  &#x2F;&#x2F;Element类型和函数组件</span><br><span class="line">    &#x2F;&#x2F;如果组件没有提供属性，则把它全部attrs当作他的属性</span><br><span class="line">    if (!instance.type.props) &#123;</span><br><span class="line">      &#x2F;&#x2F; functional w&#x2F; optional props, props &#x3D;&#x3D;&#x3D; attrs</span><br><span class="line">      instance.props &#x3D; attrs</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; functional w&#x2F; declared props</span><br><span class="line">      instance.props &#x3D; props</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>普通组件</li>
</ol>
<p>原<code>app</code>即为普通组件，不是函数式也不是Element类型。故默认将它设置成浅层响应式对象<code>shallowReactive</code></p>
<blockquote>
<p>浅层响应式对象：只为某个对象的私有（第一层）属性创建浅层的响应式代理，不会对“属性的属性”做深层次、递归地响应式代理，而只是保留原样</p>
</blockquote>
<p>在<code>App.vue</code>添加一个属性<code>user</code>，设置其被点击就更改<code>user.name</code>字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &#123;&#123; msg &#125;&#125;</span><br><span class="line">        &#123;&#123; testWord &#125;&#125;</span><br><span class="line">        &lt;div @click&#x3D;&quot;user.name &#x3D; &#39;aaa&#39;&quot;&gt;我是：&#123;&#123; user &amp;&amp; user.name&#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;app&quot;,</span><br><span class="line">    props: [&quot;msg&quot;, &quot;testWord&quot;,&quot;user&quot;],</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(&quot;this对象如上&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>并且在<code>main.js</code>文件将其改为响应式对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const app &#x3D; createApp(App, &#123; </span><br><span class="line">    msg: &quot;hello&quot;, </span><br><span class="line">    msg1: &quot;vue&quot;,</span><br><span class="line">    &quot;test-word&quot;: &quot;我是用 “-” 符号传递的属性&quot;,</span><br><span class="line">    user: reactive(&#123;name: &quot;testname&quot;&#125;)</span><br><span class="line">&#125;);&#x2F;&#x2F;渲染App组件，传递msg参数</span><br></pre></td></tr></table></figure>

<p>则通过点击，该属性的name变成了<code>aaa</code>。但此对象仅其自有属性<code>name</code>为响应式，而其属性仍为非响应式，即仅有第一层</p>
<ol start="2">
<li>Element类型及函数类型</li>
</ol>
<p>并且在<code>main.js</code>文件新增函数类型组件，并为其添加属性<code>msg</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const AppWrapper &#x3D; (props) &#x3D;&gt; &#123;&#x2F;&#x2F;函数式组件</span><br><span class="line">    return h(&quot;div&quot;,[h(App,props)]);</span><br><span class="line">&#125;;</span><br><span class="line">AppWrapper.props &#x3D; &#123;&#x2F;&#x2F;给函数式组件设置属性</span><br><span class="line">    msg: String,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const app &#x3D; createApp(AppWrapper, &#123; </span><br><span class="line">    msg: &quot;hello&quot;, </span><br><span class="line">    msg1: &quot;vue&quot;,</span><br><span class="line">    &quot;test-word&quot;: &quot;我是用 “-” 符号传递的属性&quot;,</span><br><span class="line">    user: reactive(&#123;name: &quot;testname&quot;&#125;)</span><br><span class="line">&#125;);&#x2F;&#x2F;渲染App组件，传递msg参数</span><br><span class="line">app.mount(&quot;#app&quot;)&#x2F;&#x2F;渲染app，将其挂载到id&#x3D;app的节点上</span><br></pre></td></tr></table></figure>

<p>则其定义的属性attr<code>msg</code>被作为prop，其他属性则被当作<code>attrs</code>传递</p>
<p><img src="https://z3.ax1x.com/2021/05/26/29vbQK.png" alt="attrs"></p>
<h3 id="setFullProps"><a href="#setFullProps" class="headerlink" title="setFullProps()"></a>setFullProps()</h3><blockquote>
<p>设置属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setFullProps(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  rawProps: Data | null,</span><br><span class="line">  props: Data,</span><br><span class="line">  attrs: Data</span><br><span class="line">) &#123;</span><br><span class="line">  const [options, needCastKeys] &#x3D; instance.propsOptions</span><br><span class="line">  if (rawProps) &#123;</span><br><span class="line">    for (const key in rawProps) &#123;</span><br><span class="line">      const value &#x3D; rawProps[key]</span><br><span class="line">      &#x2F;&#x2F; key, ref are reserved and never passed down</span><br><span class="line">      if (isReservedProp(key)) &#123;</span><br><span class="line">        continue</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; prop option names are camelized during normalization, so to support kebab -&gt; camel conversion here we need to camelize the key.</span><br><span class="line">      let camelKey</span><br><span class="line">      &#x2F;&#x2F;如果有给组件传递的参数，并在当前组件中定义了该参数。就把传递的参数传给当前组件</span><br><span class="line">      if (options &amp;&amp; hasOwn(options, (camelKey &#x3D; camelize(key)))) &#123;</span><br><span class="line">        props[camelKey] &#x3D; value</span><br><span class="line">      &#125; else if (!isEmitListener(instance.emitsOptions, key)) &#123;</span><br><span class="line">        &#x2F;&#x2F;否则把传递的属性传给attrs</span><br><span class="line">        attrs[key] &#x3D; value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;传递的属性中是否含有 - 符号定义的属性，有的话就获取该属性</span><br><span class="line">  if (needCastKeys) &#123;</span><br><span class="line">    const rawCurrentProps &#x3D; toRaw(props)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; needCastKeys.length; i++) &#123;</span><br><span class="line">      const key &#x3D; needCastKeys[i]</span><br><span class="line">      props[key] &#x3D; resolvePropValue(</span><br><span class="line">        options!,</span><br><span class="line">        rawCurrentProps,</span><br><span class="line">        key,</span><br><span class="line">        rawCurrentProps[key],</span><br><span class="line">        instance</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h4><ol>
<li>理解属性传递部分</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (options &amp;&amp; hasOwn(options, (camelKey &#x3D; camelize(key)))) &#123;</span><br><span class="line">    props[camelKey] &#x3D; value</span><br><span class="line">&#125; else if (!isEmitListener(instance.emitsOptions, key)) &#123;</span><br><span class="line">    &#x2F;&#x2F;否则把传递的属性传给attrs</span><br><span class="line">    attrs[key] &#x3D; value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即若给<code>app</code>添加两个属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const app &#x3D; createApp(App, &#123; msg: &quot;hello&quot;, msg1: &quot;vue&quot; &#125;);</span><br></pre></td></tr></table></figure>

<p>此时，<code>App.vue</code>中<code>&lt;template&gt;</code>没有定义根元素，仅为<code>&lt;template&gt;&lt;/template&gt;</code>。故Vue自动帮它加了一个<code>Fragment</code>片段，故无法显示</p>
<p>当给<code>App.vue</code>加上根节点<code>&lt;div&gt;&lt;/div&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;app&quot;,</span><br><span class="line">    props: [&quot;msg&quot;],</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(&quot;this对象如上&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>由于在<code>&lt;script&gt;</code>仅给组件传递了参数<code>msg</code>，故<code>msg1</code>被当作属性给<code>attrs</code></p>
<p><img src="https://z3.ax1x.com/2021/05/26/29qxmj.png" alt="29qxmj.png"></p>
<ol start="2">
<li>理解“-”符号定义的属性部分</li>
</ol>
<p>含有“-”符号定义的属性即在<code>App.vue</code>中定义的类似于<code>testWord</code>含有大写的驼峰命名法定义的属性。在被挂载到app上时，会被命名为<code>test-word</code>。故需要对类似的属性进行处理</p>
<h3 id="initSlots"><a href="#initSlots" class="headerlink" title="initSlots()"></a>initSlots()</h3><blockquote>
<p>初始化插槽</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/componentSlots.ts</code>第109行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const initSlots &#x3D; (</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  children: VNodeNormalizedChildren</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;创建节点时传递的children为对象时</span><br><span class="line">  if (instance.vnode.shapeFlag &amp; ShapeFlags.SLOTS_CHILDREN) &#123;</span><br><span class="line">    const type &#x3D; (children as RawSlots)._</span><br><span class="line">    if (type) &#123;</span><br><span class="line">      instance.slots &#x3D; children as InternalSlots</span><br><span class="line">      &#x2F;&#x2F; make compiler marker non-enumerable</span><br><span class="line">      def(children as InternalSlots, &#39;_&#39;, type)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      normalizeObjectSlots(children as RawSlots, (instance.slots &#x3D; &#123;&#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;&#x2F;&#x2F;当传递的children为数组时，直接在slots里暴露一下default方法</span><br><span class="line">    instance.slots &#x3D; &#123;&#125;</span><br><span class="line">    if (children) &#123;</span><br><span class="line">      normalizeVNodeSlots(instance, children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  def(instance.slots, InternalObjectKey, 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有状态组件vs无状态组件"><a href="#有状态组件vs无状态组件" class="headerlink" title="有状态组件vs无状态组件"></a>有状态组件vs无状态组件</h4><ul>
<li><p>有状态组件：需要维护内部状态的组件。通常被称为容器container，通常会包含若干无状态组件。如<code>App.vue</code>此类<code>SFC</code>组件，可以利用<code>data</code>或<code>setup</code>方法定义自己的状态</p>
</li>
<li><p>无状态组件：不需要维护状态的组件，自己没有数据，要么是纯渲染的html内容，要么数据都是来自上层结构。如上面的函数组件<code>AppWrapper</code> </p>
</li>
</ul>
<p>查看文件<code>vue-next/packages/shared/src/shapeFlags.ts</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const enum ShapeFlags &#123;</span><br><span class="line">  &#x2F;&#x2F;无状态组件</span><br><span class="line">  ELEMENT &#x3D; 1,  &#x2F;&#x2F;dom元素类型，如div、span等普通dom标签</span><br><span class="line">  FUNCTIONAL_COMPONENT &#x3D; 1 &lt;&lt; 1,  &#x2F;&#x2F;函数式类型，如AppWrapper</span><br><span class="line">  &#x2F;&#x2F;有状态组件 </span><br><span class="line">  STATEFUL_COMPONENT &#x3D; 1 &lt;&lt; 2,  &#x2F;&#x2F;静态类型，如svg标签</span><br><span class="line">  TEXT_CHILDREN &#x3D; 1 &lt;&lt; 3, &#x2F;&#x2F;文本节点类型</span><br><span class="line">  ARRAY_CHILDREN &#x3D; 1 &lt;&lt; 4,  &#x2F;&#x2F;创建节点时传递的子节点是数组时</span><br><span class="line">  SLOTS_CHILDREN &#x3D; 1 &lt;&lt; 5,  &#x2F;&#x2F;创建节点时传递的子节点是对象时</span><br><span class="line">  TELEPORT &#x3D; 1 &lt;&lt; 6,  &#x2F;&#x2F;TELEPORT组件</span><br><span class="line">  SUSPENSE &#x3D; 1 &lt;&lt; 7,  &#x2F;&#x2F;SUSPENSE组件</span><br><span class="line">  COMPONENT_SHOULD_KEEP_ALIVE &#x3D; 1 &lt;&lt; 8, &#x2F;&#x2F;keep-alive组件的子组件</span><br><span class="line">  COMPONENT_KEPT_ALIVE &#x3D; 1 &lt;&lt; 9,  &#x2F;&#x2F;keep-alive组件</span><br><span class="line">  COMPONENT &#x3D; ShapeFlags.STATEFUL_COMPONENT | ShapeFlags.FUNCTIONAL_COMPONENT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setupStatefulComponent"><a href="#setupStatefulComponent" class="headerlink" title="setupStatefulComponent()"></a>setupStatefulComponent()</h3><blockquote>
<p>设置有状态组件</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/component.ts</code>第538行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function setupStatefulComponent(</span><br><span class="line">  instance: ComponentInternalInstance,</span><br><span class="line">  isSSR: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const Component &#x3D; instance.type as ComponentOptions</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 0. create render proxy property access cache</span><br><span class="line">  instance.accessCache &#x3D; Object.create(null)</span><br><span class="line">  &#x2F;&#x2F; 1. create public instance &#x2F; render proxy also mark it raw so it&#39;s never observed</span><br><span class="line">  &#x2F;&#x2F;创建当前组件实例的代理对象，即demo项目打印出的this对象</span><br><span class="line">  instance.proxy &#x3D; new Proxy(instance.ctx, PublicInstanceProxyHandlers)</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 2. call setup()</span><br><span class="line">  const &#123; setup &#125; &#x3D; Component</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当通过<code>Proxy</code>访问<code>instance</code>属性时，需要经过方法<code>PublicInstanceProxyHandlers</code></p>
<h3 id="PublicInstanceProxyHandlers"><a href="#PublicInstanceProxyHandlers" class="headerlink" title="PublicInstanceProxyHandlers"></a>PublicInstanceProxyHandlers</h3><p>查看文件<code>vue-next/packages/runtime-core/src/componentPublicInstance.ts</code>第243行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const PublicInstanceProxyHandlers: ProxyHandler&lt;any&gt; &#x3D; &#123;</span><br><span class="line">  get(&#123; _: instance &#125;: ComponentRenderContext, key: string) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;当使用组件用this访问不带’$‘的属性时</span><br><span class="line">    if (key[0] !&#x3D;&#x3D; &#39;$&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F;查看缓存中是否存在</span><br><span class="line">      const n &#x3D; accessCache![key]</span><br><span class="line">      &#x2F;&#x2F;缓存中存在，按顺序获取</span><br><span class="line">      if (n !&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        switch (n) &#123;</span><br><span class="line">          &#x2F;&#x2F;1.从setupState中获取</span><br><span class="line">          case AccessTypes.SETUP:</span><br><span class="line">            return setupState[key]</span><br><span class="line">          &#x2F;&#x2F;2.从data中获取</span><br><span class="line">          case AccessTypes.DATA:</span><br><span class="line">            return data[key]</span><br><span class="line">          &#x2F;&#x2F;3.从组件上下文对象中获取</span><br><span class="line">          case AccessTypes.CONTEXT:</span><br><span class="line">            return ctx[key]</span><br><span class="line">          &#x2F;&#x2F;4.从组件属性里获取</span><br><span class="line">          case AccessTypes.PROPS:</span><br><span class="line">            return props![key]</span><br><span class="line">          &#x2F;&#x2F; default: just fallthrough</span><br><span class="line">        &#125;</span><br><span class="line">      &#x2F;&#x2F;缓存中不存在，则按以下顺序获取</span><br><span class="line">      &#125; else if (setupState !&#x3D;&#x3D; EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) &#123; </span><br><span class="line">        &#x2F;&#x2F;1.从setupState中获取，并存入缓存</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.SETUP</span><br><span class="line">        return setupState[key]</span><br><span class="line">      &#125; else if (data !&#x3D;&#x3D; EMPTY_OBJ &amp;&amp; hasOwn(data, key)) &#123;</span><br><span class="line">        &#x2F;&#x2F;2.从data中获取，并存入缓存</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.DATA</span><br><span class="line">        return data[key]</span><br><span class="line">      &#125; else if (</span><br><span class="line">        &#x2F;&#x2F; only cache other properties when instance has declared (thus stable)</span><br><span class="line">        &#x2F;&#x2F; props</span><br><span class="line">        (normalizedProps &#x3D; instance.propsOptions[0]) &amp;&amp;</span><br><span class="line">        hasOwn(normalizedProps, key)</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F;3.从组件属性props中获取，并存入缓存</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.PROPS</span><br><span class="line">        return props![key]</span><br><span class="line">      &#125; else if (ctx !&#x3D;&#x3D; EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">        &#x2F;&#x2F;4.最后从组件上下文对象中获取，并存入缓存</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.CONTEXT</span><br><span class="line">        return ctx[key]</span><br><span class="line">      &#125; else if (!__FEATURE_OPTIONS_API__ || !isInBeforeCreate) &#123;</span><br><span class="line">        accessCache![key] &#x3D; AccessTypes.OTHER</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    const publicGetter &#x3D; publicPropertiesMap[key]</span><br><span class="line">    let cssModule, globalProperties</span><br><span class="line">    &#x2F;&#x2F; public $xxx properties</span><br><span class="line">    &#x2F;&#x2F;获取带‘$‘的公共属性，如$el、$data、$props等</span><br><span class="line">    if (publicGetter) &#123;</span><br><span class="line">      if (key &#x3D;&#x3D;&#x3D; &#39;$attrs&#39;) &#123;</span><br><span class="line">        track(instance, TrackOpTypes.GET, key)</span><br><span class="line">        __DEV__ &amp;&amp; markAttrsAccessed()</span><br><span class="line">      &#125;</span><br><span class="line">      return publicGetter(instance)</span><br><span class="line">    &#125; else if (</span><br><span class="line">      &#x2F;&#x2F; css module (injected by vue-loader)</span><br><span class="line">      (cssModule &#x3D; type.__cssModules) &amp;&amp;</span><br><span class="line">      (cssModule &#x3D; cssModule[key])</span><br><span class="line">    ) &#123;</span><br><span class="line">      return cssModule</span><br><span class="line">    &#125; else if (ctx !&#x3D;&#x3D; EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) &#123;</span><br><span class="line">      &#x2F;&#x2F; user may set custom properties to &#96;this&#96; that start with &#96;$&#96;</span><br><span class="line">      accessCache![key] &#x3D; AccessTypes.CONTEXT</span><br><span class="line">      return ctx[key]</span><br><span class="line">    &#125; else if (</span><br><span class="line">      &#x2F;&#x2F;前面方法都找不到则到app全局对象中找</span><br><span class="line">      &#x2F;&#x2F; global properties</span><br><span class="line">      ((globalProperties &#x3D; appContext.config.globalProperties),</span><br><span class="line">      hasOwn(globalProperties, key))</span><br><span class="line">    ) &#123;</span><br><span class="line">      return globalProperties[key]</span><br><span class="line">    &#125; else if (</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">      currentRenderingInstance &amp;&amp;</span><br><span class="line">      (!isString(key) ||</span><br><span class="line">        &#x2F;&#x2F; #1091 avoid internal isRef&#x2F;isVNode checks on component instance leading</span><br><span class="line">        &#x2F;&#x2F; to infinite warning loop</span><br><span class="line">        key.indexOf(&#39;__v&#39;) !&#x3D;&#x3D; 0)</span><br><span class="line">    ) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，Vue3新增的内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else if (</span><br><span class="line">    &#x2F;&#x2F;前面方法都找不到则到app全局对象中找</span><br><span class="line">    &#x2F;&#x2F; global properties</span><br><span class="line">    ((globalProperties &#x3D; appContext.config.globalProperties), hasOwn(globalProperties, key))</span><br><span class="line">    ) &#123;</span><br><span class="line">      return globalProperties[key]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Vue3不再以一个Vue对象的形式创建组件，而使用组合式API，故不能在Vue原形上绑定一些全局的属性，但Vue3在app对象上暴露了<code>globalProperties</code>供使用。</p>
<p>在定义全局<code>api</code>时，建议使用<code>$</code>来定义，如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.js文件添加一个全局的 $showSuccuessDialog 方法</span><br><span class="line">app.config.globalProperties.$showSuccuessDialog &#x3D; function (msg) &#123;</span><br><span class="line">  alert(msg);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; App.vue文件中调用全局的方法</span><br><span class="line">this.$showSuccuessDialog(&quot;我是全局的 showSuccuessDialog 方法&quot;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由方法<code>PublicInstanceProxyHandlers</code>得知，当获取<code>$</code>开头的属性时，可以绕过<code>setState</code>、<code>data</code>、<code>prop</code>等前置条件，可以更快的取到全局属性，从而提升性能效率。</p>
</blockquote>
<h2 id="附录-Vue3流程图"><a href="#附录-Vue3流程图" class="headerlink" title="附录-Vue3流程图"></a>附录-Vue3流程图</h2><p><img src="https://z3.ax1x.com/2021/05/26/2pvc1f.md.jpg" alt="vue流程图"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（二）</title>
    <url>/post/1384730263.html</url>
    <content><![CDATA[<p>接<a href="https://awesolynn.me/post/1654628943.html">结合Vue3-demo项目分析源码（一）</a>，创建完App组件，开始使用<code>mount</code>方法渲染app</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="mount"><a href="#mount" class="headerlink" title="mount()"></a>mount()</h3><blockquote>
<p>渲染app</p>
</blockquote>
<p>查看源码项目<code>vue-next/packages/runtime-dom/src/index.ts</code>中<code>createApp()</code>，其中<code>app.mount</code>被重写了。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.mount &#x3D; (containerOrSelector: Element | string): any &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;根据传递的选择器获取dom元素</span><br><span class="line">    const container &#x3D; normalizeContainer(containerOrSelector)</span><br><span class="line">    if (!container) return</span><br><span class="line">    const component &#x3D; app._component    &#x2F;&#x2F;若不存在，使用app根组件</span><br><span class="line">    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">      component.template &#x3D; container.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; clear content before mounting</span><br><span class="line">    container.innerHTML &#x3D; &#39;&#39;</span><br><span class="line">    &#x2F;&#x2F;调用app对象原始mount方法，传递给当前根节点元素</span><br><span class="line">    const proxy &#x3D; mount(container)</span><br><span class="line">    container.removeAttribute(&#39;v-cloak&#39;)</span><br><span class="line">    container.setAttribute(&#39;data-v-app&#39;, &#39;&#39;)</span><br><span class="line">    return proxy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，重写的<code>mount()</code>根据传递的选择器找到dom元素，调用原始<code>mount</code>方法，传递给当前根节点元素。</p>
<p>查看文件<code>vue-next/packages/runtime-core/src/apiCreateApp.ts</code>第227行原始<code>mount</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mount(rootContainer: HostElement, isHydrate?: boolean): any &#123;</span><br><span class="line">if (!isMounted) &#123;&#x2F;&#x2F;第一次渲染</span><br><span class="line">    &#x2F;&#x2F;创建Vnode节点</span><br><span class="line">    const vnode &#x3D; createVNode(</span><br><span class="line">        rootComponent as ConcreteComponent,</span><br><span class="line">        rootProps</span><br><span class="line">    )</span><br><span class="line">    &#x2F;&#x2F; store app context on the root VNode.</span><br><span class="line">    &#x2F;&#x2F; this will be set on the root instance on initial mount.</span><br><span class="line">    vnode.appContext &#x3D; context&#x2F;&#x2F;节点上下文为根节点上下文</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; HMR root reload</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">        context.reload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            render(cloneVNode(vnode), rootContainer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;支持自定义渲染</span><br><span class="line">    if (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">        &#x2F;&#x2F;自定义渲染</span><br><span class="line">        hydrate(vnode as VNode&lt;Node, Element&gt;, rootContainer as any)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;默认渲染</span><br><span class="line">        render(vnode, rootContainer)</span><br><span class="line">    &#125;</span><br><span class="line">    isMounted &#x3D; true</span><br><span class="line">    app._container &#x3D; rootContainer</span><br><span class="line">    &#x2F;&#x2F; for devtools and telemetry</span><br><span class="line">    ;(rootContainer as any).__vue_app__ &#x3D; app</span><br><span class="line"></span><br><span class="line">    if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">        devtoolsInitApp(app, version)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return vnode.component!.proxy</span><br><span class="line">&#125; else if (__DEV__) &#123;</span><br><span class="line">    &#x2F;&#x2F;多次调用mount方法报错</span><br><span class="line">    warn(</span><br><span class="line">    &#96;App has already been mounted.\n&#96; +</span><br><span class="line">        &#96;If you want to remount the same app, move your app creation logic &#96; +</span><br><span class="line">        &#96;into a factory function and create fresh app instances for each &#96; +</span><br><span class="line">        &#96;mount - e.g. \&#96;const createMyApp &#x3D; () &#x3D;&gt; createApp(App)\&#96;&#96;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原始<code>mount</code>方法主要创建一个<code>vnode</code>节点，调用<code>render()</code>方法渲染。</p>
<h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><blockquote>
<p>渲染节点</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/renderer.ts</code>第2182行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const render: RootRenderFunction &#x3D; (vnode, container) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;若当前节点为null，则卸载节点</span><br><span class="line">    if (vnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">        if (container._vnode) &#123;</span><br><span class="line">            unmount(container._vnode, null, null, true)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F;使用patch方法对比新老节点</span><br><span class="line">        patch(container._vnode || null, vnode, container)</span><br><span class="line">    &#125;</span><br><span class="line">    flushPostFlushCbs()</span><br><span class="line">    container._vnode &#x3D; vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="patch"><a href="#patch" class="headerlink" title="patch()"></a>patch()</h3><blockquote>
<p>对比新老节点，根据节点类型的不同做不同处理</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/renderer.ts</code>第448行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const patch: PatchFn &#x3D; (</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    anchor &#x3D; null,</span><br><span class="line">    parentComponent &#x3D; null,</span><br><span class="line">    parentSuspense &#x3D; null,</span><br><span class="line">    isSVG &#x3D; false,</span><br><span class="line">    optimized &#x3D; false</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; patching &amp; not same type, unmount old tree</span><br><span class="line">    &#x2F;&#x2F;对比新老节点，若类型一样，则卸载老节点</span><br><span class="line">    if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) &#123;</span><br><span class="line">        anchor &#x3D; getNextHostNode(n1)</span><br><span class="line">        &#x2F;&#x2F;卸载老节点</span><br><span class="line">        unmount(n1, parentComponent, parentSuspense, true)</span><br><span class="line">        n1 &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (n2.patchFlag &#x3D;&#x3D;&#x3D; PatchFlags.BAIL) &#123;</span><br><span class="line">        optimized &#x3D; false</span><br><span class="line">        n2.dynamicChildren &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const &#123; type, ref, shapeFlag &#125; &#x3D; n2</span><br><span class="line">    &#x2F;&#x2F;根据当前节点类型不同做不同处理</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case Text:  &#x2F;&#x2F;文本节点TextNode</span><br><span class="line">            processText(n1, n2, container, anchor)</span><br><span class="line">            break</span><br><span class="line">        case Comment:   &#x2F;&#x2F; 文档注释节点</span><br><span class="line">            processCommentNode(n1, n2, container, anchor)</span><br><span class="line">            break</span><br><span class="line">        case Static:    &#x2F;&#x2F;svg等静态节点</span><br><span class="line">            if (n1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">                mountStaticNode(n2, container, anchor, isSVG)</span><br><span class="line">            &#125; else if (__DEV__) &#123;</span><br><span class="line">                patchStaticNode(n1, n2, container, isSVG)</span><br><span class="line">            &#125;</span><br><span class="line">            break</span><br><span class="line">      case Fragment:    &#x2F;&#x2F;片段节点</span><br><span class="line">        processFragment(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized</span><br><span class="line">        )</span><br><span class="line">        break</span><br><span class="line">      default: </span><br><span class="line">        &#x2F;&#x2F;普通的dom节点-div、span等</span><br><span class="line">        if (shapeFlag &amp; ShapeFlags.ELEMENT) &#123;</span><br><span class="line">            processElement(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized</span><br><span class="line">            )</span><br><span class="line">        &#125; else if (shapeFlag &amp; ShapeFlags.COMPONENT) &#123;&#x2F;&#x2F;Vue组件</span><br><span class="line">            processComponent(</span><br><span class="line">            n1,</span><br><span class="line">            n2,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized</span><br><span class="line">            )</span><br><span class="line">        &#125; else if (shapeFlag &amp; ShapeFlags.TELEPORT) &#123;&#x2F;&#x2F;TELEPORT类型</span><br><span class="line">            ;(type as typeof TeleportImpl).process(</span><br><span class="line">            n1 as TeleportVNode,</span><br><span class="line">            n2 as TeleportVNode,</span><br><span class="line">            container,</span><br><span class="line">            anchor,</span><br><span class="line">            parentComponent,</span><br><span class="line">            parentSuspense,</span><br><span class="line">            isSVG,</span><br><span class="line">            optimized,</span><br><span class="line">            internals</span><br><span class="line">            )</span><br><span class="line">        &#125; else if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (__DEV__) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; set ref</span><br><span class="line">    if (ref !&#x3D; null &amp;&amp; parentComponent) &#123;</span><br><span class="line">        setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据<code>main.js</code>中代码得知，<code>app</code>为<code>vue</code>组件节点，故下一步到<code>processComponent()</code>方法</p>
<h3 id="processComponent"><a href="#processComponent" class="headerlink" title="processComponent()"></a>processComponent()</h3><p>查看文件<code>vue-next/packages/runtime-core/src/renderer.ts</code>第1185行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const processComponent &#x3D; (</span><br><span class="line">    n1: VNode | null,</span><br><span class="line">    n2: VNode,</span><br><span class="line">    container: RendererElement,</span><br><span class="line">    anchor: RendererNode | null,</span><br><span class="line">    parentComponent: ComponentInternalInstance | null,</span><br><span class="line">    parentSuspense: SuspenseBoundary | null,</span><br><span class="line">    isSVG: boolean,</span><br><span class="line">    optimized: boolean</span><br><span class="line">  ) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;老节点是否为null(第一次进来的老节点一定是null)</span><br><span class="line">    if (n1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 是否是COMPONENT_KEPT_ALIVE类型的节点</span><br><span class="line">        if (n2.shapeFlag &amp; ShapeFlags.COMPONENT_KEPT_ALIVE) &#123;</span><br><span class="line">            ;(parentComponent!.ctx as KeepAliveContext).activate(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                isSVG,</span><br><span class="line">                optimized</span><br><span class="line">            )</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F;普通组件</span><br><span class="line">            mountComponent(</span><br><span class="line">                n2,</span><br><span class="line">                container,</span><br><span class="line">                anchor,</span><br><span class="line">                parentComponent,</span><br><span class="line">                parentSuspense,</span><br><span class="line">                isSVG,</span><br><span class="line">                optimized</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;&#x2F;&#x2F;若老节点不为空，更新组件</span><br><span class="line">        updateComponent(n1, n2, optimized)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>app为首次渲染为null且为普通组件，故调用<code>mountomponent()</code>方法</p>
<h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent()"></a>mountComponent()</h3><p>查看文件<code>vue-next/packages/runtime-core/src/renderer.ts</code>第1220行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mountComponent: MountComponentFn &#x3D; (</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;创建组件实例</span><br><span class="line">    const instance: ComponentInternalInstance &#x3D; (initialVNode.component &#x3D; createComponentInstance(</span><br><span class="line">        initialVNode,</span><br><span class="line">        parentComponent,</span><br><span class="line">        parentSuspense</span><br><span class="line">    ))</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;设置组件实例</span><br><span class="line">    setupComponent(instance)</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;处理setup方法</span><br><span class="line">    setupRenderEffect(</span><br><span class="line">        instance,</span><br><span class="line">        initialVNode,</span><br><span class="line">        container,</span><br><span class="line">        anchor,</span><br><span class="line">        parentSuspense,</span><br><span class="line">        isSVG,</span><br><span class="line">        optimized</span><br><span class="line">    )</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createComponentInstance"><a href="#createComponentInstance" class="headerlink" title="createComponentInstance()"></a>createComponentInstance()</h4><blockquote>
<p>创建组件实例</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/component.ts</code>第405行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createComponentInstance(</span><br><span class="line">  vnode: VNode,</span><br><span class="line">  parent: ComponentInternalInstance | null,</span><br><span class="line">  suspense: SuspenseBoundary | null</span><br><span class="line">) &#123;</span><br><span class="line">  const type &#x3D; vnode.type as ConcreteComponent</span><br><span class="line">  &#x2F;&#x2F; inherit parent app context - or - if root, adopt from root vnode</span><br><span class="line">  const appContext &#x3D;</span><br><span class="line">    (parent ? parent.appContext : vnode.appContext) || emptyAppContext</span><br><span class="line"></span><br><span class="line">  const instance: ComponentInternalInstance &#x3D; &#123;</span><br><span class="line">    uid: uid++, &#x2F;&#x2F;唯一标识</span><br><span class="line">    vnode,  &#x2F;&#x2F;当前组件的vnode节点</span><br><span class="line">    type,   &#x2F;&#x2F;组件类型</span><br><span class="line">    parent, &#x2F;&#x2F;父组件</span><br><span class="line">    appContext, &#x2F;&#x2F;app上下文</span><br><span class="line">    root: null!, &#x2F;&#x2F; to be immediately set</span><br><span class="line">    next: null,</span><br><span class="line">    subTree: null!, &#x2F;&#x2F; will be set synchronously right after creation</span><br><span class="line">    update: null!, &#x2F;&#x2F; will be set synchronously right after creation</span><br><span class="line">    render: null,</span><br><span class="line">    proxy: null,    &#x2F;&#x2F;组件实例代理对象（组件里用this访问的即为此对象</span><br><span class="line">    exposed: null,</span><br><span class="line">    withProxy: null,</span><br><span class="line">    effects: null,</span><br><span class="line">    provides: parent ? parent.provides : Object.create(appContext.provides),</span><br><span class="line">    accessCache: null!,</span><br><span class="line">    renderCache: [],</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; local resovled assets</span><br><span class="line">    components: null,</span><br><span class="line">    directives: null,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; resolved props and emits options</span><br><span class="line">    propsOptions: normalizePropsOptions(type, appContext),</span><br><span class="line">    emitsOptions: normalizeEmitsOptions(type, appContext),</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; emit</span><br><span class="line">    emit: null as any, &#x2F;&#x2F; to be set immediately</span><br><span class="line">    emitted: null,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; state</span><br><span class="line">    ctx: EMPTY_OBJ,</span><br><span class="line">    data: EMPTY_OBJ,</span><br><span class="line">    props: EMPTY_OBJ,</span><br><span class="line">    attrs: EMPTY_OBJ,</span><br><span class="line">    slots: EMPTY_OBJ,</span><br><span class="line">    refs: EMPTY_OBJ,</span><br><span class="line">    setupState: EMPTY_OBJ,</span><br><span class="line">    setupContext: null,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; suspense related</span><br><span class="line">    suspense,</span><br><span class="line">    suspenseId: suspense ? suspense.pendingId : 0,</span><br><span class="line">    asyncDep: null,</span><br><span class="line">    asyncResolved: false,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; lifecycle hooks</span><br><span class="line">    &#x2F;&#x2F; not using enums here because it results in computed properties</span><br><span class="line">    isMounted: false,</span><br><span class="line">    isUnmounted: false,</span><br><span class="line">    isDeactivated: false,</span><br><span class="line">    bc: null,</span><br><span class="line">    c: null,</span><br><span class="line">    bm: null,</span><br><span class="line">    m: null,</span><br><span class="line">    bu: null,</span><br><span class="line">    u: null,</span><br><span class="line">    um: null,</span><br><span class="line">    bum: null,</span><br><span class="line">    da: null,</span><br><span class="line">    a: null,</span><br><span class="line">    rtg: null,</span><br><span class="line">    rtc: null,</span><br><span class="line">    ec: null</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  instance.root &#x3D; parent ? parent.root : instance</span><br><span class="line">  instance.emit &#x3D; emit.bind(null, instance)</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F;返回实例</span><br><span class="line">  return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组件实例中<code>proxy</code>即为在组件里用<code>this</code>访问的对象。Vue只暴露组件实例的一部分属性供访问，这些属性只能通过代理对象<code>proxy</code>获取。</p>
<p>在<code>App.vue</code>中加入代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;app&quot;,</span><br><span class="line">    props: [&quot;msg&quot;],</span><br><span class="line">    created()&#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">        console.log(&quot;this对象如上&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>则在浏览其中可看到：</p>
<p><img src="https://z3.ax1x.com/2021/05/26/29INWQ.png" alt="this对象"></p>
<h2 id="附录-Vue3流程图"><a href="#附录-Vue3流程图" class="headerlink" title="附录-Vue3流程图"></a>附录-Vue3流程图</h2><p><img src="https://z3.ax1x.com/2021/05/26/2pvc1f.md.jpg" alt="vue流程图"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>结合Vue3-demo项目分析源码（一）</title>
    <url>/post/1654628943.html</url>
    <content><![CDATA[<p>Vue3-demo项目即为先前<a href="https://awesolynn.me/post/876416960.html">从0搭建简易vue3项目</a>中搭建的demo</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>入口文件<code>main.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;;&#x2F;&#x2F;引入Vue3源码</span><br><span class="line">import App from &quot;.&#x2F;App&quot;;&#x2F;&#x2F;引入App.vue组件</span><br><span class="line">const app &#x3D; createApp(App,&#123;msg:&quot;Hello Vue&quot;&#125;)&#x2F;&#x2F;创建App组件，传递msg参数</span><br><span class="line"></span><br><span class="line">app.mount(&quot;#app&quot;)&#x2F;&#x2F;渲染app，将其挂载到id&#x3D;app的节点上</span><br></pre></td></tr></table></figure>

<p>通过在浏览器上不同位置打断点，可以按步骤流程分析Vue源码的实现流程。</p>
<a id="more"></a>

<p><img src="https://z3.ax1x.com/2021/05/26/29Iz0P.png" alt="断点"></p>
<h3 id="创建app应用实例"><a href="#创建app应用实例" class="headerlink" title="创建app应用实例"></a>创建app应用实例</h3><h4 id="createApp"><a href="#createApp" class="headerlink" title="createApp()"></a>createApp()</h4><blockquote>
<p>创建app对象，即应用实例</p>
</blockquote>
<p>查看源码项目<code>vue-next/packages/runtime-dom/src/index.ts</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const createApp &#x3D; ((...args) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;创建app对象</span><br><span class="line">  const app &#x3D; ensureRenderer().createApp(...args)</span><br><span class="line"></span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    injectNativeTagCheck(app)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const &#123; mount &#125; &#x3D; app</span><br><span class="line">  &#x2F;&#x2F;重写app的mount方法</span><br><span class="line">  app.mount &#x3D; (containerOrSelector: Element | string): any &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;根据传递的选择器获取dom元素</span><br><span class="line">    const container &#x3D; normalizeContainer(containerOrSelector)</span><br><span class="line">    if (!container) return</span><br><span class="line">    const component &#x3D; app._component</span><br><span class="line">    if (!isFunction(component) &amp;&amp; !component.render &amp;&amp; !component.template) &#123;</span><br><span class="line">      component.template &#x3D; container.innerHTML</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; clear content before mounting</span><br><span class="line">    container.innerHTML &#x3D; &#39;&#39;</span><br><span class="line">    const proxy &#x3D; mount(container)</span><br><span class="line">    container.removeAttribute(&#39;v-cloak&#39;)</span><br><span class="line">    container.setAttribute(&#39;data-v-app&#39;, &#39;&#39;)</span><br><span class="line">    return proxy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return app</span><br><span class="line">&#125;) as CreateAppFunction&lt;Element&gt;</span><br></pre></td></tr></table></figure>

<p>其中，创建app的代码为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建app对象</span><br><span class="line">const app &#x3D; ensureRenderer().createApp(...args)</span><br></pre></td></tr></table></figure>

<p>查看<code>ensureRenderer()</code>方法定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ensureRenderer() &#123;</span><br><span class="line">  return renderer || (renderer &#x3D; createRenderer&lt;Node, Element&gt;(rendererOptions))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>ensureRenderer()</code>通过使用<code>createRenderer&lt;Node, Element&gt;(rendererOptions)</code>方法创建app。</p>
<blockquote>
<p>renderer负责Vue3中节点的渲染、对比、更新。</p>
</blockquote>
<h3 id="createRenderer"><a href="#createRenderer" class="headerlink" title="createRenderer()"></a>createRenderer()</h3><blockquote>
<p>创建并返回一个节点渲染引擎</p>
</blockquote>
<p>查看<code>vue-next/packages/runtime-core/src/renderer.ts</code>中391行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createRenderer&lt;</span><br><span class="line">  HostNode &#x3D; RendererNode,</span><br><span class="line">  HostElement &#x3D; RendererElement</span><br><span class="line">&gt;(options: RendererOptions&lt;HostNode, HostElement&gt;) &#123;</span><br><span class="line">  return baseCreateRenderer&lt;HostNode, HostElement&gt;(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用了<code>baseCreateRenderer()</code>方法，查看其定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;用到的一些定义</span><br><span class="line">type PatchFn &#x3D; (</span><br><span class="line">  n1: VNode | null, &#x2F;&#x2F; null means this is a mount</span><br><span class="line">  n2: VNode,</span><br><span class="line">  container: RendererElement,</span><br><span class="line">  anchor?: RendererNode | null,</span><br><span class="line">  parentComponent?: ComponentInternalInstance | null,</span><br><span class="line">  parentSuspense?: SuspenseBoundary | null,</span><br><span class="line">  isSVG?: boolean,</span><br><span class="line">  optimized?: boolean</span><br><span class="line">) &#x3D;&gt; void</span><br><span class="line"></span><br><span class="line">export type MountComponentFn &#x3D; (</span><br><span class="line">  initialVNode: VNode,</span><br><span class="line">  container: RendererElement,</span><br><span class="line">  anchor: RendererNode | null,</span><br><span class="line">  parentComponent: ComponentInternalInstance | null,</span><br><span class="line">  parentSuspense: SuspenseBoundary | null,</span><br><span class="line">  isSVG: boolean,</span><br><span class="line">  optimized: boolean</span><br><span class="line">) &#x3D;&gt; void</span><br><span class="line"></span><br><span class="line">export type RootRenderFunction&lt;HostElement &#x3D; RendererElement&gt; &#x3D; (</span><br><span class="line">  vnode: VNode | null,</span><br><span class="line">  container: HostElement</span><br><span class="line">) &#x3D;&gt; void</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;baseCreateRenderer方法定义</span><br><span class="line">function baseCreateRenderer(</span><br><span class="line">  options: RendererOptions,</span><br><span class="line">  createHydrationFns?: typeof createHydrationFunctions</span><br><span class="line">): any &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;对比两个节点</span><br><span class="line">    const patch: PatchFn &#x3D; (</span><br><span class="line">    n1,</span><br><span class="line">    n2,</span><br><span class="line">    container,</span><br><span class="line">    anchor &#x3D; null,</span><br><span class="line">    parentComponent &#x3D; null,</span><br><span class="line">    parentSuspense &#x3D; null,</span><br><span class="line">    isSVG &#x3D; false,</span><br><span class="line">    optimized &#x3D; false</span><br><span class="line">  ) &#x3D;&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;渲染组件</span><br><span class="line">  const mountComponent: MountComponentFn &#x3D; (</span><br><span class="line">    initialVNode,</span><br><span class="line">    container,</span><br><span class="line">    anchor,</span><br><span class="line">    parentComponent,</span><br><span class="line">    parentSuspense,</span><br><span class="line">    isSVG,</span><br><span class="line">    optimized</span><br><span class="line">  ) &#x3D;&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;更新组件</span><br><span class="line">  const updateComponent &#x3D; (n1: VNode, n2: VNode, optimized: boolean) &#x3D;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;卸载组件</span><br><span class="line">  const unmountComponent &#x3D; (</span><br><span class="line">    instance: ComponentInternalInstance,</span><br><span class="line">    parentSuspense: SuspenseBoundary | null,</span><br><span class="line">    doRemove?: boolean</span><br><span class="line">  ) &#x3D;&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;渲染组件</span><br><span class="line">  const render: RootRenderFunction &#x3D; (vnode, container) &#x3D;&gt; &#123;</span><br><span class="line">    if (vnode &#x3D;&#x3D; null) &#123;</span><br><span class="line">      if (container._vnode) &#123;</span><br><span class="line">        unmount(container._vnode, null, null, true)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      patch(container._vnode || null, vnode, container)</span><br><span class="line">    &#125;</span><br><span class="line">    flushPostFlushCbs()</span><br><span class="line">    container._vnode &#x3D; vnode</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;返回renderer对象</span><br><span class="line">  return &#123;</span><br><span class="line">    render,</span><br><span class="line">    hydrate,</span><br><span class="line">    createApp: createAppAPI(render, hydrate)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从最后<code>return</code>可看出，最终的app是使用<code>createAppAPI()</code>方法得出。</p>
<h3 id="createAppAPI"><a href="#createAppAPI" class="headerlink" title="createAppAPI()"></a>createAppAPI()</h3><blockquote>
<p>创建并返回一个app实例</p>
</blockquote>
<p>查看文件<code>vue-next/packages/runtime-core/src/apiCreateApp.ts</code>第123行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createAppAPI&lt;HostElement&gt;(</span><br><span class="line">  render: RootRenderFunction,</span><br><span class="line">  hydrate?: RootHydrateFunction</span><br><span class="line">): CreateAppFunction&lt;HostElement&gt; &#123;</span><br><span class="line">  return function createApp(rootComponent, rootProps &#x3D; null) &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建应用上下文</span><br><span class="line">    const context &#x3D; createAppContext()</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;app为方法createApp()最后的返回值，即需要的app实例</span><br><span class="line">    const app: App &#x3D; (context.app &#x3D; &#123;</span><br><span class="line">      _uid: uid++,      &#x2F;&#x2F;唯一标识</span><br><span class="line">      _component: rootComponent as ConcreteComponent,   &#x2F;&#x2F;根组件</span><br><span class="line">      _props: rootProps,    &#x2F;&#x2F;根属性</span><br><span class="line">      _container: null,     &#x2F;&#x2F;根节点</span><br><span class="line">      _context: context,    &#x2F;&#x2F;上下文</span><br><span class="line"></span><br><span class="line">      version,      &#x2F;&#x2F;vue版本号</span><br><span class="line"></span><br><span class="line">      get config() &#123;        &#x2F;&#x2F;获取当前应用的config对象</span><br><span class="line">        return context.config</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      set config(v) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局插件注册-同webpack.config.js中webpack-chain配置use使用</span><br><span class="line">      use(plugin: Plugin, ...options: any[]) &#123;</span><br><span class="line">        if (installedPlugins.has(plugin)) &#123;</span><br><span class="line">          ...</span><br><span class="line">        &#125; else if (plugin &amp;&amp; isFunction(plugin.install)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin.install(app, ...options)</span><br><span class="line">        &#125; else if (isFunction(plugin)) &#123;</span><br><span class="line">          installedPlugins.add(plugin)</span><br><span class="line">          plugin(app, ...options)</span><br><span class="line">        &#125; else if (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            &#96;A plugin must either be a function or an object with an &quot;install&quot; &#96; +</span><br><span class="line">              &#96;function.&#96;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局mixin注册</span><br><span class="line">      mixin(mixin: ComponentOptions) &#123;</span><br><span class="line">        ...</span><br><span class="line">        context.mixins.push(mixin)</span><br><span class="line">        ...</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局组件注册</span><br><span class="line">      component(name: string, component?: Component): any &#123;</span><br><span class="line">        ...</span><br><span class="line">        if (!component) &#123;</span><br><span class="line">          return context.components[name]</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        context.components[name] &#x3D; component</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局指令注册</span><br><span class="line">      directive(name: string, directive?: Directive) &#123;</span><br><span class="line">        ...</span><br><span class="line">        context.directives[name] &#x3D; directive</span><br><span class="line">        return app</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;渲染当前app</span><br><span class="line">      mount(rootContainer: HostElement, isHydrate?: boolean): any &#123;</span><br><span class="line">        if (!isMounted) &#123;</span><br><span class="line">          const vnode &#x3D; createVNode(</span><br><span class="line">            rootComponent as ConcreteComponent,</span><br><span class="line">            rootProps</span><br><span class="line">          )</span><br><span class="line">          &#x2F;&#x2F; store app context on the root VNode.</span><br><span class="line">          &#x2F;&#x2F; this will be set on the root instance on initial mount.</span><br><span class="line">          vnode.appContext &#x3D; context</span><br><span class="line"></span><br><span class="line">          &#x2F;&#x2F; HMR root reload</span><br><span class="line">          if (__DEV__) &#123;</span><br><span class="line">            context.reload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">              render(cloneVNode(vnode), rootContainer)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          if (isHydrate &amp;&amp; hydrate) &#123;</span><br><span class="line">            hydrate(vnode as VNode&lt;Node, Element&gt;, rootContainer as any)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            render(vnode, rootContainer)</span><br><span class="line">          &#125;</span><br><span class="line">          isMounted &#x3D; true</span><br><span class="line">          app._container &#x3D; rootContainer</span><br><span class="line">          &#x2F;&#x2F; for devtools and telemetry</span><br><span class="line">          ;(rootContainer as any).__vue_app__ &#x3D; app</span><br><span class="line"></span><br><span class="line">          if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) &#123;</span><br><span class="line">            devtoolsInitApp(app, version)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          return vnode.component!.proxy</span><br><span class="line">        &#125; else if (__DEV__) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            &#96;App has already been mounted.\n&#96; +</span><br><span class="line">              &#96;If you want to remount the same app, move your app creation logic &#96; +</span><br><span class="line">              &#96;into a factory function and create fresh app instances for each &#96; +</span><br><span class="line">              &#96;mount - e.g. \&#96;const createMyApp &#x3D; () &#x3D;&gt; createApp(App)\&#96;&#96;</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;卸载当前app</span><br><span class="line">      unmount() &#123;</span><br><span class="line">        ...</span><br><span class="line">        render(null, app._container)</span><br><span class="line">        ...</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F;全局provide注册</span><br><span class="line">      provide(key, value) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; TypeScript doesn&#39;t allow symbols as index type</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;TypeScript&#x2F;issues&#x2F;24587</span><br><span class="line">        context.provides[key as string] &#x3D; value</span><br><span class="line">        return app</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &#x2F;&#x2F;返回app对象</span><br><span class="line">    return app</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可得，最终返回的app组成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export interface App&lt;HostElement &#x3D; any&gt; &#123;</span><br><span class="line">  version: string   &#x2F;&#x2F;vue版本</span><br><span class="line">  config: AppConfig &#x2F;&#x2F;全局配置</span><br><span class="line">  use(plugin: Plugin, ...options: any[]): this  &#x2F;&#x2F;全局插件注册</span><br><span class="line">  mixin(mixin: ComponentOptions): this      &#x2F;&#x2F;全局mixin注册</span><br><span class="line">  component(name: string): Component | undefined    &#x2F;&#x2F;全局组件注册</span><br><span class="line">  component(name: string, component: Component): this</span><br><span class="line">  directive(name: string): Directive | undefined    &#x2F;&#x2F;全局指令注册</span><br><span class="line">  directive(name: string, directive: Directive): this</span><br><span class="line">  mount(    &#x2F;&#x2F;渲染app方法</span><br><span class="line">    rootContainer: HostElement | string,</span><br><span class="line">    isHydrate?: boolean</span><br><span class="line">  ): ComponentPublicInstance</span><br><span class="line">  unmount(rootContainer: HostElement | string): void    &#x2F;&#x2F;卸载组件方法</span><br><span class="line">  provide&lt;T&gt;(key: InjectionKey&lt;T&gt; | string, value: T): this &#x2F;&#x2F;全局provide注册</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; internal, but we need to expose these for the server-renderer and devtools</span><br><span class="line">  _uid: number  &#x2F;&#x2F;唯一标识</span><br><span class="line">  _component: ConcreteComponent &#x2F;&#x2F;根组件</span><br><span class="line">  _props: Data | null   &#x2F;&#x2F;根属性</span><br><span class="line">  _container: HostElement | null    &#x2F;&#x2F;根节点</span><br><span class="line">  _context: AppContext  &#x2F;&#x2F;上下文节点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>故回到<code>main.js</code>文件，创建完app实例，则调用了app的<code>mount</code>方法开始渲染对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;;</span><br><span class="line">import App from &quot;.&#x2F;App&quot;; &#x2F;&#x2F; 引入 App.vue 组件</span><br><span class="line">const app &#x3D; createApp(App, &#123; msg: &quot;hello Vue 3&quot; &#125;); &#x2F;&#x2F; 创建 App 根组件</span><br><span class="line">app.mount(&quot;#app&quot;); &#x2F;&#x2F; 渲染 App</span><br></pre></td></tr></table></figure>

<h2 id="附录-Vue3流程图"><a href="#附录-Vue3流程图" class="headerlink" title="附录-Vue3流程图"></a>附录-Vue3流程图</h2><p><img src="https://z3.ax1x.com/2021/05/26/2pvc1f.md.jpg" alt="vue流程图"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>从0搭建简易vue3项目</title>
    <url>/post/876416960.html</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li><p>创建目录，使用<code>npm init -y</code>初始化项目</p>
</li>
<li><p>使用<code>npm install -D xxx ...</code>命令安装webpack相关依赖</p>
<ul>
<li><p>webpack：webpack编译打包核心库</p>
</li>
<li><p>webpack-cli：webpack指令库</p>
</li>
<li><p>webpack-dev-server：webpack开发者服务框架</p>
</li>
<li><p>webpack-chain：webpack配置工具</p>
</li>
</ul>
</li>
<li><p>创建webpack配置文件<code>webpack.config.js</code></p>
</li>
</ol>
<a id="more"></a>

<ol start="4">
<li>在<code>package.json</code>的<code>scripts</code>字段声明<code>build</code>和<code>dev</code>脚本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;build&quot;: &quot;rimraf dist &amp;&amp; webpack --mode&#x3D;production&quot;,</span><br><span class="line">&quot;dev&quot;: &quot;webpack serve --mode&#x3D;development&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>创建<code>src</code>目录和入口文件<code>src/main.js</code></p>
</li>
<li><p>配置<code>webpack.config.js</code></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line">const config &#x3D; new (require(&quot;webpack-chain&quot;))();</span><br><span class="line">config</span><br><span class="line">.context(path.resolve(__dirname, &quot;.&quot;)) &#x2F;&#x2F; webpack 上下文目录为项目根目录</span><br><span class="line">.entry(&quot;app&quot;) &#x2F;&#x2F; 入口文件名称为 app</span><br><span class="line">.add(&quot;.&#x2F;src&#x2F;main.js&quot;) &#x2F;&#x2F; 入口文件为 .&#x2F;src&#x2F;main.js</span><br><span class="line">.end()</span><br><span class="line">.output.path(path.join(__dirname, &quot;.&#x2F;dist&quot;)) &#x2F;&#x2F; webpack 输出的目录为根目录的 dist 目录</span><br><span class="line">.filename(&quot;[name].[hash:8].js&quot;) &#x2F;&#x2F; 打包出来的 bundle 名称为 &quot;[name].[hash:8].js&quot;</span><br><span class="line">.publicPath(&quot;&#x2F;&quot;) &#x2F;&#x2F; publicpath 配置为 &quot;&#x2F;&quot;</span><br><span class="line">.end();</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>安装Vue3相关依赖</p>
<ul>
<li><p>vue：Vue3源码</p>
</li>
<li><p>vue-loader：.vue文件webpack加载器</p>
</li>
<li><p>@vue/compiler-sfc：vue-loader用来解析sfc（Single File Component）插件</p>
</li>
<li><p>html-webpack-plugin：webpack插件用来自动注入chunks到模版html文件</p>
</li>
</ul>
</li>
<li><p>创建公共目录<code>public</code>和项目入口页面<code>public/index.html</code></p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;noscript&gt;your browser should support javascript!&lt;&#x2F;noscript&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- html-webpack-plugin 将自动引入入口文件 --&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>在<code>webpack.config.js</code>文件中配置vue工具(<code>webpack.config.js</code>最终文件见文末附录)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">.resolve.extensions.add(&quot;.js&quot;)</span><br><span class="line">.add(&quot;.vue&quot;) &#x2F;&#x2F; 配置以 .js 等结尾的文件当模块使用的时候都可以省略后缀</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.module.rule(&quot;vue&quot;) &#x2F;&#x2F; vue-loader 相关配置</span><br><span class="line">.test(&#x2F;\.vue$&#x2F;) &#x2F;&#x2F; 匹配 .vue 文件</span><br><span class="line">.use(&quot;vue-loader&quot;)</span><br><span class="line">.loader(&quot;vue-loader&quot;)</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.plugin(&quot;vue-loader-plugin&quot;) &#x2F;&#x2F; vue-loader 必须要添加 vue-loader-plugin</span><br><span class="line">.use(require(&quot;vue-loader&quot;).VueLoaderPlugin, [])</span><br><span class="line">.end()</span><br><span class="line">.plugin(&quot;html&quot;) &#x2F;&#x2F; 添加 html-webpack-plugin 插件</span><br><span class="line">.use(require(&quot;html-webpack-plugin&quot;), [</span><br><span class="line">&#123;</span><br><span class="line">    template: path.resolve(__dirname, &quot;.&#x2F;public&#x2F;index.html&quot;), &#x2F;&#x2F; 指定模版文件</span><br><span class="line">    chunks: [&quot;app&quot;], &#x2F;&#x2F; 指定需要加载的 chunk</span><br><span class="line">    inject: &quot;body&quot;, &#x2F;&#x2F; 指定 script 脚本注入的位置为 body</span><br><span class="line">&#125;,</span><br><span class="line">])</span><br><span class="line">.end()</span><br><span class="line">.devServer.host(&quot;0.0.0.0&quot;) &#x2F;&#x2F; 服务器外部可访问</span><br><span class="line">.disableHostCheck(true) &#x2F;&#x2F; 关闭白名单校验</span><br><span class="line">.contentBase(path.resolve(__dirname, &quot;.&#x2F;public&quot;)) &#x2F;&#x2F; 设置一个 express 静态目录</span><br><span class="line">.historyApiFallback(&#123;</span><br><span class="line">disableDotRule: true, &#x2F;&#x2F; 禁止在链接中使用 &quot;.&quot; 符号</span><br><span class="line">rewrites: [</span><br><span class="line">    &#123; from: &#x2F;^\&#x2F;$&#x2F;, to: &quot;&#x2F;index.html&quot; &#125;, &#x2F;&#x2F; 将所有的 404 响应重定向到 index.html 页面</span><br><span class="line">],</span><br><span class="line">&#125;)</span><br><span class="line">.port(8080) &#x2F;&#x2F; 当前端口号</span><br><span class="line">.hot(true) &#x2F;&#x2F; 打开页面热载功能</span><br><span class="line">.sockPort(&quot;location&quot;) &#x2F;&#x2F; 设置成平台自己的端口</span><br><span class="line">.open(true);</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>创建sfc组件<code>src/App.vue</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &#123;&#123; msg &#125;&#125;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;app&quot;,</span><br><span class="line">  props: [&quot;msg&quot;],</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>在入口文件<code>src/main.js</code>中引入<code>App.vue</code>组件，并将其挂载到<code>id=app</code>的节点上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &quot;vue&quot;; &#x2F;&#x2F; 引入 Vue 3 源码</span><br><span class="line">import App from &quot;.&#x2F;App&quot;; &#x2F;&#x2F; 引入 App.vue 组件</span><br><span class="line">const app &#x3D; createApp(App, &#123; msg: &quot;hello Vue 3&quot; &#125;); &#x2F;&#x2F; 渲染 App 组件，并传递 msg 参数 “hello Vue”</span><br><span class="line">app.mount(&quot;#app&quot;); &#x2F;&#x2F; 渲染 App</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>使用命令<code>npm run dev</code>运行项目</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/26/2pH9aV.png" alt="运行项目"></p>
<ol start="13">
<li>下载Vue3源码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone -b https:&#x2F;&#x2F;github.com&#x2F;vuejs&#x2F;vue-next.git</span><br></pre></td></tr></table></figure>

<p>目录：</p>
<p><img src="https://i.loli.net/2021/05/19/saSrTKyNbRA41B8.png" alt="总目录"></p>
<p><img src="https://i.loli.net/2021/05/19/5G7fRioLh9ZBm1k.png" alt="package目录"></p>
<ol start="14">
<li>安装Vue3依赖</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd vue-next &amp;&amp; yarn --registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<ol start="15">
<li><p>使用命令<code>yarn build</code>编译Vue3源码并打包</p>
</li>
<li><p>使用命令<code>yarn dev --s</code>启动源码开发环境</p>
</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/26/2pH6Ln.png" alt="启动源码"></p>
<ol start="17">
<li>修改vue的<code>demo</code>项目<code>webpack.config.js</code>文件，引入vue源码文件<code>vue-next/packages/vue/dist/vue.global.js</code>。(<code>webpack.config.js</code>最终文件见文末附录)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">.devServer.host(&quot;0.0.0.0&quot;) &#x2F;&#x2F; 服务器外部可访问</span><br><span class="line">.disableHostCheck(true) &#x2F;&#x2F; 关闭白名单校验</span><br><span class="line">.contentBase([</span><br><span class="line">path.resolve(__dirname, &quot;.&#x2F;public&quot;),</span><br><span class="line">path.resolve(__dirname, &quot;..&#x2F;vue-next&quot;),</span><br><span class="line">]) &#x2F;&#x2F; 设置一个 express 静态目录</span><br><span class="line">.historyApiFallback(&#123;</span><br><span class="line">disableDotRule: true, &#x2F;&#x2F; 禁止在链接中使用 &quot;.&quot; 符号</span><br><span class="line">rewrites: [</span><br><span class="line">    &#123; from: &#x2F;^\&#x2F;$&#x2F;, to: &quot;&#x2F;index.html&quot; &#125;, &#x2F;&#x2F; 将所有的 404 响应重定向到 index.html 页面</span><br><span class="line">],</span><br><span class="line">&#125;)</span><br><span class="line">.port(8080) &#x2F;&#x2F; 当前端口号</span><br><span class="line">.hot(true) &#x2F;&#x2F; 打开页面热载功能</span><br><span class="line">.sockPort(&quot;location&quot;) &#x2F;&#x2F; 设置成平台自己的端口</span><br><span class="line">.open(true);</span><br><span class="line"></span><br><span class="line">config.externals(&#123;</span><br><span class="line">vue: &quot;Vue&quot;, &#x2F;&#x2F; 告诉 webpack，让它在加载 vue 模块的时候去 CDN 全局变量里面找 Vue</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="18">
<li>启动demo项目，在url后添加<code>/packages/vue/dist/vue.global.js</code>查看源码文件（可使用同样方法输入其他文件相对路径查看）</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/26/2pqfv4.png" alt="源码文件"></p>
<ol start="19">
<li>在demo项目<code>public/index.html</code>中以<code>CDN</code>形式导入本地vue3源码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;!-- 以 CDN 形式导入我们本地的 Vue 3 源码 --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;&#x2F;packages&#x2F;vue&#x2F;dist&#x2F;vue.global.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;noscript&gt;your browser should support javascript!&lt;&#x2F;noscript&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- html-webpack-plugin 将自动引入入口文件 --&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ol start="20">
<li>启动后可在浏览器开发者工具中查看源码进行断点调试。</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/26/2pL1RU.png" alt="源码调试"></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="webpack-config-js文件"><a href="#webpack-config-js文件" class="headerlink" title="webpack.config.js文件"></a>webpack.config.js文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config &#x3D; new (require(&quot;webpack-chain&quot;))</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line">&#x2F;&#x2F; const isDev &#x3D; !!process.env.WEBPACK_DEV_SERVER; &#x2F;&#x2F; 判断是否是开发环境</span><br><span class="line"></span><br><span class="line">config</span><br><span class="line">.context(path.resolve(__dirname,&quot;.&quot;))&#x2F;&#x2F;上下文目录</span><br><span class="line">.entry(&quot;app&quot;)&#x2F;&#x2F;入口文件名称</span><br><span class="line">.add(&quot;.&#x2F;src&#x2F;main.js&quot;)&#x2F;&#x2F;入口文件为.&#x2F;src&#x2F;main.js</span><br><span class="line">.end()</span><br><span class="line">.output.path(path.join(__dirname,&quot;.&#x2F;dist&quot;))&#x2F;&#x2F;输出目录为dist</span><br><span class="line">.filename(&quot;[name].[hash:8].js&quot;)&#x2F;&#x2F;打包出的bundle名称</span><br><span class="line">.publicPath(&quot;&#x2F;&quot;)&#x2F;&#x2F;公共目录</span><br><span class="line">.end()</span><br><span class="line">.resolve.extensions.add(&quot;.js&quot;)</span><br><span class="line">.add(&quot;.vue&quot;)</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.module.rule(&quot;vue&quot;)</span><br><span class="line">.test(&#x2F;\.vue$&#x2F;)</span><br><span class="line">.use(&quot;vue-loader&quot;)</span><br><span class="line">.loader(&quot;vue-loader&quot;)</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.end()</span><br><span class="line">.plugin(&quot;vue-loader-plugin&quot;)</span><br><span class="line">.use(require(&quot;vue-loader&quot;).VueLoaderPlugin,[])</span><br><span class="line">.end()</span><br><span class="line">.plugin(&quot;html&quot;)</span><br><span class="line">.use(require(&quot;html-webpack-plugin&quot;),[</span><br><span class="line">    &#123;</span><br><span class="line">        template: path.resolve(__dirname,&quot;.&#x2F;public&#x2F;index.html&quot;),&#x2F;&#x2F;指定模版文件</span><br><span class="line">        chunks: [&quot;app&quot;],&#x2F;&#x2F;指定需要加在的chunk</span><br><span class="line">        inject: &quot;body&quot;&#x2F;&#x2F;指定script脚本注入的位置为body</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br><span class="line">.end()</span><br><span class="line">.devServer.disableHostCheck(true)</span><br><span class="line">.contentBase(</span><br><span class="line">    [</span><br><span class="line">        path.resolve(__dirname,&quot;.&#x2F;public&quot;),</span><br><span class="line">        path.resolve(__dirname,&quot;..&#x2F;vue-next&#x2F;vue-next&quot;)</span><br><span class="line">    ]</span><br><span class="line">)&#x2F;&#x2F;设置express静态目录</span><br><span class="line">.historyApiFallback(&#123;</span><br><span class="line">    disableDotRule: true,</span><br><span class="line">    rewrites:[</span><br><span class="line">        &#123;</span><br><span class="line">            from: &#x2F;ˆ\&#x2F;$&#x2F;,</span><br><span class="line">            to: &quot;index.html&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;)</span><br><span class="line">.port(8080)</span><br><span class="line">.hot(true)</span><br><span class="line">.sockPort(&quot;location&quot;)</span><br><span class="line">.open(true)</span><br><span class="line">.end()</span><br><span class="line">.devtool(&#39;eval-source-map&#39;);</span><br><span class="line"></span><br><span class="line">config.externals(&#123;</span><br><span class="line">    vue: &quot;Vue&quot;,&#x2F;&#x2F;告诉webpack，在加载vue模块时去CDN全局变量里找Vue</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; config.when(</span><br><span class="line">&#x2F;&#x2F;     !isDev,</span><br><span class="line">&#x2F;&#x2F;     ()&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;         &#x2F;&#x2F; 生产环境配置</span><br><span class="line">&#x2F;&#x2F;         config.devtool(null) &#x2F;&#x2F; 生产不生成 source-map，默认行为</span><br><span class="line">&#x2F;&#x2F;     &#125;,</span><br><span class="line">&#x2F;&#x2F;     ()&#x3D;&gt;&#123;</span><br><span class="line">&#x2F;&#x2F;         &#x2F;&#x2F; 开发环境配置</span><br><span class="line">&#x2F;&#x2F;         config.devtool(&#39;eval-source-map&#39;) &#x2F;&#x2F; 获取完整的 source-map，并且用 eval 函数执行</span><br><span class="line">&#x2F;&#x2F;     &#125;</span><br><span class="line">&#x2F;&#x2F; );</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; config.toConfig();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>近期问题分析及解决</title>
    <url>/post/900994060.html</url>
    <content><![CDATA[<h2 id="使用命令npm-run-dev运行时提示报错Cannot-find-module-39-webpack-cli-bin-config-yargs"><a href="#使用命令npm-run-dev运行时提示报错Cannot-find-module-39-webpack-cli-bin-config-yargs" class="headerlink" title="使用命令npm run dev运行时提示报错Cannot find module &#39;webpack-cli/bin/config-yargs"></a>使用命令<code>npm run dev</code>运行时提示报错<code>Cannot find module &#39;webpack-cli/bin/config-yargs</code></h2><p>本地package版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;webpack&quot;: &quot;^5.37.1&quot;,</span><br><span class="line">&quot;webpack-chain&quot;: &quot;^6.5.1&quot;,</span><br><span class="line">&quot;webpack-cli&quot;: &quot;^4.7.0&quot;,</span><br><span class="line">&quot;webpack-dev-server&quot;: &quot;^3.11.2&quot;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>webpack-cli的新版本对webpack-dev-server版本不兼容，卸载后重装webpack-cli提示和webpack有冲突，需要全部重装合适版本，很麻烦。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>将<code>package.json</code>中<code>dev</code>的命令由<code>webpack-dev-server --mode=development --progess</code>改为<code>webpack serve --mode=development</code>后，运行<code>npm run dev</code>成功。</p>
<h2 id="webpack配置外部扩展externals"><a href="#webpack配置外部扩展externals" class="headerlink" title="webpack配置外部扩展externals"></a>webpack配置外部扩展externals</h2><h2 id="ES6字符串模版语法-和’"><a href="#ES6字符串模版语法-和’" class="headerlink" title="ES6字符串模版语法`和’"></a>ES6字符串模版语法`和’</h2>]]></content>
      <categories>
        <category>debug</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
        <tag>debug</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-dev-server搭建简易mock服务器</title>
    <url>/post/328527238.html</url>
    <content><![CDATA[<h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><blockquote>
<p>用来快速开发应用，仅用于development环境</p>
</blockquote>
<p>webpack-dev-server是第三方依赖库，依赖<code>webpack-dev-middleware</code>（负责把webpack打包后的文件存放在内存中供外界访问）。</p>
<p>下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -D webpack-dev-server --registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h3><blockquote>
<p>对象，webpack的一个配置选项，主要为<code>webpack-dev-server</code>的参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: path.join(__dirname, &#39;dist&#39;),</span><br><span class="line">    compress: true, &#x2F;&#x2F; 该选项为 true，如果访问服务器的文件，将压缩 dist 目录底下的所有文件给到访问者</span><br><span class="line">    port: 8888,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li>host: 指定一个host，默认为<code>localhost</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    host: &#39;0.0.0.0&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li><p>port: 设置服务器的端口，默认为<code>8080</code></p>
</li>
<li><p>allowedHost: 字符串数组，用于添加白名单，允许开发服务器访问</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    host: &quot;0.0.0.0&quot;, &#x2F;&#x2F; 如果你希望服务器外部可访问</span><br><span class="line">    allowedHosts: [</span><br><span class="line">        &quot;www.baidu.com&quot; &#x2F;&#x2F; 添加白名单</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>disableHostCheck: 是否关闭白名单校验，默认为<code>false</code>，此项设为<code>true</code>则不需要设置<code>allowedHost</code></p>
</li>
<li><p>before: function，在服务其他中间件之前，提供执行自定义中间件的功能，可以用来配置自定义处理程序</p>
</li>
<li><p>after: function，用法与<code>before</code>一致，表示在服务其他中间件之后执行自定义中间件的功能</p>
</li>
<li><p>compress: 默认为<code>false</code>，用于对服务器的文件和处理结果的压缩</p>
</li>
<li><p>contentBase: 默认为<code>process.cwd()</code>，<code>express</code>的功能，利用express指定某目录为静态目录</p>
</li>
<li><p>contentBasePublicPath: 表示静态公共目录的访问path</p>
</li>
<li><p>historyApiFallback: 当后端路由没有命中，就会自动重定向到<code>index.html</code></p>
</li>
<li><p>hot: 默认为<code>false</code>，启用webpack的模块热替换功能</p>
<ul>
<li><p>hot reload: 热载入，需要打开hot生效，即当webpack监听到文件变化，打包编译后通知<code>webpack-dev-server</code>,客户端收到<code>webpack-dev-server</code>消息后更新局部模块。</p>
</li>
<li><p>live load: 实时更新，webpack-dev-server默认开启，即客户端刷新整个页面。</p>
</li>
</ul>
</li>
<li><p>open: 字符串或对象，默认<code>false</code>禁用。告诉dev-server在server启动后打开浏览器</p>
</li>
<li><p>overlay: <code>boolean</code>或对象形式，默认为<code>false</code>。将webpack报错信息显示到浏览器</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">    ...</span><br><span class="line">    overlay: true, &#x2F;&#x2F; 把 webpack 的报错和警告信息显示在浏览器</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;或分开显示error和warning</span><br><span class="line">overlay: &#123;</span><br><span class="line">  warnings: true, &#x2F;&#x2F; 是否显示 warnings</span><br><span class="line">  errors: true &#x2F;&#x2F; 是否显示 errors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="搭建mock服务器"><a href="#搭建mock服务器" class="headerlink" title="搭建mock服务器"></a>搭建mock服务器</h2><ol>
<li><p>新建mock目录</p>
</li>
<li><p>编写mock接口函数</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; function (req,res,next)&#123;</span><br><span class="line">    const &#123; name &#125; &#x3D; req.query; &#x2F;&#x2F;接受参数name  </span><br><span class="line">    let result &#x3D; &#96;$&#123;name&#125;，请回应我～&#96;; &#x2F;&#x2F;返回result</span><br><span class="line">    res.json(&#123; msg: result &#125;); &#x2F;&#x2F;json格式返回result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改<code>webpack.config.js</code>文件用<code>webpack-dev-server</code>加载此函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">        disableHostCheck: true, &#x2F;&#x2F;关闭白名单校验</span><br><span class="line">        before(app, devServer, compiler)&#123;</span><br><span class="line">            const glob &#x3D; require(&quot;glob&quot;);</span><br><span class="line">            const mockPaths &#x3D; &#96;$&#123;path.join(__dirname,&#39;.&#x2F;mock&#39;)&#125;&#x2F;*.js&#96;;&#x2F;&#x2F;获取所有mock函数</span><br><span class="line">            glob(mockPaths,function(er,files)&#123;</span><br><span class="line">                files.forEach((mockFile) &#x3D;&gt; &#123;&#x2F;&#x2F; 遍历所有mock函数</span><br><span class="line">                    const mockFunc &#x3D; require(mockFile); &#x2F;&#x2F; 获取当前mock函数</span><br><span class="line">                    const methodName &#x3D; path.basename(mockFile).split(&quot;.&quot;)[0];&#x2F;&#x2F;获取当前mock名称</span><br><span class="line">                    app.all(&quot;&#x2F;&quot; + methodName, mockFunc); &#x2F;&#x2F; 添加mock函数到服务器</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用命令<code>npx webpack-dev-server</code>启动，访问链接<code>http://localhost:8080/responseByName?name=lynn</code>查看效果</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/25/gzQEZR.png" alt="mock回应"></p>
<ol start="5">
<li>编写对接接口并处理返回值渲染页面</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;入口文件src&#x2F;index.js</span><br><span class="line">import &#123;webpackSay&#125; from &quot;..&#x2F;library&quot;; &#x2F;&#x2F;引入 library 的 webpackSay 方法</span><br><span class="line">import Vue from &quot;vue&quot;; &#x2F;&#x2F;导入vue</span><br><span class="line">import noticeWebpack from &quot;$NOTICE&quot;; &#x2F;&#x2F;导入noticeWebpack组件</span><br><span class="line"></span><br><span class="line">document.write(&quot;hello webpack!&quot;);</span><br><span class="line">&#x2F;&#x2F;按需引入demo.js文件</span><br><span class="line">import(&quot;.&#x2F;demo&quot;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">    result.default();</span><br><span class="line">    webpackSay(); &#x2F;&#x2F;执行 webpackSay方法</span><br><span class="line">    &#x2F;&#x2F; 通知webpack函数</span><br><span class="line">    function renderNotice()&#123;</span><br><span class="line">        const noticeRootEle &#x3D; document.createElement(&quot;div&quot;);</span><br><span class="line">        document.body.append(noticeRootEle);</span><br><span class="line">        new Vue(&#123;</span><br><span class="line">            render: (h) &#x3D;&gt; h(noticeWebpack)</span><br><span class="line">        &#125;).$mount(noticeRootEle);</span><br><span class="line">    &#125;</span><br><span class="line">    renderNotice();</span><br><span class="line">    &#x2F;&#x2F; mock服务器对接接口，渲染页面</span><br><span class="line">    responseMsg(&#39;Lynn&#39;).then((msg) &#x3D;&gt; &#123;</span><br><span class="line">        writeToPage(&#96;喂喂喂： $&#123;msg&#125;&#96;);</span><br><span class="line">    &#125;).catch((e) &#x3D;&gt;&#123;</span><br><span class="line">        writeToPage(&#39;喂喂喂，听不到我嘛～&#39;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * 对话函数</span><br><span class="line"> * @param name</span><br><span class="line"> *&#x2F;</span><br><span class="line">function responseMsg(name)&#123;</span><br><span class="line">    return new Promise((resolve,reject) &#x3D;&gt;&#123;</span><br><span class="line">        const request &#x3D; new XMLHttpRequest();</span><br><span class="line">        request.onreadystatechange &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">            if(request.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; request.status &#x3D;&#x3D;&#x3D; 200)&#123;</span><br><span class="line">                const result &#x3D; JSON.parse(request.responseText);</span><br><span class="line">                resolve(result.msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        request.onerror &#x3D; (error) &#x3D;&gt; &#123;</span><br><span class="line">            reject(error);</span><br><span class="line">        &#125;;</span><br><span class="line">        request.open(&#39;GET&#39;,&#96;&#x2F;responseByName?name&#x3D;$&#123;name&#125;&#96;);</span><br><span class="line">        request.setRequestHeader(&#39;accept&#39;, &#39;application&#x2F;json&#39;); &#x2F;&#x2F; 添加请求头 accept 为 application&#x2F;json</span><br><span class="line">        request.send(null);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line"> * 打印msg到页面</span><br><span class="line"> * @param msg</span><br><span class="line"> *&#x2F;</span><br><span class="line">function writeToPage(msg)&#123;</span><br><span class="line">    const ele &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">    ele.innerText &#x3D; msg;</span><br><span class="line">    document.body.append(ele);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用命令<code>npx webpack-dev-server</code>启动，查看效果</li>
</ol>
<p><img src="https://z3.ax1x.com/2021/05/25/gzw8gA.png" alt="mock效果"></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-配置参数解析（下）</title>
    <url>/post/2741042691.html</url>
    <content><![CDATA[<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><blockquote>
<p>选项<code>resolve</code>可设置模块如何被解析</p>
</blockquote>
<h3 id="resolve-alias"><a href="#resolve-alias" class="headerlink" title="resolve.alias"></a>resolve.alias</h3><blockquote>
<p>创建<code>import</code>或<code>require</code>中间<code>request</code>的别名</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用alias前</span><br><span class="line">import noticewebpack from &#39;.&#x2F;notice-webpack.vue&#39;; &#x2F;&#x2F; 导入 noticewebpack 组件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置module中resolve</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  ...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &#39;$NOTICE&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#x2F;notice-webpack.vue&#39;) &#x2F;&#x2F; 设置一个别名替换 .&#x2F;src&#x2F;notice-webpack.vue 文件</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置后</span><br><span class="line">import noticewebpack from &#39;$NOTICE&#39;; &#x2F;&#x2F; 导入 noticewebpack 组件</span><br></pre></td></tr></table></figure>

<h3 id="resolve-mainFields"><a href="#resolve-mainFields" class="headerlink" title="resolve.mainFields"></a>resolve.mainFields</h3><blockquote>
<p>当从<code>npm</code>包中导入模块时，<code>mainFields</code>决定在<code>package.json</code>中使用哪个字段导入模块。根据webpack配置中指定的<code>target</code>不同，默认值也不同</p>
</blockquote>
<ul>
<li>当<code>target</code>为：<code>webworker</code>、<code>web</code>或没有指定时，默认值为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    mainFields: [&#39;browser&#39;, &#39;module&#39;, &#39;main&#39;], &#x2F;&#x2F; 顺序从左到右加载</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他<code>target</code>，默认值为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F;...</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    mainFields: [&#39;module&#39;, &#39;main&#39;], &#x2F;&#x2F; 顺序从左到右加载</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="resolve-extensions"><a href="#resolve-extensions" class="headerlink" title="resolve.extensions"></a>resolve.extensions</h3><blockquote>
<p>自动解析确定的扩展，即确定在加载模块时能省略后缀的文件，默认值为<code>[&#39;.wasm&#39;,&#39;.mjs&#39;,&#39;.js&#39;,&#39;.json&#39;]</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;配置前</span><br><span class="line">import noticewebpack from &#39;.&#x2F;notice-webpack.vue&#39;; &#x2F;&#x2F; 导入 noticewebpack 组件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;配置extensions参数</span><br><span class="line"> ...</span><br><span class="line"> resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            &#39;$NOTICE&#39;: path.resolve(__dirname, &#39;.&#x2F;src&#x2F;notice-webpack.vue&#39;)</span><br><span class="line">        &#125;,</span><br><span class="line">        extensions: [&#39;.wasm&#39;, &#39;.mjs&#39;, &#39;.js&#39;, &#39;.json&#39;, &#39;.vue&#39;] &#x2F;&#x2F; 配置后缀自动解析</span><br><span class="line">    &#125;,</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 配置后</span><br><span class="line">import noticewebpack from &#39;.&#x2F;notice-webpack&#39;; &#x2F;&#x2F; 导入 noticewebpack 组件</span><br></pre></td></tr></table></figure>

<h3 id="resolve-enforceExtension"><a href="#resolve-enforceExtension" class="headerlink" title="resolve.enforceExtension"></a>resolve.enforceExtension</h3><p>若设置为<code>true</code>则不允许有无扩展名的文件</p>
<h3 id="resolve-modules"><a href="#resolve-modules" class="headerlink" title="resolve.modules"></a>resolve.modules</h3><blockquote>
<p>告知webpack解析模块时应该搜索的目录，绝对路径和相对路径均可使用</p>
</blockquote>
<p>添加一个目录到模块搜索目录，此目录优先于<code>node_modules/</code>目录进行搜索的话，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">modules: [path.resolve(__dirname, &#39;src&#39;), &#39;node_modules&#39;];</span><br></pre></td></tr></table></figure>

<p>此时引入src/xxx文件，即<code>import(&quot;./demo&quot;).then()</code>可以省略<code>.</code>，直接使用<code>import(&quot;demo&quot;).then()</code>引入</p>
<h3 id="resolveLoader"><a href="#resolveLoader" class="headerlink" title="resolveLoader"></a>resolveLoader</h3><blockquote>
<p>用于解析webpack的loader包</p>
</blockquote>
<p>默认值为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  modules: [ &#39;node_modules&#39; ], &#x2F;&#x2F; 默认的 loader 搜索目录</span><br><span class="line">  extensions: [ &#39;.js&#39;, &#39;.json&#39; ], &#x2F;&#x2F; 默认的 loader 后缀自动解析</span><br><span class="line">  mainFields: [ &#39;loader&#39;, &#39;main&#39; ] &#x2F;&#x2F; 默认的 loader 模块入口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><blockquote>
<p>插件可以时一个<code>object</code>或<code>function</code>，故plugins为<code>object</code>或<code>function</code>的集合</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">plugins: [new (require(&#39;vue-loader&#39;).VueLoaderPlugin)()];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-配置参数解析（中）</title>
    <url>/post/641273569.html</url>
    <content><![CDATA[<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><blockquote>
<p>webpack中用<code>require</code>或<code>import</code>引入的都叫module，通过对module选项的配置可以让loader加载对应的模块</p>
</blockquote>
<h3 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h3><p>当使用commonjs模块生成，修改src/index.js文件引入library</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; webpackSay &#125; from &#39;..&#x2F;library&#39;; &#x2F;&#x2F; 引入 library 的 webpackSay 方法</span><br><span class="line"></span><br><span class="line">document.write(&#39;fall in love with webpack！&#39;);</span><br><span class="line">&#x2F;&#x2F; 按需引入 girl.js 文件</span><br><span class="line">import(&#39;.&#x2F;girl&#39;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  result.default();</span><br><span class="line">  webpackSay(); &#x2F;&#x2F; 执行 webpackSay 方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>此时打包编译，代码用<code>import</code>或<code>require</code>导入时，webpack会再编译一遍<code>library</code>，严重影响性能，故可以使用<code>module.noParse</code>忽略对library模块的再次编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  mode: &#39;development&#39;, &#x2F;&#x2F; 测试环境</span><br><span class="line">  context: path.resolve(__dirname, &#39;.&#x2F;src&#39;), &#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">  entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt; resolve(&#39;.&#x2F;index.js&#39;)), &#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;.&#x2F;lib&#39;), &#x2F;&#x2F; 修改输出路径为 “sy_webpack-config&#x2F;lib”</span><br><span class="line">    publicPath: &#39;.&#x2F;lib&#x2F;&#39;, &#x2F;&#x2F; 配置公共路径</span><br><span class="line">    filename: &quot;[name].js&quot;, &#x2F;&#x2F;配置入口最后生成输出文件名称</span><br><span class="line">    chunkFilename: &quot;[name].[chunkhash:8].js&quot; &#x2F;&#x2F;让它的组成为 &#96;名称.8位内容的hash值.js&#96;</span><br><span class="line">  &#125;,</span><br><span class="line">  module:&#123;</span><br><span class="line">      noParse: &#x2F;(library)&#x2F;,&#x2F;&#x2F;过滤掉library模块</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="rules"><a href="#rules" class="headerlink" title="rules"></a>rules</h3><blockquote>
<p>模块rule的集合。当创建模块时，匹配请求的rule数组，修改模块的创建方式，并对模块应用选择对应的loader或修改解析器</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">      ...</span><br><span class="line">    module: &#123;</span><br><span class="line">        noParse: &#x2F;(library)&#x2F;, &#x2F;&#x2F; 过滤掉 library 模块</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;.vue$&#x2F;, &#x2F;&#x2F; 设置当前模块的规则</span><br><span class="line">                use: &#39;vue-loader&#39;, &#x2F;&#x2F; 设置当前模块的加载器</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: &#x2F;\.(sass|scss)$&#x2F;, &#x2F;&#x2F; 设置当前模块的规则</span><br><span class="line">                use: [ &#x2F;&#x2F; 设置当前模块的加载器</span><br><span class="line">                    &quot;style-loader&quot;,</span><br><span class="line">                    &quot;css-loader&quot;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: &quot;postcss-loader&quot;,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            ident: &quot;postcss&quot;,</span><br><span class="line">                            config: &#123;</span><br><span class="line">                                path: path.resolve(__dirname,&quot;.&#x2F;postcss.config.js&quot;)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;sass-loader&quot;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">   ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="条件Condition"><a href="#条件Condition" class="headerlink" title="条件Condition"></a>条件Condition</h4><p>有两种输入值:</p>
<ol>
<li><p>resource：请求文件的绝对路径,属性<code>test</code>、<code>include</code>、<code>exclude</code>、<code>resource</code>对<code>resource</code>匹配</p>
</li>
<li><p>issuer：被请求资源模块文件的绝对路径，代表导入时的模块路径。属性<code>issuer</code>对<code>issuer</code>匹配</p>
</li>
</ol>
<p>如：从<code>app.js</code>导入<code>./style.css</code>模块，则<code>resource</code>为<code>./style.css</code>，<code>issuer</code>为<code>app.js</code></p>
<h5 id="Rule-test"><a href="#Rule-test" class="headerlink" title="Rule.test"></a>Rule.test</h5><blockquote>
<p>为<code>Rule.resource.test</code>的简写。提供了<code>Rule.test</code>就不能再提供<code>Rule.resource</code></p>
</blockquote>
<ul>
<li>字符串：匹配输入必须以提供的字符串开始，目录绝对路径或文件绝对路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: path.resolve(__dirname,&#39;.&#x2F;src&#x2F;notice-webpack.vue&#39;), &#x2F;&#x2F; 字符串匹配一个文件，绝对路径</span><br><span class="line">    use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>正则表达式，使用test来验证输入的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">  use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>函数：调用输入的函数，必须返回一个真值匹配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: resource &#x3D;&gt; &#x2F;\.vue$&#x2F;.test(resource),</span><br><span class="line">    use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>条件数组：至少有一个匹配</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: [ &#x2F;\.vue$&#x2F; ],</span><br><span class="line">    use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ul>
<li>对象：匹配所有属性，每个属性都有一个定义行为</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: &#123;</span><br><span class="line">      test: &#x2F;\.vue$&#x2F;</span><br><span class="line">    &#125;,</span><br><span class="line">    use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>当webpack加载到不支持的文件，在执行<code>module.build</code>时会到<code>module.rule</code>中找可以解析此文件的<code>loader</code>。当在<code>webpack.config.js</code>中配置了此loader，webpack就会利用以上的形式找到它，以此来加载此文件。</p>
<h5 id="Rule-issuer"><a href="#Rule-issuer" class="headerlink" title="Rule.issuer"></a>Rule.issuer</h5><blockquote>
<p>用来与发布者的request对应的模块项匹配，其用法与<code>Rule.test</code>一致</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;只需要用 vue-loader 加载 sy_webpack-config&#x2F;src&#x2F;index.js 下的 notice-webpack.vue 文件</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">issuer: [</span><br><span class="line">    &#x2F;&#x2F; 发布者 issuer 是 index.js 或 notice-webpack.vue 的时候才让加载器加载</span><br><span class="line">    path.resolve(__dirname,&quot;.&#x2F;src&#x2F;index.js&quot;),</span><br><span class="line">    path.resolve(__dirname,&quot;.&#x2F;src&#x2F;notice-webpack.vue&quot;),</span><br><span class="line">],</span><br><span class="line">use: &#39;vue-loader&#39;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Rule-resourceQuery"><a href="#Rule-resourceQuery" class="headerlink" title="Rule.resourceQuery"></a>Rule.resourceQuery</h5><blockquote>
<p>webpack 加载获取加载器的时候，会用当前模块来匹配<code>resourceQuery</code>条件，表示一个请求资源的参数，用法跟<code>Rule.test</code>一样。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当 resourceQuery 有值的时候才匹配 vue-loader</span><br><span class="line">&#123;</span><br><span class="line">     test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">     use: &#39;vue-loader&#39;,</span><br><span class="line">     resourceQuery: (query)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(query)</span><br><span class="line">        return true;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;,</span><br><span class="line">&#x2F;&#x2F;同时修改入口文件</span><br><span class="line">import noticewebpack from &#39;.&#x2F;notice-webpack.vue?inline&#39;; &#x2F;&#x2F; 导入noticewebpack组件，inline即为resourceQuery</span><br></pre></td></tr></table></figure>

<h5 id="Rule-use"><a href="#Rule-use" class="headerlink" title="Rule.use"></a>Rule.use</h5><blockquote>
<p>利用<code>use</code>指定当前加载器</p>
</blockquote>
<p>可配置的值与<code>Rule.test</code>一致</p>
<ul>
<li><p>字符串形式</p>
</li>
<li><p>对象形式：当loader需要传递参数时使用</p>
</li>
<li><p>数组形式：当需要多个loader加载时使用</p>
</li>
<li><p>方法形式：当需要获取某些信息当作参数时使用</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: &#x2F;\.vue$&#x2F;,</span><br><span class="line">   use: (info)&#x3D;&gt;[</span><br><span class="line">     &#123;</span><br><span class="line">       loader: &#39;vue-loader&#39;, &#x2F;&#x2F; 使用 vue-loader 去加载</span><br><span class="line">          options: &#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>其中，info可以写为：</p>
<ul>
<li><p>compiler：当前webpack的compiler对象</p>
</li>
<li><p>issuer：当前模块发布者的路径</p>
</li>
<li><p>realResource：当前module的绝对路径</p>
</li>
<li><p>resource：当前module的路径</p>
</li>
</ul>
<h5 id="Rule-loader-amp-Rule-options"><a href="#Rule-loader-amp-Rule-options" class="headerlink" title="Rule.loader &amp; Rule.options"></a>Rule.loader &amp; Rule.options</h5><blockquote>
<p>配置<code>Rule.loader</code>是<code>Rule.use: [ { loader } ]</code>的简写。</p>
</blockquote>
<p>参数<code>Rule.use</code>跟<code>Rule.loader</code>关系就像是<code>Rule.test</code>跟<code>Rule.resource</code>关系一样</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack-配置参数解析（上）</title>
    <url>/post/467442022.html</url>
    <content><![CDATA[<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><blockquote>
<p>入口对象<code>entry</code>用于webpack查找开始构建<code>bundle</code>的地方，配置方法有多种形式</p>
</blockquote>
<p>默认为：<code>./src/index.js</code></p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    &#x2F;&#x2F;配置入口</span><br><span class="line">    &#x2F;&#x2F;字符串形式</span><br><span class="line">    entry: &quot;.&#x2F;src&#x2F;index.js&quot;,    </span><br><span class="line">    &#x2F;&#x2F;字符串数组形式</span><br><span class="line">    entry: [&#39;.&#x2F;src&#x2F;index.js&#39;],</span><br><span class="line">    &#x2F;&#x2F;对象形式</span><br><span class="line">    entry: &#123;</span><br><span class="line">         main: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">    &#125;,  </span><br><span class="line">    &#x2F;&#x2F;多入口形式</span><br><span class="line">    entry:&#123;                  </span><br><span class="line">         main: &#39;.&#x2F;src&#x2F;index.js&#39;,</span><br><span class="line">         main2: &#39;.&#x2F;src&#x2F;index2.js&#39;,</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;动态入口</span><br><span class="line">    &#x2F;* 当需要根据请求来编译文件做到懒加载打包输出，则使用动态入口*&#x2F;</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt; resolve(&#39;.&#x2F;src&#x2F;index.js&#39;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><blockquote>
<p>上下文<code>context</code>配置webpack的基础目录，用于从配置中解析入口起点和<code>loader</code></p>
</blockquote>
<p>默认为：<code>process.cwd()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><blockquote>
<p>选项<code>mode</code>告知webpack使用相应环境。可能的值：<code>none</code>、<code>development</code>、<code>production</code>（默认）</p>
</blockquote>
<h3 id="生产配置Production"><a href="#生产配置Production" class="headerlink" title="生产配置Production"></a>生产配置Production</h3><blockquote>
<p>生产模式用于项目上线发布，打包后生成的dist/main.js文件无法被识别，压缩代码，关闭输出<code>Console</code>、<code>Debugger</code>，设置<code>process.env.NODE_ENV</code>为<code>production</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;production&#39;,&#x2F;&#x2F;默认模式</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包后dist/main.js文件：</p>
<p><img src="https://i.loli.net/2021/05/24/6xeFbakX4DQlypZ.png" alt="production模式"></p>
<h3 id="开发配置Development"><a href="#开发配置Development" class="headerlink" title="开发配置Development"></a>开发配置Development</h3><blockquote>
<p>开发模式用于日常开发调试，打包后生成的dist/main.js文件代码清晰并添加了<code>sourcemap</code>，不考虑加载速度等，设置<code>process.env.NODE_ENV</code>为<code>development</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;development&#39;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包后dist/main.js文件：</p>
<p><img src="https://i.loli.net/2021/05/24/IgRNyl3fV61iocu.png" alt="development模式"></p>
<h3 id="不使用webpack默认mode配置None"><a href="#不使用webpack默认mode配置None" class="headerlink" title="不使用webpack默认mode配置None"></a>不使用webpack默认mode配置None</h3><blockquote>
<p>将mode设置为none则不实用webpack的默认mode配置，生成的dist/main.js文件与development模式相比少了<code>sourcemap</code>的生成</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;none&#39;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打包后dist/main.js文件：</p>
<p><img src="https://i.loli.net/2021/05/24/IgRNyl3fV61iocu.png" alt="development模式"></p>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><blockquote>
<p>配置output包含一组选项，指示webpack如何输出及在哪输出<code>bundle</code>、<code>asset</code>和其他导报webpack载入的内容</p>
</blockquote>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><blockquote>
<p>path为文件输出目录，对应一个绝对路径</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;production&#39;,&#x2F;&#x2F;默认模式</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,&#39;.&#x2F;lib&#39;),&#x2F;&#x2F;修改输出路径为 “webpack_demo&#x2F;lib”</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="pathinfo"><a href="#pathinfo" class="headerlink" title="pathinfo"></a>pathinfo</h3><blockquote>
<p>pathinfo告知webpack在<code>bundle</code>中引入所包含模块信息的相关注释，在<code>development</code>模式中默认为<code>true</code>，在<code>production</code>模式中默认为<code>false</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;production&#39;,&#x2F;&#x2F;默认模式</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,&#39;.&#x2F;lib&#39;),&#x2F;&#x2F;修改输出路径为 “webpack_demo&#x2F;lib”</span><br><span class="line">        pathinfo: true,&#x2F;&#x2F;打开pathinfo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注释为：</p>
<p><img src="https://i.loli.net/2021/05/24/yvkopAL8uqJRxHO.png" alt="pathinfo"></p>
<p>在分析<code>bundle</code>包时查看此注释可以了解当前<code>module</code>的依赖组成</p>
<h3 id="publicPath"><a href="#publicPath" class="headerlink" title="publicPath"></a>publicPath</h3><blockquote>
<p>当需要按需加载或加载外部资源，使用<code>publicPath</code>指定外部资源的路径</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  mode: &#39;development&#39;, &#x2F;&#x2F; 测试环境</span><br><span class="line">  context: path.resolve(__dirname, &#39;.&#x2F;src&#39;), &#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">  entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt; resolve(&#39;.&#x2F;index.js&#39;)), &#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;.&#x2F;lib&#39;), &#x2F;&#x2F; 修改输出路径为 “sy_webpack-config&#x2F;lib”</span><br><span class="line">    publicPath: &#39;.&#x2F;lib&#x2F;&#39;, &#x2F;&#x2F; 配置公共路径</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以在入口文件使用运行时的变量__webpack_public_path__指定</span><br><span class="line">document.write(&#39;hello webpack！&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 动态设置 webpack 的 publicpath 路径</span><br><span class="line">__webpack_public_path__ &#x3D; &#39;.&#x2F;lib&#x2F;&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 按需引入 girl.js 文件</span><br><span class="line">import(&#39;.&#x2F;demo&#39;).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  result.default(); &#x2F;&#x2F; 满足 demo 的需求</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h3><blockquote>
<p>选项filename用于修改输出文件的名称</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    context: path.resolve(__dirname,&#39;.&#x2F;src&#39;),&#x2F;&#x2F; context 上下文指向 src 目录</span><br><span class="line">    entry: () &#x3D;&gt; new Promise((resolve) &#x3D;&gt;resolve(&#39;.&#x2F;index.js&#39;)),&#x2F;&#x2F; 利用方法返回一个异步的入口</span><br><span class="line">    mode: &#39;production&#39;,&#x2F;&#x2F;默认模式</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname,&#39;.&#x2F;lib&#39;),&#x2F;&#x2F;修改输出路径为 “webpack_demo&#x2F;lib”</span><br><span class="line">        pathinfo: true,&#x2F;&#x2F;打开pathinfo</span><br><span class="line">        filename: &#39;oubput.js&#39;,&#x2F;&#x2F;单入口文件配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;多入口文件配置</span><br><span class="line">filename: &#39;[name].js&#39;,&#x2F;&#x2F;输出文件为main1.js，main2.js，name默认为当前module文件名</span><br></pre></td></tr></table></figure>

<h3 id="chunkFilename"><a href="#chunkFilename" class="headerlink" title="chunkFilename"></a>chunkFilename</h3><blockquote>
<p>选项<code>chunkFilename</code>决定非入口chunk文件的名称，不能配置为方法，其他与filename一致</p>
</blockquote>
<h3 id="library"><a href="#library" class="headerlink" title="library"></a>library</h3><blockquote>
<p>用于封装自己的函数库或ui库或二次封装并暴露给外界使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  mode: &#39;production&#39;,</span><br><span class="line">  context: path.resolve(__dirname, &#39;.&#39;),</span><br><span class="line">  entry: &#39;.&#x2F;index.js&#39;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &#39;.&#x2F;lib&#39;),</span><br><span class="line">    library: &#39;webpackSay&#39;,</span><br><span class="line">    libraryExport: &#39;default&#39;,</span><br><span class="line">    libraryTarget: &#39;var&#39;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>library：封装后打包的名字</p>
</li>
<li><p>libraryTarget: 配置暴露给外界的方式，即输出的格式</p>
<ul>
<li><p>生成一个变量</p>
<ul>
<li><p>var：libraryTarget的默认值，将库入口的返回值生成一个变量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输出main.js为</span><br><span class="line">var webpackSay&#x3D;function(e)&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>assign：产生一个隐含的全局变量。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpackSay&#x3D;function(e)&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>生成对象的属性 </p>
<ul>
<li><p>this：将生成的变量赋值给this对象，作为它的属性</p>
</li>
<li><p>window：返回值赋值为window的一个属性</p>
</li>
<li><p>global：返回值赋值给global的一个属性</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this[&#39;webpackSay&#39;]&#x3D;function(e)&#123;...&#125;</span><br><span class="line">window[&#39;webpackSay&#39;]&#x3D;function(e)&#123;...&#125;</span><br><span class="line">global[&#39;webpackSay&#39;]&#x3D;function(e)&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>按不同模块生成</p>
<ul>
<li><p>commonjs/commonjs2：暴露为CommonJS模块</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;commonjs</span><br><span class="line">exports[&#39;webpackSay&#39;] &#x3D; function(e)&#123; ... &#125;</span><br><span class="line">&#x2F;&#x2F;commonjs2，该方式会直接忽略library的值</span><br><span class="line">module.exports &#x3D; function(e)&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>amd：暴露为amd模块，需要指定library</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">define(&#39;webpackSay&#39;, [], function()&#123;</span><br><span class="line">    return function(e)&#123; ... &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>umd：暴露为所有模块定义下都可运行的方式，需要指定library</p>
</li>
</ul>
</li>
<li><p>生成为JSONP：将返回值封装到一个JSONP容器中</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpackSay(function(e)&#123; ... &#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>libraryExport：默认要导出模块的哪个部分</p>
</li>
</ul>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack源码分析-编译的seal和emit阶段</title>
    <url>/post/769148052.html</url>
    <content><![CDATA[<blockquote>
<p>webpack的编译分几个阶段进行，分别为创建对象阶段run、解析获取module阶段make、module分包阶段seal、输出打包后文件阶段emit</p>
</blockquote>
<h2 id="seal阶段"><a href="#seal阶段" class="headerlink" title="seal阶段"></a>seal阶段</h2><blockquote>
<p>seal阶段主要对<code>modules</code>做分拣、拆包、封装。</p>
</blockquote>
<p>查看文件<code>/node_modules/webpack/lib/Compiler.js</code>第675行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; make 阶段开始</span><br><span class="line">    this.hooks.make.callAsync(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">        if (err) return callback(err);</span><br><span class="line">        &#x2F;&#x2F; make 阶段结束</span><br><span class="line">        compilation.finish(err &#x3D;&gt; &#123;</span><br><span class="line">            if (err) return callback(err);</span><br><span class="line">            &#x2F;&#x2F; seal 阶段开始</span><br><span class="line">            compilation.seal(err &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="分包优化"><a href="#分包优化" class="headerlink" title="分包优化"></a>分包优化</h3><p>查看文件<code>/node_modules/webpack/lib/Compilation.js</code>中第1283行seal方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">seal(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 开始进行分包优化操作</span><br><span class="line">    this.hooks.optimize.call();</span><br><span class="line">    &#x2F;&#x2F; 一系列的分包优化操作...</span><br><span class="line">    while (</span><br><span class="line">        this.hooks.optimizeModulesBasic.call(this.modules) ||</span><br><span class="line">        this.hooks.optimizeModules.call(this.modules) ||</span><br><span class="line">        this.hooks.optimizeModulesAdvanced.call(this.modules)</span><br><span class="line">    ) &#123;</span><br><span class="line">        &#x2F;* empty *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    this.hooks.afterOptimizeModules.call(this.modules);</span><br><span class="line"></span><br><span class="line">    while (</span><br><span class="line">        this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) ||</span><br><span class="line">        this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) ||</span><br><span class="line">        this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)</span><br><span class="line">    ) &#123;</span><br><span class="line">        &#x2F;* empty *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">    this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);</span><br><span class="line"></span><br><span class="line">    this.hooks.optimizeTree.callAsync(this.chunks, this.modules, err &#x3D;&gt; &#123;</span><br><span class="line">        if (err) &#123;</span><br><span class="line">            return callback(err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.hooks.afterOptimizeTree.call(this.chunks, this.modules);</span><br><span class="line"></span><br><span class="line">        while (</span><br><span class="line">            this.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) ||</span><br><span class="line">            this.hooks.optimizeChunkModules.call(this.chunks, this.modules) ||</span><br><span class="line">            this.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules)</span><br><span class="line">        ) &#123;</span><br><span class="line">            &#x2F;* empty *&#x2F;</span><br><span class="line">        &#125;</span><br><span class="line">        this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);</span><br><span class="line"></span><br><span class="line">        const shouldRecord &#x3D; this.hooks.shouldRecord.call() !&#x3D;&#x3D; false;</span><br><span class="line"></span><br><span class="line">        this.hooks.reviveModules.call(this.modules, this.records);</span><br><span class="line">        this.hooks.optimizeModuleOrder.call(this.modules);</span><br><span class="line">        this.hooks.advancedOptimizeModuleOrder.call(this.modules);</span><br><span class="line">        this.hooks.beforeModuleIds.call(this.modules);</span><br><span class="line">        this.hooks.moduleIds.call(this.modules);</span><br><span class="line">        this.applyModuleIds();</span><br><span class="line">        this.hooks.optimizeModuleIds.call(this.modules);</span><br><span class="line">        this.hooks.afterOptimizeModuleIds.call(this.modules);</span><br><span class="line"></span><br><span class="line">        this.sortItemsWithModuleIds();</span><br><span class="line"></span><br><span class="line">        this.hooks.reviveChunks.call(this.chunks, this.records);</span><br><span class="line">        this.hooks.optimizeChunkOrder.call(this.chunks);</span><br><span class="line">        this.hooks.beforeChunkIds.call(this.chunks);</span><br><span class="line">        this.applyChunkIds();</span><br><span class="line">        this.hooks.optimizeChunkIds.call(this.chunks);</span><br><span class="line">        this.hooks.afterOptimizeChunkIds.call(this.chunks);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="compilation调用createModuleAssets方法"><a href="#compilation调用createModuleAssets方法" class="headerlink" title="compilation调用createModuleAssets方法"></a>compilation调用createModuleAssets方法</h3><p>webpack调用<code>createModuleAssets</code>方法来提取资产文件最后输出到<code>dist</code>目录中，如css中引入的图片等，<code>css-loader</code>会将图片当成一个个<code>module</code>，用<code>url-loader</code>或<code>file-loader</code>提取出来当成css模块中资产文件输出到dist</p>
<h3 id="compilation调用createChunkAssets方法"><a href="#compilation调用createChunkAssets方法" class="headerlink" title="compilation调用createChunkAssets方法"></a>compilation调用createChunkAssets方法</h3><p>查看文件<code>/node_modules/webpack/lib/Compilation.js</code>中第1395行seal方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">seal(callback) &#123;</span><br><span class="line">        &#x2F;&#x2F; 分包优化操作</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 开始分拣 module 中的资产文件</span><br><span class="line">        this.createModuleAssets();</span><br><span class="line">        ...</span><br><span class="line">        if (this.hooks.shouldGenerateChunkAssets.call() !&#x3D;&#x3D; false) &#123;</span><br><span class="line">            this.hooks.beforeChunkAssets.call();</span><br><span class="line">            &#x2F;&#x2F; 开始分拣当前 chunk 中的资产文件</span><br><span class="line">            this.createChunkAssets();</span><br><span class="line">            ...</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>createChunkAssets</code>用来分拣<code>dist/main.js</code>中的资产文件</p>
<h3 id="判断Chunk是否包含runtime代码"><a href="#判断Chunk是否包含runtime代码" class="headerlink" title="判断Chunk是否包含runtime代码"></a>判断Chunk是否包含runtime代码</h3><p>查看文件<code>/node_modules/webpack/lib/Compilation.js</code>中第2111行createChunkAssets方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">createChunkAssets() &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历所有的 chunk</span><br><span class="line">    for (let i &#x3D; 0; i &lt; this.chunks.length; i++) &#123;</span><br><span class="line">        const chunk &#x3D; this.chunks[i];</span><br><span class="line">        chunk.files &#x3D; [];</span><br><span class="line">        let source;</span><br><span class="line">        let file;</span><br><span class="line">        let filenameTemplate;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 判断 chunk 是否包含 runtime 代码并获取 chunk 模版</span><br><span class="line">            const template &#x3D; chunk.hasRuntime()</span><br><span class="line">                ? this.mainTemplate</span><br><span class="line">                : this.chunkTemplate;</span><br><span class="line">            &#x2F;&#x2F; 调用 chunk 模版的 getRenderManifest 方法获取当前 chunk 的所有资产文件</span><br><span class="line">            const manifest &#x3D; template.getRenderManifest(&#123;</span><br><span class="line">                chunk,</span><br><span class="line">                hash: this.hash,</span><br><span class="line">                fullHash: this.fullHash,</span><br><span class="line">                outputOptions,</span><br><span class="line">                moduleTemplates: this.moduleTemplates,</span><br><span class="line">                dependencyTemplates: this.dependencyTemplates</span><br><span class="line">            &#125;); &#x2F;&#x2F; [&#123; render(), filenameTemplate, pathOptions, identifier, hash &#125;]</span><br><span class="line">            &#x2F;&#x2F; 遍历所有的资产清单</span><br><span class="line">            for (const fileManifest of manifest) &#123;</span><br><span class="line">                ...</span><br><span class="line">                &#x2F;&#x2F; 开始执行渲染，获取最后能被浏览器识别的代码</span><br><span class="line">                source &#x3D; fileManifest.render();</span><br><span class="line">                ...</span><br><span class="line">                &#x2F;&#x2F; 开始提交最终打包完毕的资产信息</span><br><span class="line">                this.emitAsset(file, source, assetInfo);</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack判断<code>chunk</code>是否是<code>runtime</code>，即webpack启动代码（最终能被浏览器识别的<code>import</code>、<code>require</code>、<code>export</code>，默认为<code>webpackjsonp</code>）。</p>
<p>如果包含<code>runtime</code>则用<code>mainTemplate</code>生成最终代码，不包含则用<code>chunkTemplate</code>生成。</p>
<p>二者区别仅为是否包含<code>runtime</code>代码</p>
<p>至此，<code>seal</code>阶段结束。</p>
<h2 id="emit阶段"><a href="#emit阶段" class="headerlink" title="emit阶段"></a>emit阶段</h2><blockquote>
<p>emit阶段根据配置输出文件</p>
</blockquote>
<p>seal阶段结束，代码回到<code>/node_modules/webpack/lib/Compiler.js</code>660行<code>run</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile(callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; seal 阶段开始</span><br><span class="line">    compilation.seal(err &#x3D;&gt; &#123;</span><br><span class="line">        if (err) return callback(err);</span><br><span class="line">        &#x2F;&#x2F; seal 阶段结束</span><br><span class="line">        this.hooks.afterCompile.callAsync(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">            if (err) return callback(err);</span><br><span class="line">            &#x2F;&#x2F; 回到 run方法</span><br><span class="line">            return callback(null, compilation);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;run方法</span><br><span class="line">run(callback) &#123;const onCompiled &#x3D; (err, compilation) &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; seal 结束后回到了 run 方法，并准备执行 emitAssets</span><br><span class="line">        this.emitAssets(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="compiler-emitAssets输出打包过后文件"><a href="#compiler-emitAssets输出打包过后文件" class="headerlink" title="compiler.emitAssets输出打包过后文件"></a>compiler.emitAssets输出打包过后文件</h3><p>查看文件<code>/node_modules/webpack/lib/Compiler.js</code>的<code>emitAssets</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">emitAssets(compilation, callback) &#123;</span><br><span class="line">    let outputPath; &#x2F;&#x2F; 输出目录地址</span><br><span class="line">    const emitFiles &#x3D; err &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 遍历所有的资产文件</span><br><span class="line">        asyncLib.forEachLimit(</span><br><span class="line">            compilation.getAssets(),</span><br><span class="line">            15,</span><br><span class="line">            (&#123; name: file, source &#125;, callback) &#x3D;&gt; &#123;</span><br><span class="line">                let targetFile &#x3D; file;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 使用 webpack 的文件输出系统开始写文件到 outputPath</span><br><span class="line">            this.outputFileSystem.writeFile(targetPath, content, err &#x3D;&gt; &#123;</span><br><span class="line">                if (err) return callback(err);</span><br><span class="line">                this.hooks.assetEmitted.callAsync(file, content, callback);</span><br><span class="line">            &#125;);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至此，<code>emit</code>阶段结束</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack源码分析-编译的run和make阶段</title>
    <url>/post/2637109507.html</url>
    <content><![CDATA[<blockquote>
<p>webpack的编译分几个阶段进行，分别为创建对象阶段run、解析获取module阶段make、module分包阶段seal、输出打包后文件阶段emit</p>
</blockquote>
<h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul>
<li><p>module：webpack中用<code>require</code>或<code>import</code>引入的都叫module</p>
</li>
<li><p>chunk：module的一个集合，入口文件就算一个chunk</p>
</li>
<li><p>dependency：包含一个模块的基本信息，用来创建<code>module</code></p>
</li>
<li><p>moduleFactory：创建<code>module</code>对象的工厂类</p>
</li>
<li><p>assets：最后输出的资产文件</p>
</li>
</ul>
<a id="more"></a>

<h2 id="webpack流程图"><a href="#webpack流程图" class="headerlink" title="webpack流程图"></a>webpack流程图</h2><p><img src="https://i.loli.net/2021/05/22/OtqX5seK1fT6guZ.png" alt="webpack流程图"></p>
<h2 id="执行compiler-run方法"><a href="#执行compiler-run方法" class="headerlink" title="执行compiler.run方法"></a>执行compiler.run方法</h2><p>查看文件<code>node_modules/webpack/lib/Compiler.js</code>第247行</p>
<!--more-->

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    webpack 开始工作</span><br><span class="line">*&#x2F;</span><br><span class="line">run(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 开始执行 beforerun 钩子函数</span><br><span class="line">    this.hooks.beforeRun.callAsync(this, err &#x3D;&gt; &#123;</span><br><span class="line">        if (err) return finalCallback(err);</span><br><span class="line">        &#x2F;&#x2F; 开始执行 run 钩子函数</span><br><span class="line">        this.hooks.run.callAsync(this, err &#x3D;&gt; &#123;</span><br><span class="line">            if (err) return finalCallback(err);</span><br><span class="line">            &#x2F;&#x2F; 开始读取记录</span><br><span class="line">            this.readRecords(err &#x3D;&gt; &#123;</span><br><span class="line">                if (err) return finalCallback(err);</span><br><span class="line">                &#x2F;&#x2F; 开始编译</span><br><span class="line">                this.compile(onCompiled);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>run</code>最后执行了<code>compile</code>方法，即在<code>compiler</code>方法执行时，说明<code>run</code>阶段已经开始了。</p>
<h2 id="compile方法定义"><a href="#compile方法定义" class="headerlink" title="compile方法定义"></a>compile方法定义</h2><p>在文件660行查看<code>compile</code>方法的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    webpack 开始编译</span><br><span class="line">*&#x2F;</span><br><span class="line">compile(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建编译器参数</span><br><span class="line">    const params &#x3D; this.newCompilationParams();</span><br><span class="line">    &#x2F;&#x2F; 调用 beforeCompile 钩子函数</span><br><span class="line">    this.hooks.beforeCompile.callAsync(params, err &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用 compile 钩子函数</span><br><span class="line">        this.hooks.compile.call(params);</span><br><span class="line">        &#x2F;&#x2F; 创建编译器对象</span><br><span class="line">        const compilation &#x3D; this.newCompilation(params);</span><br><span class="line">        &#x2F;&#x2F; 调用 compiler 的 make 钩子函数</span><br><span class="line">        this.hooks.make.callAsync(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">            if (err) return callback(err);</span><br><span class="line">            &#x2F;&#x2F; 调用 finishModules 钩子函数</span><br><span class="line">            compilation.finish(err &#x3D;&gt; &#123;</span><br><span class="line">                if (err) return callback(err);</span><br><span class="line">                &#x2F;&#x2F; 开始对所有的 modules 进行封装</span><br><span class="line">                compilation.seal(err &#x3D;&gt; &#123;</span><br><span class="line">                    if (err) return callback(err);</span><br><span class="line">                    &#x2F;&#x2F; 调用 afterCompile 钩子函数</span><br><span class="line">                    this.hooks.afterCompile.callAsync(compilation, err &#x3D;&gt; &#123;</span><br><span class="line">                        if (err) return callback(err);</span><br><span class="line">                        &#x2F;&#x2F; webpack 编译结束</span><br><span class="line">                        return callback(null, compilation);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="run阶段"><a href="#run阶段" class="headerlink" title="run阶段"></a>run阶段</h2><blockquote>
<p>由<code>compiler.run</code>方法得知<code>compiler</code>方法执行时，说明<code>run</code>阶段已经开始</p>
</blockquote>
<h3 id="创建NormalModuleFactory和ContextModuleFactory"><a href="#创建NormalModuleFactory和ContextModuleFactory" class="headerlink" title="创建NormalModuleFactory和ContextModuleFactory"></a>创建NormalModuleFactory和ContextModuleFactory</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    webpack 开始编译</span><br><span class="line">*&#x2F;</span><br><span class="line">compile(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建编译器参数</span><br><span class="line">    const params &#x3D; this.newCompilationParams();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">    使用方法newCompilationParams()</span><br><span class="line">    创建 NormalModuleFactory 和 ContextModuleFactory</span><br><span class="line">*&#x2F;</span><br><span class="line">newCompilationParams() &#123;</span><br><span class="line">    const params &#x3D; &#123;</span><br><span class="line">        normalModuleFactory: this.createNormalModuleFactory(), &#x2F;&#x2F; NormalModule 的工厂类</span><br><span class="line">        contextModuleFactory: this.createContextModuleFactory(), &#x2F;&#x2F; ContextModules 的工厂类</span><br><span class="line">        compilationDependencies: new Set()</span><br><span class="line">    &#125;;</span><br><span class="line">    return params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建Compilation对象"><a href="#创建Compilation对象" class="headerlink" title="创建Compilation对象"></a>创建Compilation对象</h3><blockquote>
<p>对象<code>Compilation</code>对象是webpack的编译器核心对象，被<code>Compiler</code>用来创建新的编译或构建。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    webpack 开始编译</span><br><span class="line">*&#x2F;</span><br><span class="line">compile(callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建编译器参数</span><br><span class="line">    const params &#x3D; this.newCompilationParams();</span><br><span class="line">    &#x2F;&#x2F; 调用 beforeCompile 钩子函数</span><br><span class="line">    this.hooks.beforeCompile.callAsync(params, err &#x3D;&gt; &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用 compile 钩子函数</span><br><span class="line">        this.hooks.compile.call(params);</span><br><span class="line">        &#x2F;&#x2F; 创建编译器对象</span><br><span class="line">        const compilation &#x3D; this.newCompilation(params);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">    创建 Compilation 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">newCompilation(params) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 Compilation 对象</span><br><span class="line">    const compilation &#x3D; this.createCompilation();</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 调用 thisCompilation 钩子函数</span><br><span class="line">    this.hooks.thisCompilation.call(compilation, params);</span><br><span class="line">    &#x2F;&#x2F; 调用 compilation 钩子函数</span><br><span class="line">    this.hooks.compilation.call(compilation, params);</span><br><span class="line">    return compilation;</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;**</span><br><span class="line">     创建并返回 Compilation 对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">createCompilation() &#123;</span><br><span class="line">    return new Compilation(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，webpack的<code>run</code>阶段结束</p>
<h2 id="make阶段"><a href="#make阶段" class="headerlink" title="make阶段"></a>make阶段</h2><p>由<code>compile</code>方法得知，<code>make</code>阶段开始调用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 调用 compiler 的 make 钩子函数</span><br><span class="line">this.hooks.make.callAsync(compilation, err &#x3D;&gt; &#123;</span><br></pre></td></tr></table></figure>

<p>在初始化过程中得知，钩子函数<code>make</code>在<code>SingleEntryPlugin</code>处被监听，等待make操作的执行。</p>
<h3 id="添加入口文件entry"><a href="#添加入口文件entry" class="headerlink" title="添加入口文件entry"></a>添加入口文件entry</h3><p>查看文件<code>node_modules/webpack/lib/SingleEntryPlugin.js</code>第46行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 监听 compiler 对象的 make 操作</span><br><span class="line">compiler.hooks.make.tapAsync(&#39;SingleEntryPlugin&#39;, (compilation, callback) &#x3D;&gt; &#123;</span><br><span class="line">  const &#123; entry, name, context &#125; &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 创建一个 dependency</span><br><span class="line">  const dep &#x3D; SingleEntryPlugin.createDependency(entry, name);</span><br><span class="line">  &#x2F;&#x2F;添加 entry（入口），并将 dependency 添加到 compilation 对象</span><br><span class="line">  compilation.addEntry(context, dep, name, callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>查看文件<code>node_modules/webpack/lib/Compilation.js</code>第1142行<code>addEntry</code>方法的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">addEntry(context, entry, name, callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; context：默认是我们的工程目录</span><br><span class="line">    &#x2F;&#x2F; entry：是包含工程目录中的 “&#x2F;src&#x2F;index.js” 文件的 “dependency” 对象</span><br><span class="line">    &#x2F;&#x2F; name：默认是 “main”</span><br><span class="line">    this._addModuleChain( &#x2F;&#x2F; 通过 dependency 创建 module 并添加至 compilation 对象</span><br><span class="line">        context,</span><br><span class="line">        entry,</span><br><span class="line">        module &#x3D;&gt; &#123;</span><br><span class="line">            this.entries.push(module);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err, module) &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 成功后回到 SingleEntryPlugin 插件</span><br><span class="line">            return callback(null, module);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>_addModuleChain</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    根据 dependency 添加 module 对象至 compilation 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">_addModuleChain(context, dependency, onModule, callback) &#123;</span><br><span class="line">    const Dep &#x3D; &#x2F;** @type &#123;DepConstructor&#125; *&#x2F; (dependency.constructor);</span><br><span class="line">    &#x2F;&#x2F; 获取模块工厂对象</span><br><span class="line">    const moduleFactory &#x3D; this.dependencyFactories.get(Dep);</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 通过模块工厂创建对应的 module 对象</span><br><span class="line">        moduleFactory.create(</span><br><span class="line">            &#123;</span><br><span class="line">                contextInfo: &#123;</span><br><span class="line">                    issuer: &quot;&quot;,</span><br><span class="line">                    compiler: this.compiler.name</span><br><span class="line">                &#125;,</span><br><span class="line">                context: context,</span><br><span class="line">                dependencies: [dependency]</span><br><span class="line">            &#125;,</span><br><span class="line">            (err, module) &#x3D;&gt; &#123;</span><br><span class="line">                ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用<code>moduleFactory</code>的<code>create</code>方法创建<code>module</code>对象</p>
<p>若没有定义<code>moduleFactory</code>，则webpack默认使用<code>NormalModuleFactory</code>创建<code>NormalModule</code></p>
<h3 id="触发ModuleFactory的create方法"><a href="#触发ModuleFactory的create方法" class="headerlink" title="触发ModuleFactory的create方法"></a>触发ModuleFactory的create方法</h3><p>之前的基础用法demo中没有自定义<code>module</code>和<code>ModuleFactory</code>，故webpack使用<code>NormalModuleFactory</code>的<code>create</code>方法创建，查看文件<code>/node_modules/webpack/lib/NormalModuleFactory.js</code>的373行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    创建 NormalModule 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">create(data, callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 dependencies</span><br><span class="line">    const dependencies &#x3D; data.dependencies;</span><br><span class="line">    &#x2F;&#x2F; 获取上下文目录</span><br><span class="line">    const context &#x3D; data.context || this.context;</span><br><span class="line">    &#x2F;&#x2F; 获取 dependency 的文件地址，也就是“项目名&#x2F;src&#x2F;index.js”</span><br><span class="line">    const request &#x3D; dependencies[0].request;</span><br><span class="line">    &#x2F;&#x2F; 执行 beforeResolve 钩子函数</span><br><span class="line">    this.hooks.beforeResolve.callAsync(</span><br><span class="line">        &#123;</span><br><span class="line">            contextInfo,</span><br><span class="line">            resolveOptions,</span><br><span class="line">            context,</span><br><span class="line">            request,</span><br><span class="line">            dependencies</span><br><span class="line">        &#125;,</span><br><span class="line">        (err, result) &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="触发ModuleFactory的resolver方法"><a href="#触发ModuleFactory的resolver方法" class="headerlink" title="触发ModuleFactory的resolver方法"></a>触发ModuleFactory的resolver方法</h3><blockquote>
<p>方法<code>resolver</code>负责根据传入的<code>dependency</code>对象获取模块中的基本信息，根据这些信息返回模块的<code>loaders</code>(能处理当前<code>module</code>的一个loader集合)、<code>hash值</code>、<code>query</code>(请求参数)等，用于构建<code>module</code>对象的信息，并<code>new</code>一个<code>NormalModule</code>对象</p>
</blockquote>
<p>查看文件<code>/node_modules/webpack/lib/NormalModuleFactory.js</code>的123行中<code>resolver</code>方法的定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.hooks.factory.tap(&quot;NormalModuleFactory&quot;, () &#x3D;&gt; (result, callback) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用 resolver 钩子函数获取 resolver 方法</span><br><span class="line">    let resolver &#x3D; this.hooks.resolver.call(null);</span><br><span class="line">    &#x2F;&#x2F; 直接调用 resolver 方法</span><br><span class="line">    resolver(result, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">        this.hooks.afterResolve.callAsync(data, (err, result) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 调用 createModule 钩子函数</span><br><span class="line">            let createdModule &#x3D; this.hooks.createModule.call(result);</span><br><span class="line">            if (!createdModule) &#123;</span><br><span class="line">                if (!result.request) &#123;</span><br><span class="line">                    return callback(new Error(&quot;Empty dependency (no request)&quot;));</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; 创建 NormalModule 对象</span><br><span class="line">                createdModule &#x3D; new NormalModule(result);</span><br><span class="line">            &#125;</span><br><span class="line">            createdModule &#x3D; this.hooks.module.call(createdModule, result);</span><br><span class="line">            return callback(null, createdModule);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 注册 resolver 钩子函数监听</span><br><span class="line">this.hooks.resolver.tap(&quot;NormalModuleFactory&quot;, () &#x3D;&gt; (data, callback) &#x3D;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 返回 resolve 方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="compilateion触发addModule方法"><a href="#compilateion触发addModule方法" class="headerlink" title="compilateion触发addModule方法"></a>compilateion触发addModule方法</h3><p>工厂<code>NormalModuleFactory</code>创建完<code>NormalModule</code>对象后回到<code>Compilation</code>的<code>_addModuleChain</code>方法，开始添加module</p>
<p>查看文件<code>node_modules/webpack/lib/Compilation.js</code>第1085行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    根据 dependency 添加 module 对象至 compilation 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">_addModuleChain(context, dependency, onModule, callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 添加 module 至 compilation</span><br><span class="line">   const addModuleResult &#x3D; this.addModule(module);</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;*</span><br><span class="line">     添加 module</span><br><span class="line"> *&#x2F;</span><br><span class="line"> addModule(module, cacheGroup) &#123;</span><br><span class="line">    &#x2F;&#x2F; 添加 module 至 compilation 的 modules 集合中</span><br><span class="line">    ...</span><br><span class="line">    this.modules.push(module);</span><br><span class="line">    return &#123;</span><br><span class="line">        module: module,</span><br><span class="line">        issuer: true,</span><br><span class="line">        build: true,</span><br><span class="line">        dependencies: true</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法<code>_addModuleChain</code>直接调用<code>addModule</code>方法将<code>module</code>对象添加到<code>Compilation</code>的<code>module</code>集合中</p>
<h3 id="Compilation触发buildModule构建模块"><a href="#Compilation触发buildModule构建模块" class="headerlink" title="Compilation触发buildModule构建模块"></a>Compilation触发buildModule构建模块</h3><p>查看文件<code>node_modules/webpack/lib/Compilation.js</code>第1111行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    根据 dependency 添加 module 对象至 compilation 对象</span><br><span class="line">*&#x2F;</span><br><span class="line">_addModuleChain(context, dependency, onModule, callback) &#123;</span><br><span class="line">   ...</span><br><span class="line">   &#x2F;&#x2F; 开始构建当前 module 对象</span><br><span class="line">   this.buildModule(module, false, null, null, err &#x3D;&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;*</span><br><span class="line">     构建模块</span><br><span class="line"> *&#x2F;</span><br><span class="line"> buildModule(module, optional, origin, dependencies, thisCallback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接调用 module 的 build 方法构建</span><br><span class="line">    module.build(</span><br><span class="line">        this.options,</span><br><span class="line">        this,</span><br><span class="line">        this.resolverFactory.get(&quot;normal&quot;, module.resolveOptions),</span><br><span class="line">        this.inputFileSystem,</span><br><span class="line">        error &#x3D;&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            &#x2F;&#x2F; 构建完毕后回到再次 _addModuleChain 方法</span><br><span class="line">            return callback();</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由构建模块可看出，<code>buildModule</code>方法执行的是每个<code>module</code>对象的<code>build</code>方法。在基础使用demo中，则为之前创建的<code>NormalModule</code>，查看文件<code>/node_modules/webpack/lib/NormalModule.js</code>文件第427行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build(options, compilation, resolver, fs, callback) &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 直接调用 dobuild 方法</span><br><span class="line">  return this.doBuild(options, compilation, resolver, fs, err &#x3D;&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">    执行所有的 loader 获取返回结果，根据返回结果创建 loader 加载过后的 source 源码</span><br><span class="line">*&#x2F;</span><br><span class="line">doBuild(options, compilation, resolver, fs, callback) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建执行 loader 的上下文对象</span><br><span class="line">    const loaderContext &#x3D; this.createLoaderContext(</span><br><span class="line">        resolver,</span><br><span class="line">        options,</span><br><span class="line">        compilation,</span><br><span class="line">        fs</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F; 执行所有的 loader</span><br><span class="line">    runLoaders(</span><br><span class="line">        &#123;</span><br><span class="line">            resource: this.resource,</span><br><span class="line">            loaders: this.loaders,</span><br><span class="line">            context: loaderContext,</span><br><span class="line">            readResource: fs.readFile.bind(fs)</span><br><span class="line">        &#125;,</span><br><span class="line">        (err, result) &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; 根据返回的结果创建 source 源码对象</span><br><span class="line">            this._source &#x3D; this.createSource(</span><br><span class="line">                this.binary ? asBuffer(source) : asString(source),</span><br><span class="line">                resourceBuffer,</span><br><span class="line">                sourceMap</span><br><span class="line">            );</span><br><span class="line">            this._sourceSize &#x3D; null;</span><br><span class="line">            this._ast &#x3D;</span><br><span class="line">                typeof extraInfo &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp;</span><br><span class="line">                extraInfo !&#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">                extraInfo.webpackAST !&#x3D;&#x3D; undefined</span><br><span class="line">                    ? extraInfo.webpackAST</span><br><span class="line">                    : null;</span><br><span class="line">            &#x2F;&#x2F; 返回到 buildModule 方法</span><br><span class="line">            return callback();</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述<code>doBuild</code>方法中使用的<code>runLoaders</code>方法是单独由第三方库<code>loader-runner</code>提供，用来执行所有的<code>loader</code>并返回执行后的结果。根据此结果创建<code>source</code>对象</p>
<h3 id="执行parse方法解析源码"><a href="#执行parse方法解析源码" class="headerlink" title="执行parse方法解析源码"></a>执行parse方法解析源码</h3><p>查看文件<code>/node_modules/webpack/lib/NormalModule.js</code>文件第482行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build(options, compilation, resolver, fs, callback) &#123;</span><br><span class="line">  ...</span><br><span class="line">  return this.doBuild(options, compilation, resolver, fs, err &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 开始解析 loader 处理过后的源码</span><br><span class="line">    const result &#x3D; this.parser.parse(</span><br><span class="line">        this._ast || this._source.source(),</span><br><span class="line">        &#123;</span><br><span class="line">            current: this,</span><br><span class="line">            module: this,</span><br><span class="line">            compilation: compilation,</span><br><span class="line">            options: options</span><br><span class="line">        &#125;,</span><br><span class="line">        (err, result) &#x3D;&gt; &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                handleParseError(err);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                handleParseResult(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webpack默认支持<code>JSON</code>、<code>JavaScript</code>代码解析，<code>JavaScript</code>解析默认使用<code>Acorn</code>框架，<code>parse</code>方法主要用来解析代码中的模块定义、获取代码中的模块引用、转换alias、转换自定义变量方法等。</p>
<h3 id="addModuleDependencies编译模块中关联的依赖"><a href="#addModuleDependencies编译模块中关联的依赖" class="headerlink" title="addModuleDependencies编译模块中关联的依赖"></a>addModuleDependencies编译模块中关联的依赖</h3><p>解析后，<code>compilation</code>的<code>buildModule</code>结束，开始编译<code>module</code>中关联的依赖，查看文件<code>node_modules/webpack/lib/Compilation.js</code>第1093行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_addModuleChain(context, dependency, onModule, callback) &#123;</span><br><span class="line">   ...</span><br><span class="line">    const afterBuild &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        if (addModuleResult.dependencies) &#123;</span><br><span class="line">            &#x2F;&#x2F;开始编译模块中关联的依赖</span><br><span class="line">            this.processModuleDependencies(module, err &#x3D;&gt; &#123;</span><br><span class="line">                if (err) return callback(err);</span><br><span class="line">                callback(null, module);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return callback(null, module);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processModuleDependencies(module, callback) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F;addModuleDependencies方法用来编译模块中关联的依赖，与_addModuleChain类似</span><br><span class="line">    this.addModuleDependencies(</span><br><span class="line">			module,</span><br><span class="line">			sortedDependencies,</span><br><span class="line">			this.bail,</span><br><span class="line">			null,</span><br><span class="line">			true,</span><br><span class="line">			callback</span><br><span class="line">		);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，webpack的<code>make</code>阶段结束。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack源码分析-初始化过程</title>
    <url>/post/4111585367.html</url>
    <content><![CDATA[<blockquote>
<p>webpack是现代<code>JavaScript</code>应用程序的静态模块打包器。通过递归地构建依赖关系图，将应用程序需要的每个模块打包成一个或多个bundle</p>
</blockquote>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><ol>
<li><p>使用<code>npm init</code>命令初始化工程</p>
</li>
<li><p>在src目录创建入口文件index.js</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import $ from &#39;jquery&#39;; &#x2F;&#x2F; 引入 jquery 第三方库</span><br><span class="line">$(&#39;#app&#39;).text(&#39;hello webpack!&#39;); &#x2F;&#x2F; 使用 jquery 输出 hello webpack</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<ol start="3">
<li><p>使用<code>npm install jquery --registry https://registry.npm.taobao.org</code>安装jquery</p>
</li>
<li><p>使用<code>npm install -D webpack@4.44.1 webpack-cli --registry https://registry.npm.taobao.org</code>安装webpack</p>
</li>
<li><p>使用<code>npx webpack</code>编译打包。可看到目录中生成了<code>dist/main.js</code>文件</p>
</li>
<li><p>创建浏览器入口index.html文件</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;webpack基础用法&lt;&#x2F;title&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 创建挂载点 --&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;!-- 引入入口js文件 --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;.&#x2F;dist&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>可在编译器浏览index.html文件输出的hello webpack</li>
</ol>
<h2 id="webpack-cli"><a href="#webpack-cli" class="headerlink" title="webpack-cli"></a>webpack-cli</h2><p>在基础用法第5步，使用命令<code>npx webpack</code>编译打包，node会自动执行<code>/node_modules/webpack/bin/webpack.js</code>文件，从<code>133行</code>到<code>149行</code>看出<code>webpack</code>是最后交给<code>webpack-cli</code>命令来执行，即执行<code>npx webpack</code>和<code>npx webpack-cli</code>的结果是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 判断是否安装了 webpack-cli，如果没有安装就引导安装，确保存在 webpack-cli</span><br><span class="line">const packageName &#x3D; &#39;webpack-cli&#39;;</span><br><span class="line">&#x2F;&#x2F; 执行 webpack-cli</span><br><span class="line">runCommand(packageManager, installOptions.concat(packageName))</span><br><span class="line">  .then(() &#x3D;&gt; &#123;</span><br><span class="line">    require(packageName); &#x2F;&#x2F; eslint-disable-line</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch((error) &#x3D;&gt; &#123;</span><br><span class="line">    console.error(error);</span><br><span class="line">    process.exitCode &#x3D; 1;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>分析<code>node_modules/webpack-cli/bin/cli.js</code>文件可发现<code>webpack-cli</code>负责接受用户输入的命令，获取自定义配置文件<code>webpack.config,js</code>或<code>webpackfile.js</code>。创建一个webpack编译器对象<code>compiler</code>并执行<code>compiler</code>对象的<code>run</code>方法。</p>
<h2 id="webpack流程图"><a href="#webpack流程图" class="headerlink" title="webpack流程图"></a>webpack流程图</h2><p><img src="https://i.loli.net/2021/05/22/OtqX5seK1fT6guZ.png" alt="webpack流程图"></p>
<h2 id="分析webpack初始化过程"><a href="#分析webpack初始化过程" class="headerlink" title="分析webpack初始化过程"></a>分析webpack初始化过程</h2><p>在<code>node_modules/webpack-cli/bin/cli.js</code>文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">   const webpack &#x3D; require(&quot;webpack&quot;); &#x2F;&#x2F; 引入 webpack</span><br><span class="line">   compiler &#x3D; webpack(options); &#x2F;&#x2F; 创建 webpack 编译器对象 compiler</span><br><span class="line">&#125; catch (err) &#123;......&#125;</span><br></pre></td></tr></table></figure>

<p>引入webpack，并返回webpack编译器对象compiler</p>
<p>查看文件<code>node_modules/webpack/lib/webpack.js</code>第25行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 加载 webpack 默认配置</span><br><span class="line">  options &#x3D; new webpackOptionsDefaulter().process(options);</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 编译器对象 compiler</span><br><span class="line">        compiler &#x3D; new Compiler(options.context);</span><br><span class="line">        compiler.options &#x3D; options;</span><br><span class="line">        &#x2F;&#x2F; 初始化 webpack 的 log 系统、watch 系统、file 系统</span><br><span class="line">        new NodeEnvironmentPlugin(&#123;</span><br><span class="line">            infrastructureLogging: options.infrastructureLogging</span><br><span class="line">        &#125;).apply(compiler);</span><br><span class="line">        &#x2F;&#x2F; 开始加载插件</span><br><span class="line">        if (options.plugins &amp;&amp; Array.isArray(options.plugins)) &#123;</span><br><span class="line">            for (const plugin of options.plugins) &#123;</span><br><span class="line">                if (typeof plugin &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">                    plugin.call(compiler, compiler);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    plugin.apply(compiler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        compiler.hooks.environment.call();</span><br><span class="line">        compiler.hooks.afterEnvironment.call();</span><br><span class="line">        &#x2F;&#x2F;根据 wbepack 的默认配置做 webpack 的初始化操作</span><br><span class="line">        compiler.options &#x3D; new webpackOptionsApply().process(options, compiler);</span><br><span class="line">  if (callback) &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 开始编译</span><br><span class="line">        compiler.run(callback);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回编译器对象</span><br><span class="line">    return compiler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加载默认配置webpackOptionsDefaulter"><a href="#加载默认配置webpackOptionsDefaulter" class="headerlink" title="加载默认配置webpackOptionsDefaulter"></a>加载默认配置webpackOptionsDefaulter</h3><p>查看<code>node_modules/webpack/lib/webpackOptionsDefaulter.js</code>文件第30行，查看<code>webpackOptionsDefaulter</code>定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class webpackOptionsDefaulter extends OptionsDefaulter &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        &#x2F;&#x2F; 设置默认的入口文件为 “src&#x2F;index.js” 文件</span><br><span class="line">        this.set(&quot;entry&quot;, &quot;.&#x2F;src&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置默认的开发模式为：测试环境 “eval” 生产环境 “false”</span><br><span class="line">        this.set(&quot;devtool&quot;, &quot;make&quot;, options &#x3D;&gt;</span><br><span class="line">            options.mode &#x3D;&#x3D;&#x3D; &quot;development&quot; ? &quot;eval&quot; : false</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; 设置默认上下文目录为 process.cwd()</span><br><span class="line">        this.set(&quot;context&quot;, process.cwd());</span><br><span class="line">        &#x2F;&#x2F; 设置 webpack 的默认 target 为 “web”</span><br><span class="line">        this.set(&quot;target&quot;, &quot;web&quot;);</span><br><span class="line">        ...</span><br><span class="line">        &#x2F;&#x2F; 设置 webpack 的默认输出路径为 “dist” 目录</span><br><span class="line">        this.set(&quot;output.path&quot;, path.join(process.cwd(), &quot;dist&quot;));</span><br><span class="line"></span><br><span class="line">        .........</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上看出，当没有对webpack做任何配置时，webpack会读取默认配置信息，即默认入口文件<code>src/index.js</code>，默认开发环境、上下文目录、默认target、默认输出路径。</p>
<p>即在基础使用中，没有做任何配置，故webpack默认读取<code>src/index.js</code>文件打包输出到<code>dist</code>目录</p>
<h3 id="创建Compiler对象"><a href="#创建Compiler对象" class="headerlink" title="创建Compiler对象"></a>创建Compiler对象</h3><blockquote>
<p>对象<code>Compiler</code>类似<code>webpack</code>的司机，控制webpack使用</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建 webpack 编译器对象 compiler</span><br><span class="line">  compiler &#x3D; new Compiler(options.context);</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的方法有</p>
<ol>
<li><p>run：启动编译</p>
</li>
<li><p>newCompilation：创建编译器</p>
</li>
<li><p>emitAssets：处理编译后结果。</p>
</li>
</ol>
<h3 id="创建node环境"><a href="#创建node环境" class="headerlink" title="创建node环境"></a>创建node环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 初始化 webpack 的 log 系统、watch 系统、file 系统</span><br><span class="line">    new NodeEnvironmentPlugin(&#123;</span><br><span class="line">        infrastructureLogging: options.infrastructureLogging</span><br><span class="line">    &#125;).apply(compiler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>node_modules/webpack/lib/node/NodeEnvironmentPlugin.js</code>文件第14行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NodeEnvironmentPlugin &#123;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 中的 log 系统</span><br><span class="line">        compiler.infrastructureLogger &#x3D; createConsoleLogger(</span><br><span class="line">            Object.assign(</span><br><span class="line">                &#123;</span><br><span class="line">                    level: &quot;info&quot;,</span><br><span class="line">                    debug: false,</span><br><span class="line">                    console: nodeConsole</span><br><span class="line">                &#125;,</span><br><span class="line">                this.options.infrastructureLogging</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 中的 file 读取系统</span><br><span class="line">        compiler.inputFileSystem &#x3D; new CachedInputFileSystem(</span><br><span class="line">            new NodeJsInputFileSystem(),</span><br><span class="line">            60000</span><br><span class="line">        );</span><br><span class="line">        const inputFileSystem &#x3D; compiler.inputFileSystem;</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 中的 file 输出系统</span><br><span class="line">        compiler.outputFileSystem &#x3D; new NodeOutputFileSystem();</span><br><span class="line">        &#x2F;&#x2F; 创建 webpack 中的 watch 监听文件系统</span><br><span class="line">        compiler.watchFileSystem &#x3D; new NodeWatchFileSystem(</span><br><span class="line">            compiler.inputFileSystem</span><br><span class="line">        );</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>NodeEnvironmentPlugin</code>创建文件系统，使<code>webpack</code>可以读取、编译、输出文件，同时输出一些log文件</p>
<h3 id="加载plugins"><a href="#加载plugins" class="headerlink" title="加载plugins"></a>加载plugins</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 开始加载插件</span><br><span class="line">    if (options.plugins &amp;&amp; Array.isArray(options.plugins)) &#123;</span><br><span class="line">        for (const plugin of options.plugins) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果插件是一个方法</span><br><span class="line">            if (typeof plugin &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">                plugin.call(compiler, compiler);</span><br><span class="line">            &#x2F;&#x2F; 插件为一个对象的时候</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                plugin.apply(compiler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h4><ol>
<li>提供配置文件<code>webpack.config.js</code>给<code>webpack</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建配置文件</span><br><span class="line">touch webpack.config.js</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>导入一个对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建plugins目录</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir plugins</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在plugins目录中创建文件function-webpack-plugin.js</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch plugins&#x2F;function-webpack-plugin.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;文件内容</span><br><span class="line">module.exports &#x3D; function (compiler) &#123;</span><br><span class="line">  &#x2F;&#x2F; 利用 webpack 的 log 系统输出一句话</span><br><span class="line">  compiler.infrastructureLogger(&#39;Customer&#39;, &#39;error&#39;, [</span><br><span class="line">    &#39;我是自定义Function插件&#39;,</span><br><span class="line">  ]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在plugins目录中创建文件object-webpack-plugin.js</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ObjectwebpackPlugin &#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    &#x2F;&#x2F; 同样利用 webpack 的 log 系统输出一句话</span><br><span class="line">    compiler.infrastructureLogger(&#39;Customer&#39;, &#39;error&#39;, [</span><br><span class="line">      &#39;我是自定义Object插件&#39;,</span><br><span class="line">    ]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports &#x3D; ObjectwebpackPlugin;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在webpack.config.js使用4、5中插件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    require(&#39;.&#x2F;plugins&#x2F;function-webpack-plugin&#39;), &#x2F;&#x2F; 引用 function 方式插件</span><br><span class="line">    new (require(&#39;.&#x2F;plugins&#x2F;object-webpack-plugin&#39;))(), &#x2F;&#x2F; 引用 object 方式插件</span><br><span class="line">  ],</span><br><span class="line">  infrastructureLogging: &#123;</span><br><span class="line">    debug: true, &#x2F;&#x2F; 开启 webpack 的 log 系统</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>执行命令<code>npx webpack</code></li>
</ol>
<p><img src="https://i.loli.net/2021/05/22/XolRx52HTQWpPwy.png" alt="结果"></p>
<h3 id="根据默认配置初始化webpack"><a href="#根据默认配置初始化webpack" class="headerlink" title="根据默认配置初始化webpack"></a>根据默认配置初始化webpack</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const webpackOptionsApply &#x3D; require(&quot;.&#x2F;webpackOptionsApply&quot;);</span><br><span class="line">...</span><br><span class="line">const webpack &#x3D; (options, callback) &#x3D;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  &#x2F;&#x2F; 根据默认配置初始化 webpack</span><br><span class="line">  compiler.options &#x3D; new webpackOptionsApply().process(options, compiler);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看文件<code>node_modules/webpack/lib/webpackOptionsApply.js</code>第55行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">process(options, compiler) &#123;</span><br><span class="line">    let ExternalsPlugin;</span><br><span class="line">    &#x2F;&#x2F; 初始化 webpack 的输出路径</span><br><span class="line">    compiler.outputPath &#x3D; options.output.path;</span><br><span class="line">    &#x2F;&#x2F; 初始化 webpack 的 records 路径</span><br><span class="line">    compiler.recordsInputPath &#x3D; options.recordsInputPath || options.recordsPath;</span><br><span class="line">    compiler.recordsOutputPath &#x3D;</span><br><span class="line">        options.recordsOutputPath || options.recordsPath;</span><br><span class="line">    &#x2F;&#x2F; 设置当前编译器的 name</span><br><span class="line">    compiler.name &#x3D; options.name;</span><br><span class="line">        switch (options.target) &#123;</span><br><span class="line">            case &quot;web&quot;:</span><br><span class="line">                &#x2F;&#x2F; 添加浏览器环境的模块生成器模版</span><br><span class="line">                JsonpTemplatePlugin &#x3D; require(&quot;.&#x2F;web&#x2F;JsonpTemplatePlugin&quot;);</span><br><span class="line">                NodeSourcePlugin &#x3D; require(&quot;.&#x2F;node&#x2F;NodeSourcePlugin&quot;);</span><br><span class="line">                new JsonpTemplatePlugin().apply(compiler);</span><br><span class="line">                new FetchCompileWasmTemplatePlugin(&#123;</span><br><span class="line">                    mangleImports: options.optimization.mangleWasmImports</span><br><span class="line">                &#125;).apply(compiler);</span><br><span class="line">                &#x2F;&#x2F; 将模块到一个方法中的模版</span><br><span class="line">                new FunctionModulePlugin().apply(compiler);</span><br><span class="line">                new NodeSourcePlugin(options.node).apply(compiler);</span><br><span class="line">                new LoaderTargetPlugin(options.target).apply(compiler);</span><br><span class="line">                break;</span><br><span class="line">      ...</span><br><span class="line">    &#x2F;&#x2F; 入口文件加载插件</span><br><span class="line">    new EntryOptionPlugin().apply(compiler);</span><br><span class="line">    &#x2F;&#x2F; 执行 compiler 对象中的 entryOption 钩子函数</span><br><span class="line">    compiler.hooks.entryOption.call(options.context, options.entry);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>webpackOptionsApply的责任为根据webapck的配置信息加载一些插件。</p>
</blockquote>
<p>如上代码中<code>入口文件加载插件</code>到<code>执行compiler对象中的entryOption钩子函数</code>部分，这里执行了<code>compiler</code>对象中的<code>entryOption</code>钩子函数。</p>
<p>查看文件<code>node_modules/webpack/lib/EntryOptionPlugin.js</code>第20行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">const itemToPlugin &#x3D; (context, item, name) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 多入口的时候</span><br><span class="line">    if (Array.isArray(item)) &#123;</span><br><span class="line">        return new MultiEntryPlugin(context, item, name);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 单入口的时候</span><br><span class="line">    return new SingleEntryPlugin(context, item, name);</span><br><span class="line">&#125;;</span><br><span class="line">module.exports &#x3D; class EntryOptionPlugin &#123;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        &#x2F;&#x2F; 监听 compiler 对象中的 entryOption 钩子函数</span><br><span class="line">        compiler.hooks.entryOption.tap(&quot;EntryOptionPlugin&quot;, (context, entry) &#x3D;&gt; &#123;</span><br><span class="line">             &#x2F;&#x2F; entry 可以为一个 string 或数组，名称默认为 “main”</span><br><span class="line">            if (typeof entry &#x3D;&#x3D;&#x3D; &quot;string&quot; || Array.isArray(entry)) &#123;</span><br><span class="line">                itemToPlugin(context, entry, &quot;main&quot;).apply(compiler);</span><br><span class="line">            &#125; else if (typeof entry &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123; &#x2F;&#x2F; entry 可以为一个 object</span><br><span class="line">                for (const name of Object.keys(entry)) &#123;</span><br><span class="line">                    itemToPlugin(context, entry[name], name).apply(compiler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (typeof entry &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123; &#x2F;&#x2F; entry 还可以为一个方法</span><br><span class="line">                new DynamicEntryPlugin(context, entry).apply(compiler);</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>EntryOptionPlugin监听<code>compiler</code>对象中的<code>entryOption</code>钩子函数的执行</p>
<p>原基础应用使用的是单入口项目，故在此使用的是SIngleEntryPlugin插件，查看文件<code>node_modules/webpack/lib/SingleEntryPlugin.js</code>第40行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SingleEntryPlugin &#123;</span><br><span class="line">    constructor(context, entry, name) &#123;</span><br><span class="line">        this.context &#x3D; context; &#x2F;&#x2F; 当前 webpack 的上下文目录</span><br><span class="line">        this.entry &#x3D; entry; &#x2F;&#x2F; 入口文件</span><br><span class="line">        this.name &#x3D; name; &#x2F;&#x2F; 入口文件的名称</span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">    ...</span><br><span class="line">        &#x2F;&#x2F; 监听 compiler 对象的 make 操作</span><br><span class="line">        compiler.hooks.make.tapAsync(</span><br><span class="line">            &quot;SingleEntryPlugin&quot;,</span><br><span class="line">            (compilation, callback) &#x3D;&gt; &#123;</span><br><span class="line">                const &#123; entry, name, context &#125; &#x3D; this;</span><br><span class="line">                const dep &#x3D; SingleEntryPlugin.createDependency(entry, name);</span><br><span class="line">                &#x2F;&#x2F; 把入口文件当成一个 dependency 添加到 webpack 进行编译</span><br><span class="line">                compilation.addEntry(context, dep, name, callback);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">module.exports &#x3D; SingleEntryPlugin;</span><br></pre></td></tr></table></figure>

<p>到此，webpack的初始化过程结束。<code>webpack</code>在<code>SingleEntryPlugin</code>停止运行等待<code>compiler</code>的<code>make</code>操作的执行，即webpack编译的开始。</p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue动态切换页签缓存页面内容</title>
    <url>/post/2684937453.html</url>
    <content><![CDATA[<p>之前在上家公司自己建系统的时候出现过切换页签，但切换后上个页面的内容没有被缓存，而是重新渲染了。</p>
<p>正好学习Vue3时看到了解决方法。</p>
<p>（之前因为赶工作进度，学习Vue2时没有用心看&lt;–要改正的问题</p>
<p>使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>将切换的组件包裹起来即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive&gt;</span><br><span class="line">  &lt;component :is&#x3D;&quot;currentTabComponent&quot;&gt;&lt;&#x2F;component&gt;</span><br><span class="line">&lt;&#x2F;keep-alive&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件通信</title>
    <url>/post/943587192.html</url>
    <content><![CDATA[<blockquote>
<p>Vue组件实例的作用域相互独立，不同组件之间的数据无法相互引用</p>
</blockquote>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><blockquote>
<p>参数<code>props</code>用于父组件向子组件传递数据</p>
</blockquote>
<p>父组件调用子组件，在子组件的<code>props</code>写入需要的属性。传递时，在父组件内调用的子组件中直接使用。</p>
<p>可以传入静态的值：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">const app &#x3D; Vue.createApp(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">app.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;title&#39;],</span><br><span class="line">  template: &#96;&lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h4&gt;&#96;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.mount(&#39;#blog-post-demo&#39;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&lt;blog-post title&#x3D;&quot;My journey with Vue&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br></pre></td></tr></table></figure>


<p>也可以通过<code>v-bind</code>或简写<code>:</code>动态赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;blog-post :title&#x3D;&quot;post.title&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">&lt;blog-post :title&#x3D;&quot;post.title + &#39;by&#39; + post.author.name &quot;&gt;&lt;&#x2F;blog-post&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除传递静态string值外，传入数据、布尔值、数组、对象等，即使传递静态数据也要使用<code>v-bind</code>告诉Vue。即<code>&lt;blog-post :like=&quot;42&quot;&gt;&lt;/blog-post&gt;</code></p>
</blockquote>
<p>所有props均为单项数据流，即父级prop的更新会向下流动到子组件，无法由子组件传递给父组件。</p>
<h3 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h3><blockquote>
<p>emit用于子组件向父组件传递数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&#x2F;&#x2F;需要子组件提供postFontSize的值更新字体大小</span><br><span class="line">&lt;div :style&#x3D;&quot;&#123;fontSize: postFontSize + &#39;em&#39;&#125;&quot;&gt;</span><br><span class="line">    &lt;!--父组件通过@&#x2F;v-on监听子组件实例的enlarge-text事件将字体大小增大0.1，当子组件事件触发，则父组件通过此监听器接收到事件并更新需要的postFontSize值--&gt;</span><br><span class="line">    &lt;blog-post</span><br><span class="line">        v-for&#x3D;&quot;post in posts&quot;</span><br><span class="line">        :key &#x3D; &quot;post.id&quot;</span><br><span class="line">        :title&#x3D;&quot;post.title&quot;</span><br><span class="line">        @enlarge-text&#x3D;&quot;postFontSize +&#x3D; 0.1&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;&#x2F;blog-post&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">app.component(&#39;blog-post&#39;, &#123;</span><br><span class="line">  props: [&#39;title&#39;],</span><br><span class="line">  template: &#96;</span><br><span class="line">    &lt;div class&#x3D;&quot;blog-post&quot;&gt;</span><br><span class="line">      &lt;h4&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;!--子组件通过调用$emit方法传入事件名称enlargeText来触发事件--&gt;</span><br><span class="line">      &lt;button @click&#x3D;&quot;$emit(&#39;enlargeText&#39;)&quot;&gt;</span><br><span class="line">        Enlarge text</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>$emit:</p>
<pre><code>参数：{string}```eventName```, ```[...args]```

触发当前实例上的事件```eventName```，附加参数```args```会传给监听器回调</code></pre><h3 id="使用事件监听子组件"><a href="#使用事件监听子组件" class="headerlink" title="使用事件监听子组件"></a>使用事件监听子组件</h3><blockquote>
<p>使用<code>$emit</code>的附加参数提供特定的值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;子组件</span><br><span class="line">&lt;button @click&#x3D;&quot;$emit(&#39;enlarge-text&#39;, 0.1)&quot;&gt;</span><br><span class="line">  Enlarge text</span><br><span class="line">&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F;父组件</span><br><span class="line">&#x2F;&#x2F;通过$event访问被抛出的附加参数</span><br><span class="line">&lt;blog-post ... @enlarge-text&#x3D;&quot;postFontSize +&#x3D; $event&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;若事件处理函数是一个方法，则此抛出的附加参数会作为方法的第一个参数传入</span><br><span class="line">&lt;blog-post ... @enlarge-text&#x3D;&quot;onEnlargeText&quot;&gt;&lt;&#x2F;blog-post&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  onEnlargeText(enlargeAmount) &#123;</span><br><span class="line">    this.postFontSize +&#x3D; enlargeAmount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><h3 id="provide-amp-amp-inject"><a href="#provide-amp-amp-inject" class="headerlink" title="provide&amp;&amp;inject"></a>provide&amp;&amp;inject</h3>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue事件处理修饰符</title>
    <url>/post/2636759885.html</url>
    <content><![CDATA[<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><blockquote>
<p>在事件处理程序中调用<code>event.preventDefault()</code>或<code>event.stopPropagation()</code>是非常常见的需求。因此推荐使用事件修饰符处理。尽管可以在方法中实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理<code>DOM</code>事件细节。</p>
</blockquote>
<p>修饰符是由点开头的指令后缀来表示的。使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a @click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form @submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a @click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form @submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div @click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div @click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a @click.once&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发--&gt;</span><br><span class="line">&lt;!-- 而不会等待 &#96;onScroll&#96; 完成--&gt;</span><br><span class="line">&lt;!-- 这其中包含 &#96;event.preventDefault()&#96; 的情况--&gt;</span><br><span class="line">&lt;!-- .passive和.prevent不要一起使用，.prevent会被忽略--&gt;</span><br><span class="line">&lt;div @scroll.passive&#x3D;&quot;onScroll&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><blockquote>
<p>用于监听键盘事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只有在 &#96;key&#96; 是 &#96;Enter&#96; 时调用 &#96;vm.submit()&#96; --&gt;</span><br><span class="line">&lt;input @keyup.enter&#x3D;&quot;submit&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;input @keyup.page-down&#x3D;&quot;onPageDown&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="按键别名"><a href="#按键别名" class="headerlink" title="按键别名"></a>按键别名</h4><ul>
<li>.enter</li>
<li>.tab</li>
<li>.delete (捕获“删除”和“退格”键)</li>
<li>.esc</li>
<li>.space</li>
<li>.up</li>
<li>.down</li>
<li>.left</li>
<li>.right</li>
</ul>
<h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><blockquote>
<p>实现仅在按下相应按键时才触发鼠标或键盘事件的监听器</p>
</blockquote>
<ul>
<li>.ctrl</li>
<li>.alt</li>
<li>.shift</li>
<li>.meta</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- Alt + Enter --&gt;</span><br><span class="line">&lt;input @keyup.alt.enter&#x3D;&quot;clear&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Ctrl + Click --&gt;</span><br><span class="line">&lt;div @click.ctrl&#x3D;&quot;doSomething&quot;&gt;Do something&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用<code>.exact</code>修饰符允许控制由精确的系统修饰符组合触发的事件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.ctrl.exact&#x3D;&quot;onCtrlClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button @click.exact&#x3D;&quot;onClick&quot;&gt;A&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>鼠标按钮修饰符</p>
</blockquote>
<ul>
<li>.left</li>
<li>.right</li>
<li>.middle</li>
</ul>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue条件渲染区分</title>
    <url>/post/4085137225.html</url>
    <content><![CDATA[<ol>
<li><code>v-if</code>在初始渲染时判断条件，若为假，则不进行渲染。只有当条件为真时才开始渲染条件块。确保在切换过程中条件块内的事件监听器和子组件被适当的销毁和重建。</li>
<li><code>v-show</code>无论初始判断条件是真或假，均会进行渲染。即只是切换元素的CSS Property <code>display</code>。</li>
<li><code>v-show</code>不支持<code>&lt;template&gt;</code>和<code>v-else</code></li>
</ol>
<blockquote>
<p>使用<code>v-if</code>有更高的切换开销，若运行时条件很少改变，则选择<code>v-if</code>。<code>v-show</code>有更高的初始开销，若需要频繁的切换，则使用<code>v-show</code>更好。</p>
</blockquote>
<a id="more"></a>

<h3 id="v-if和v-for不要同时用在同一元素上"><a href="#v-if和v-for不要同时用在同一元素上" class="headerlink" title="v-if和v-for不要同时用在同一元素上"></a>v-if和v-for不要同时用在同一元素上</h3><blockquote>
<p>参数<code>v-for</code>的优先级比<code>v-if</code>高</p>
</blockquote>
<ol>
<li><p>过滤列表中的项目，优先将过滤的项目替换为计算属性，使其返回过滤后的列表进行v-for</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">        v-if&#x3D;&quot;user.isActive&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p> 无论列表数据量有多大，筛选后的列表有没有变化，都会在每次重新渲染时遍历整个列表。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;改写后</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in activeUsers&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    activeUsers() &#123;</span><br><span class="line">        return this.users.filter(user &#x3D;&gt; user.isActive)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 改写后，过滤列表只会在筛选后列表发生变化时才会重新计算，过滤更高效。且在<code>v-for</code>遍历时，只会遍历选后的列表，渲染更高效。解耦渲染层的逻辑，可维护性更强。</p>
</li>
<li><p>避免渲染需要被隐藏的列表，将v-if移动到容器元素上。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;改写前</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">        v-if&#x3D;&quot;shouldShowUsers&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;改写后</span><br><span class="line">&lt;ul v-if&#x3D;&quot;shouldShowUsers&quot;&gt;</span><br><span class="line">    &lt;li</span><br><span class="line">        v-for&#x3D;&quot;user in users&quot;</span><br><span class="line">        :key&#x3D;&quot;user.id&quot;</span><br><span class="line">    &gt;</span><br><span class="line">        &#123;&#123; user.name &#125;&#125;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<p> 改写后不需要对列表内每个用户都检查是否应该显示，而只检查一次，且不会<code>v-for</code>不应该显示的用户。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>JS真值Truthy和假值Falsy</title>
    <url>/post/3652898665.html</url>
    <content><![CDATA[<p>假值Falsy：<code>false</code>,<code>0</code>,<code>&quot;&quot;</code>,<code>null</code>,<code>undefined</code>,<code>NaN</code></p>
<p>真值Truthy：除假值外均为真值。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;真值Truthy,以下均会被当作true执行if内的代码</span><br><span class="line">if (true)</span><br><span class="line">if (&#123;&#125;)</span><br><span class="line">if (42)</span><br><span class="line">if (&quot;foo&quot;)</span><br><span class="line">if (new Date())</span><br><span class="line">if (-Infinity)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;假值Falsy，以下均会被当作false跳过if内的代码</span><br><span class="line">if (false)</span><br><span class="line">if (null)</span><br><span class="line">if (undefined)</span><br><span class="line">if (0)</span><br><span class="line">if (0n)</span><br><span class="line">if (NaN)</span><br><span class="line">if (&#39;&#39;)</span><br><span class="line">if (&quot;&quot;)</span><br><span class="line">if (&#96;&#96;)</span><br><span class="line">if (document.all)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue计算属性</title>
    <url>/post/2394451147.html</url>
    <content><![CDATA[<blockquote>
<p>不要在模版中放入太多的逻辑。模版最好是简单和声明性的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        book:&#123;</span><br><span class="line">            author: &#39;xxx&#39;,</span><br><span class="line">            borrower: [</span><br><span class="line">                &#39;aaa&#39;,</span><br><span class="line">                &#39;bbb&#39;,</span><br><span class="line">                &#39;ccc&#39;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;This book has been borrowed?&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; book.borrower.length &gt; 0 ? &#39;yes&#39; : &#39;no&#39; &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<blockquote>
<p>对于包含响应式数据的复杂逻辑，应使用计算属性<code>computed</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        book:&#123;</span><br><span class="line">            author: &#39;xxx&#39;,</span><br><span class="line">            borrower: [</span><br><span class="line">                &#39;aaa&#39;,</span><br><span class="line">                &#39;bbb&#39;,</span><br><span class="line">                &#39;ccc&#39;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123;</span><br><span class="line">    &#x2F;&#x2F;计算属性的getter</span><br><span class="line">    borrowedMessage()&#123;</span><br><span class="line">        &#x2F;&#x2F;this指向vm实例</span><br><span class="line">        return this.book.borrower.length &gt; 0 ? &#39;yes&#39; : &#39;no&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;This book has been borrowed?&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; borrowedMessage &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="在表达式中调用方法同样可以达成一样的效果"><a href="#在表达式中调用方法同样可以达成一样的效果" class="headerlink" title="在表达式中调用方法同样可以达成一样的效果"></a>在表达式中调用方法同样可以达成一样的效果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        book:&#123;</span><br><span class="line">            author: &#39;xxx&#39;,</span><br><span class="line">            borrower: [</span><br><span class="line">                &#39;aaa&#39;,</span><br><span class="line">                &#39;bbb&#39;,</span><br><span class="line">                &#39;ccc&#39;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    borrowedMessage()&#123;</span><br><span class="line">        &#x2F;&#x2F;this指向vm实例</span><br><span class="line">        return this.book.borrower.length &gt; 0 ? &#39;yes&#39; : &#39;no&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;This book has been borrowed?&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;!--调用方法--&gt;</span><br><span class="line">        &lt;span&gt;&#123;&#123; borrowedMessage() &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ol>
<li><p>计算属性基于依赖关系缓存。即<code>vm.borrowedMessage</code>依赖<code>vm.book.borrower</code>。故当<code>vm.book.borrower</code>改变，所有依赖<code>vm.borrowedMessage</code>的绑定都会更新，若<code>vm.book.borrower</code>没有改变，则多次访问<code>vm.borrowedMessage</code>均返回之前的结果，不会再次执行函数。</p>
</li>
<li><p>调用方法不会有缓存，每次触发重新渲染都会再次执行函数。即<code>Date.now()</code>在<code>methods</code>中调用可以每次渲染更新数值，但在<code>computed</code>中则不会被更新。</p>
</li>
</ol>
<blockquote>
<p>若出现性能开销大的计算属性，需要缓存来节省开销则使用<code>computed</code>，若程序不想要缓存，则使用<code>methods</code>替代计算属性</p>
</blockquote>
<h3 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">    fullName:&#123;</span><br><span class="line">        &#x2F;&#x2F;getter</span><br><span class="line">        get()&#123;</span><br><span class="line">            return this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F;setter</span><br><span class="line">        set(newValue)&#123;</span><br><span class="line">            const names &#x3D; newValue.split(&#39; &#39;)</span><br><span class="line">            this.firstName &#x3D; names[0]</span><br><span class="line">            this.lastName &#x3D; names[names.length - 1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="监听器watch"><a href="#监听器watch" class="headerlink" title="监听器watch"></a>监听器watch</h3><blockquote>
<p>当需要在数据变化时执行异步操作或者开销比较大的操作时，使用watch监听数据的变化。当数据有变化时才执行下一步操作。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;template</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;question:&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;question&quot; &#x2F;&gt; </span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;script</span><br><span class="line">watch:&#123;</span><br><span class="line">    question(new,old)&#123;</span><br><span class="line">        if(new.indexOf(&#39;?&#39;)&gt;-1)&#123;</span><br><span class="line">            this.getAnswer()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line">    getAnswer()&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-data及methods</title>
    <url>/post/2526449992.html</url>
    <content><![CDATA[<h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>组件的<code>data</code>是一个<code>函数</code>，调用它返回一个<code>对象</code>，被vue封装后，以<code>$data</code>的形式存储在组件实例中</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        example: [2,3,1]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>组件的<code>methods</code>是一个包含方法的<code>对象</code>，自动绑定<code>this</code>，始终指向组件实例。定义时避免使用箭头函数，会影响<code>this</code>的指向</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    exampleFuction()&#123;</span><br><span class="line">        example[2] &#x3D; 3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以在组件模版中被访问</span><br><span class="line">&lt;button @click&#x3D;&quot;exampleFuction&quot;&gt;Change example&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue运行单文件</title>
    <url>/post/944781666.html</url>
    <content><![CDATA[<ol>
<li><p>安装依赖<code>npm install -g @vue/cli-service-global</code></p>
</li>
<li><p>创建文件<code>xxx.vue</code></p>
</li>
<li><p>在文件目录运行<code>vue serve xxx.vue</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>新坑</title>
    <url>/post/3726999768.html</url>
    <content><![CDATA[<p>最近打算重写个人网站了，想想可以把之前练手的前端设计的个站、gist网站、还有当前的个站整合在一起，还要加一些作品集展示区。<br>本事一般想法挺大。感觉又要重学一遍了。<br>这周末再怎么犹豫也要把离职提了，做点自己喜欢的吧。</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>咕咕咕</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-2D光随鼠标移动转变方向</title>
    <url>/post/1739481233.html</url>
    <content><![CDATA[<h2 id="2D光随鼠标移动转变方向"><a href="#2D光随鼠标移动转变方向" class="headerlink" title="2D光随鼠标移动转变方向"></a>2D光随鼠标移动转变方向</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Update () &#123;</span><br><span class="line">&#x2F;&#x2F;获取鼠标的坐标，鼠标是屏幕坐标，Z轴为0，这里不做转换  </span><br><span class="line">Vector3 mouse &#x3D; Input.mousePosition;</span><br><span class="line">&#x2F;&#x2F;获取物体坐标，物体坐标是世界坐标，将其转换成屏幕坐标，和鼠标一直  </span><br><span class="line">Vector3 obj &#x3D; Camera.main.WorldToScreenPoint(transform.position);</span><br><span class="line">&#x2F;&#x2F;屏幕坐标向量相减，得到指向鼠标点的目标向量，即黄色线段  </span><br><span class="line">Vector3 direction &#x3D; mouse - obj;</span><br><span class="line">&#x2F;&#x2F;将Z轴置0,保持在2D平面内  </span><br><span class="line">direction.z &#x3D; 0f;</span><br><span class="line">&#x2F;&#x2F;将目标向量长度变成1，即单位向量，这里的目的是只使用向量的方向，不需要长度，所以变成1  </span><br><span class="line">direction &#x3D; direction.normalized;</span><br><span class="line">&#x2F;&#x2F;物体自身的Y轴和目标向量保持一直，这个过程XY轴都会变化数值  </span><br><span class="line">transform.up &#x3D; direction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-法线贴图&amp;BlendTree&amp;特效VFX</title>
    <url>/post/1132536811.html</url>
    <content><![CDATA[<h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><blockquote>
<p>法线贴图：记录了一个需要进行光影变换的贴图上的各个点的凹凸情况的贴图，显示芯片根据贴图的内容来实时生成新的有光影变换的贴图，从而实现立体效果</p>
</blockquote>
<blockquote>
<p>法线贴图不是真正的贴图，故不会直接贴到物体的表面，其作用就是记录每个点上法线的方向。</p>
</blockquote>
<a id="more"></a>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>模型面数越高，可以表现的细节越多，效果越好，但面数多了，顶点数便多了，计算量变大了。为了能用尽可能简单的模型来做出更好的效果，最初提出纹理映射，但它只影响像素阶段输出的颜色值，不能让模型有凹凸的细节，故提出法线贴图解决此问题。</p>
<p>最早在计算时需要逐顶点计算光照，然后每个像素的颜色在各个顶点的颜色之间插值，在此情况下，面数决定一切效果。但在像素着色器出现后，可以通过逐像素来计算光照效果。在计算时，会计算此像素所在面的法向量，此法向量也是由这个面周围的顶点的法线插值得来。当改变法线的方向，则可以改变这个点的光照结果。</p>
<p>在平面的情况下，感觉物体的凹凸很大一部分取决于面的亮度，有了对比，就容易感觉有凹凸。因此通过改变法线来改变面上点的光照条件进而可以让观察者感觉这个面有凹凸</p>
<p><a href="https://imgchr.com/i/sXFc0U" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sXFc0U.png" alt="sXFc0U.png"></a></p>
<h2 id="BlendTree"><a href="#BlendTree" class="headerlink" title="BlendTree"></a>BlendTree</h2><blockquote>
<p>混合树(Blend Tree)按不同程度组合所有动画的各个部分来平滑混合多个动画。即将多个动画融合在一起按条件触发。</p>
</blockquote>
<ol>
<li><code>Animator</code>选择新建混合树的状态，右键选择<code>Create New Blend Tree in State</code></li>
</ol>
<p><a href="https://imgchr.com/i/sXFRk4" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sXFRk4.png" alt="sXFRk4.png"></a></p>
<ol start="2">
<li><p>双击<code>Blend Tree</code>打开<code>Inspector</code>在<code>Motion</code>处新建需要混合的多个动画。</p>
</li>
<li><p>选择参数<code>Parameter</code>是通过速度<code>Speed</code>计算还是通过垂直加速度<code>verticalVelocity</code>，两个都是<code>Float</code>类型</p>
</li>
<li><p>在各个动画的<code>Threshold</code>设置不同的参数值来控制其出现的时间</p>
</li>
</ol>
<p><a href="https://imgchr.com/i/sXFg7F" target="_blank" rel="noopener"><img src="https://s3.ax1x.com/2021/01/26/sXFg7F.png" alt="sXFg7F.png"></a></p>
<ol start="5">
<li>在脚本中为动画参数赋值，即关联实际角色与动画设置的参数。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fallID;</span><br><span class="line">&#x2F;&#x2F;fallID为Animator状态参数的编号</span><br><span class="line">fallID &#x3D; Animator.StringToHash(&quot;verticalVelocity&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置跳跃BlendTree的动画，其float值就是角色刚体y轴跳跃的加速度,</span><br><span class="line">anim.SetFloat(fallID, rb.velocity.y);</span><br></pre></td></tr></table></figure>

<h2 id="解决更换场景也不销毁某对象"><a href="#解决更换场景也不销毁某对象" class="headerlink" title="解决更换场景也不销毁某对象"></a>解决更换场景也不销毁某对象</h2><p>在代码中使用<code>DontDestroyOnLoad(gameObject)</code>方法</p>
<h2 id="代码中给角色添加特效VFX"><a href="#代码中给角色添加特效VFX" class="headerlink" title="代码中给角色添加特效VFX"></a>代码中给角色添加特效VFX</h2><ol>
<li>脚本中创建特效变量</li>
<li>unity中将特效拖入对应变量中</li>
<li>使用<code>Instantiate(origin,position,rotation)</code>方法替换当前角色的位置为特效动画</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-2D场景透视效果&amp;多个电光源部分光源失效的问题</title>
    <url>/post/900394468.html</url>
    <content><![CDATA[<h2 id="2D场景透视效果"><a href="#2D场景透视效果" class="headerlink" title="2D场景透视效果"></a>2D场景透视效果</h2><ol>
<li>调整Camera的<code>Projection</code>为<code>Perspective</code><ul>
<li><code>Perspective</code>接近真实摄像机，在3D视图中表现为以点发散的射线构成的画面<br><img src="https://s3.ax1x.com/2021/01/25/sqIAFs.png" alt="sqIAFs.png"></li>
</ul>
</li>
</ol>
<a id="more"></a>

<pre><code>- ```Orthographic```为方形的摄像机，在3D视图中表现为方形垂直的射线构成的画面
![sqIEYn.png](https://s3.ax1x.com/2021/01/25/sqIEYn.png)</code></pre><ol start="2">
<li>调整景深，即调整不同背景图层<code>Position</code>的<code>z轴</code></li>
</ol>
<h2 id="解决设置多个电光源但部分光源失效的问题"><a href="#解决设置多个电光源但部分光源失效的问题" class="headerlink" title="解决设置多个电光源但部分光源失效的问题"></a>解决设置多个电光源但部分光源失效的问题</h2><blockquote>
<p>Unity中Quality Setting的Pixel Light Count的个数过小</p>
</blockquote>
<ol>
<li><p>点击<code>Edit</code>-&gt;<code>Project Setting</code>-&gt;<code>Quality</code>，查看<code>QualitySetting</code></p>
</li>
<li><p>在<code>Rendering</code>设置<code>Pixel Light Count</code>，即场景中渲染的点光源个数。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-合并地图碰撞器&amp;标记字段&amp;射线检测碰撞体</title>
    <url>/post/3573569076.html</url>
    <content><![CDATA[<h2 id="将地图碰撞器合并"><a href="#将地图碰撞器合并" class="headerlink" title="将地图碰撞器合并"></a>将地图碰撞器合并</h2><ol>
<li>在<code>Tile Collider 2D</code>中勾选<code>Used by Composite</code></li>
<li>新建一个<code>Composite Collider 2D</code>，同时会自动生成一个刚体<code>RigidBody 2D</code></li>
<li>将<code>RigidBody 2D</code>的<code>Body Type</code>设置为<code>static</code>，则其不会因重力而运动，固定在原地</li>
<li>同时也可以在<code>Inspector</code>的右上角将<code>Static</code>勾选</li>
</ol>
<a id="more"></a>

<h2 id="unity在脚本中使用标记字段"><a href="#unity在脚本中使用标记字段" class="headerlink" title="unity在脚本中使用标记字段"></a>unity在脚本中使用标记字段</h2><blockquote>
<p>在脚本中使用标记字段可以在<code>Inspector</code>中组织属性显示</p>
</blockquote>
<ol>
<li><code>[Space(10)]</code>: 与上面产生一个10的空隙，也可以不带参数</li>
<li><code>Header(&quot;xxx&quot;)</code>: 在<code>Inspector</code>面板上给定义的字段的上一行加描述，形成分组的感觉</li>
<li><code>[Tooltip(&quot;xxx&quot;)]</code>: 给变量加Tooltip属性使在<code>Inspector</code>面板鼠标悬停在该变量上显示提示</li>
<li><code>[Range(min,max)]</code>: 限制数值变量的取值范围并以滑动条显示在<code>Inspector</code>中</li>
<li><code>[SerializeField]</code>: 强制序列化一个私有的变量，使之可以在<code>Inspector</code>面板显示</li>
</ol>
<p><a href="https://blog.csdn.net/FifthGently/article/details/78363364?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control" target="_blank" rel="noopener">其他内容可看此链接</a></p>
<p>使用前：</p>
<p><img src="https://s3.ax1x.com/2021/01/22/sIM5N9.png" alt="sIM5N9.png"></p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]</span><br><span class="line">private float crouchSpeedDivison &#x3D; 3f;</span><br><span class="line"></span><br><span class="line">[Header(&quot;移动速度&quot;)]</span><br><span class="line">public float speed &#x3D; 8f;</span><br><span class="line">[Space(10)]</span><br><span class="line"></span><br><span class="line">[Range(0, 10)]</span><br><span class="line">public float xVelocity;</span><br></pre></td></tr></table></figure>
<p>使用后：</p>
<p><img src="https://s3.ax1x.com/2021/01/22/sIMIhR.png" alt="sIMIhR.png"></p>
<h2 id="射线检测碰撞体-RaycastHit2D"><a href="#射线检测碰撞体-RaycastHit2D" class="headerlink" title="射线检测碰撞体(RaycastHit2D)"></a>射线检测碰撞体(RaycastHit2D)</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;画射线</span><br><span class="line">RaycastHit2D leftCheck &#x3D; Physics2D.Raycast(pos + offset, Vector2.down, groundDistance, groundLayer);</span><br><span class="line">&#x2F;&#x2F;显示射线用于debug</span><br><span class="line">Debug.DrawRay(pos + offset, Vector2.down, Color.red, 0.2f);</span><br></pre></td></tr></table></figure>

<h3 id="Physics-Raycast"><a href="#Physics-Raycast" class="headerlink" title="Physics.Raycast"></a>Physics.Raycast</h3><blockquote>
<p><strong>射线投射(raycast)</strong>：射线投射从原点沿着射线方向发送假想的“激光束”，直至命中场景中的碰撞体，随后返回有关该对象和<code>RaycastHist</code>对象内的投射命中点的信息。</p>
</blockquote>
<blockquote>
<p>向场景中的所有碰撞体投射一条射线，该射线起点为<code>origin</code>，朝向<code>direction</code>，长度为<code>maxDistance</code>。</p>
</blockquote>
<blockquote>
<p>若射线与任何碰撞体相交，返回<code>true</code>否则为<code>false</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static bool Raycast (Vector3 origin, Vector3 direction, float maxDistance&#x3D; Mathf.Infinity, int layerMask&#x3D; DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction&#x3D; QueryTriggerInteraction.UseGlobal);</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>origin</td>
<td>射线在坐标系中的起点</td>
</tr>
<tr>
<td>direction</td>
<td>射线方向</td>
</tr>
<tr>
<td>maxDistance</td>
<td>射线检查碰撞的最大距离</td>
</tr>
<tr>
<td>layerMask</td>
<td>遮罩层，用于投射射线时选择性的忽略碰撞体</td>
</tr>
<tr>
<td>queryTriggerInteraction</td>
<td>指定该查询是否应该命中触发器</td>
</tr>
</tbody></table>
<p><strong>重写Raycast方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重构Raycast方法</span><br><span class="line">RaycastHit2D Raycast(Vector2 offset, Vector2 rayDirection, float length, LayerMask layer)</span><br><span class="line">&#123;</span><br><span class="line">    Vector2 pos &#x3D; transform.position;</span><br><span class="line">    RaycastHit2D hit &#x3D; Physics2D.Raycast(pos + offset, rayDirection, length, layer);</span><br><span class="line">    Color color &#x3D; hit ? Color.red : Color.green;</span><br><span class="line">    Debug.DrawRay(pos + offset, rayDirection * length,color);</span><br><span class="line">    return hit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Csharp-类&amp;方法</title>
    <url>/post/2936126698.html</url>
    <content><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li><p><code>public</code>：成员可由任何代码访问</p>
</li>
<li><p><code>private</code>：成员只能由类中的代码访问</p>
</li>
<li><p><code>protected</code>：成员只能由类或派生类中的代码访问</p>
</li>
</ul>
<a id="more"></a>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p><code>static</code>：若使用<code>static</code>关键字，该方法只能通过类访问，不能通过对象实例来访问</p>
</li>
<li><p><code>virtual</code>：方法可以重写</p>
</li>
<li><p><code>abstract</code>：方法必须在非抽象的派生类中重写（只用于抽象类）</p>
</li>
<li><p><code>override</code>：方法重写了一个基类方法（若方法被重写，必须使用该关键字）</p>
</li>
<li><p><code>extern</code>：方法定义放在其他地方</p>
</li>
<li><p><code>base</code>：调用重写或隐藏的基类方法，表示包含在派生类中的基类的实现代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;基类</span><br><span class="line">public class MyBaseClass&#123;</span><br><span class="line">    &#x2F;&#x2F;若子类可重写此方法，必须使用virtual关键字</span><br><span class="line">    public virtual void DoSomething()&#123;</span><br><span class="line">        &#x2F;&#x2F;方法内容</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">public class MyDerivedClass : MyBaseClass&#123;</span><br><span class="line">    &#x2F;&#x2F;重写基类方法必须使用override关键字</span><br><span class="line">    public override void DoSomething()&#123;</span><br><span class="line">        &#x2F;&#x2F;继承基类方法DoSomething()的已有内容</span><br><span class="line">        base.DoSomething();</span><br><span class="line">        &#x2F;&#x2F;重写方法其他独有功能</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-音效&amp;UI&amp;场景变换及光源</title>
    <url>/post/318510413.html</url>
    <content><![CDATA[<h2 id="音效"><a href="#音效" class="headerlink" title="音效"></a>音效</h2><ul>
<li><p>Audio Listener：音乐接收</p>
</li>
<li><p>Audio Source：音乐音源</p>
</li>
<li><p>Audio Clips：音乐片段</p>
</li>
</ul>
<a id="more"></a>

<h3 id="背景音乐"><a href="#背景音乐" class="headerlink" title="背景音乐"></a>背景音乐</h3><ol>
<li>下载音乐素材</li>
<li>在player界面添加<code>Audio Source</code></li>
<li>将对应bgm拖入<code>Audio Clip</code></li>
</ol>
<ul>
<li>Play On Awake: 游戏一开始就播放</li>
<li>Loop: 循环播放</li>
</ul>
<h3 id="为其他动作添加音效"><a href="#为其他动作添加音效" class="headerlink" title="为其他动作添加音效"></a>为其他动作添加音效</h3><ol>
<li><p>对象单个动作添音效</p>
<ul>
<li>下载音乐素材</li>
<li>在对象界面添加<code>Audio Source</code></li>
<li>将对应bgm拖入<code>Audio Clip</code></li>
<li>在脚本中添加<code>AudioSource</code>对象，并在<code>start()</code>方法使用<code>GetComponent&lt;AudioSource&gt;()</code>创建component</li>
<li>在合适的位置添加代码<code>audio.Play();</code>方法播放音效 </li>
</ul>
</li>
<li><p>对象多个动作添音效</p>
<ul>
<li>下载音乐素材</li>
<li>在对象界面添加<code>Audio Source</code></li>
<li>将对应bgm拖入<code>Audio Clip</code></li>
<li>在脚本中添加多个<code>public</code>的<code>AudioSource</code>对象，在unity界面将不同的音效拖入脚本的不同属性中</li>
<li>在合适的位置添加代码<code>audio.Play();</code>方法播放音效 </li>
</ul>
</li>
</ol>
<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><ol>
<li>添加UI中的<code>Panel</code>面板</li>
<li>选择合适的位置和颜色</li>
<li>在<code>Panel</code>中添加<code>Text</code>，并添加对应文字和样式</li>
<li>设置出现对话位置的碰撞体并设置<code>is Trigger</code></li>
<li>在代码中实现出现对话框的逻辑</li>
<li>在unity中将对应的对话框拖入<code>script</code>的对应<code>Object</code>中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public GameObject enterDialog;&#x2F;&#x2F;对话框Object</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;角色碰撞到出现对话的位置，触发函数</span><br><span class="line">public void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.tag.Equals(&quot;Player&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        enterDialog.SetActive(true);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;角色离开出现对话的位置，触发函数</span><br><span class="line">public void OnTriggerExit2D(Collider2D collision)</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.tag.Equals(&quot;Player&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        enterDialog.SetActive(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="场景变换"><a href="#场景变换" class="headerlink" title="场景变换"></a>场景变换</h2><blockquote>
<p>SceneManagement</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重新加载scene--死亡后重启</span><br><span class="line">SceneManager.LoadScene(SceneManager.GetActiveScene().name);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;进入下一个场景</span><br><span class="line">&#x2F;&#x2F;使用buildIndex前需要到File-&gt;Build Setting中加入所有场景</span><br><span class="line">SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);</span><br></pre></td></tr></table></figure>


<h2 id="增加光源"><a href="#增加光源" class="headerlink" title="增加光源"></a>增加光源</h2><blockquote>
<p>先让环境暗下来，再让发光的地方发出光源</p>
</blockquote>
<ol>
<li>给背景添加材质<code>Default_diffuse</code>，使其变暗</li>
<li>给人物及其他角色添加材质<ul>
<li>新建材质</li>
<li>在<code>Shader</code>中选择<code>Sprites/Diffuse</code>，若有法线贴图，则将其添加到<code>Normal Map</code>中</li>
<li>将材质拖入人物及其他角色的材质栏</li>
</ul>
</li>
<li>添加<code>Point Light</code>，光源是3D的，需要调节z轴的值来调节光线的亮度，并通过调节Range和Intensity改变光的范围和强度</li>
<li>更改光源位置到需要的地方</li>
</ol>
<p>若添加光源有边缘线，可讲cell size改成1、1，若出现锯齿，则在Project Setting中的Quality，将抗锯齿Anti Aliasing设置为Disabled</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-调用其他类&amp;敌人death动画</title>
    <url>/post/2320782257.html</url>
    <content><![CDATA[<h2 id="调用其他类的方法"><a href="#调用其他类的方法" class="headerlink" title="调用其他类的方法"></a>调用其他类的方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;调用Enemy_Frog类的方法切换敌人的动画</span><br><span class="line">Enemy_Frog frog &#x3D; collision.gameObject.GetComponent&lt;Enemy_Frog&gt;();</span><br><span class="line">frog.SwitchDeath();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="敌人death动画切换"><a href="#敌人death动画切换" class="headerlink" title="敌人death动画切换"></a>敌人death动画切换</h2><ol>
<li>创建敌人动画</li>
<li>创建动画关联Transition</li>
<li>设置条件Trigger(当该触发器被触发则切换动画)</li>
<li>在<code>Animation</code>创建event实现当动画播放结束再销毁敌人GameObject</li>
</ol>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-收集&amp;tilemap拼接缝隙&amp;collider碰撞摩擦&amp;敌人</title>
    <url>/post/4000927129.html</url>
    <content><![CDATA[<h2 id="创建收集内容"><a href="#创建收集内容" class="headerlink" title="创建收集内容"></a>创建收集内容</h2><ol>
<li>新建收集object</li>
<li>添加sprite和动画</li>
<li>移动至合适位置</li>
<li>设置collider碰撞体</li>
<li>设置isTrigger，使之碰撞时触发一些改变</li>
<li>为object设置特有tag，便于写脚本时获取该object</li>
<li>编写脚本实现计数、销毁等操作<a id="more"></a>

</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void OnTriggerEnter2D(Collider2D collision)</span><br><span class="line">    &#123;</span><br><span class="line">        if (collision.tag.Equals(&quot;Cherry&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            cherry++;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (collision.tag.Equals(&quot;Gem&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            gem++;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些记录"><a href="#一些记录" class="headerlink" title="一些记录"></a>一些记录</h3><p>is Trigger: 触发器 触发后会发生一些改变</p>
<p>inspector中: <code>Tag</code>、<code>Layer</code></p>
<p>Perfabs: 一个预置，类似于一个模版</p>
<h2 id="瓦片地图出现拼接缝隙"><a href="#瓦片地图出现拼接缝隙" class="headerlink" title="瓦片地图出现拼接缝隙"></a>瓦片地图出现拼接缝隙</h2><p>将<code>tilemap</code>的<code>grid</code>中<code>cellsize</code>改为0.99</p>
<h2 id="解决两个collider碰撞摩擦的问题-material材质"><a href="#解决两个collider碰撞摩擦的问题-material材质" class="headerlink" title="解决两个collider碰撞摩擦的问题(material材质)"></a>解决两个collider碰撞摩擦的问题(material材质)</h2><ol>
<li>创建<code>physical material 2d</code></li>
<li>修改摩擦力<code>friction</code>为0</li>
<li>将材质放入需要的collider里的material中</li>
</ol>
<h2 id="解决角色可多次跳的问题"><a href="#解决角色可多次跳的问题" class="headerlink" title="解决角色可多次跳的问题"></a>解决角色可多次跳的问题</h2><blockquote>
<p>设置角色只有触碰地面才可以跳跃，无法在空中跳跃</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public LayerMask ground;&#x2F;&#x2F;图层</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;角色跳跃</span><br><span class="line">if (Input.GetButtonDown(&quot;Jump&quot;) &amp;&amp; coll.IsTouchingLayers(ground))</span><br><span class="line">&#123;</span><br><span class="line">    rb.velocity &#x3D; new Vector2(rb.velocity.x, jumpForce * Time.deltaTime);</span><br><span class="line">    anim.SetBool(&quot;jumping&quot;, true);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ol>
<li>新建UI画布<code>canvas</code></li>
<li>在<code>canvas</code>内添加需要的内容</li>
<li>需要变化的变量在脚本中实现，unity中新建的UI是什么选项，脚本中就按该关键字获取UI</li>
<li>在unity脚本框内拖入相应的ui选项</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine.UI</span><br><span class="line"></span><br><span class="line">public Text CherryNumber;&#x2F;&#x2F;新建Text类</span><br><span class="line"></span><br><span class="line">CherryNumber.text &#x3D; cherry.ToString();&#x2F;&#x2F;将实际cherry值传给unity的Text类中</span><br></pre></td></tr></table></figure>

<h2 id="敌人"><a href="#敌人" class="headerlink" title="敌人"></a>敌人</h2><h3 id="创建敌人"><a href="#创建敌人" class="headerlink" title="创建敌人"></a>创建敌人</h3><ol>
<li>新建角色sprite</li>
<li>添加动画</li>
<li>添加刚体</li>
<li>添加collider。<code>circle</code>最好，可以保证移动时不翻转</li>
<li>给敌人加标签，便于编写脚本时获取</li>
</ol>
<h3 id="踩敌人消灭"><a href="#踩敌人消灭" class="headerlink" title="踩敌人消灭"></a>踩敌人消灭</h3><blockquote>
<p>判断角色是下落状态时，碰撞到敌人则destroy敌人</p>
</blockquote>
<h3 id="受伤"><a href="#受伤" class="headerlink" title="受伤"></a>受伤</h3><ol>
<li>添加受伤动画</li>
<li>在<code>Animator</code>添加hurt标志，调整不同状态转换的条件</li>
<li>编写受伤脚本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]private bool isHurt;&#x2F;&#x2F;判断是否受伤</span><br><span class="line">&#x2F;&#x2F;受伤动画转换</span><br><span class="line">else if (isHurt)</span><br><span class="line">&#123;</span><br><span class="line">    anim.SetBool(&quot;hurt&quot;, true);</span><br><span class="line">    anim.SetFloat(&quot;running&quot;, 0);&#x2F;&#x2F;保证受伤后处于静止状态而不是跑步状态</span><br><span class="line">    if (Mathf.Abs(rb.velocity.x) &lt; 0.1) &#123;&#x2F;&#x2F;判断角色是否已经反弹结束处于静止状态</span><br><span class="line">        isHurt &#x3D; false;</span><br><span class="line">        anim.SetBool(&quot;hurt&quot;, false);</span><br><span class="line">        anim.SetBool(&quot;idle&quot;, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;消灭敌人</span><br><span class="line">private void OnCollisionEnter2D(Collision2D collision)&#x2F;&#x2F;当该刚体碰撞另一个刚体时调用的函数</span><br><span class="line">&#123;</span><br><span class="line">    if (collision.gameObject.tag.Equals(&quot;Enemies&quot;)) &#123; &#x2F;&#x2F;函数代表的是整个碰撞器&#x2F;刚体，故需要.gameObject获其角色类</span><br><span class="line">    	&#x2F;&#x2F;消灭敌人</span><br><span class="line">        if (anim.GetBool(&quot;falling&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            Destroy(collision.gameObject);</span><br><span class="line">            &#x2F;&#x2F;增加消灭后再次小跳的效果</span><br><span class="line">            rb.velocity &#x3D; new Vector2(rb.velocity.x, jumpForce * Time.deltaTime);</span><br><span class="line">            anim.SetBool(&quot;jumping&quot;, true);</span><br><span class="line">        &#125;else if(transform.position.x &lt; collision.gameObject.transform.position.x)</span><br><span class="line">        &#123;&#x2F;&#x2F;增加受伤反弹的效果</span><br><span class="line">            rb.velocity &#x3D; new Vector2(-5, rb.velocity.y);</span><br><span class="line">            isHurt &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (transform.position.x &gt; collision.gameObject.transform.position.x)</span><br><span class="line">        &#123;</span><br><span class="line">            rb.velocity &#x3D; new Vector2(5, rb.velocity.y);</span><br><span class="line">            isHurt &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="敌人移动AI"><a href="#敌人移动AI" class="headerlink" title="敌人移动AI"></a>敌人移动AI</h3><ol>
<li>敌人角色下创建两个<code>GameObject</code>表示左右边界，设置移动边界位置（此时角色与边界为父子关系）</li>
<li>新建敌人脚本</li>
<li>新建两个<code>Transform</code>类表示左右边界，并在unity中拖入边界Object完成关联</li>
<li>在脚本中在start时获取边界的x值，然后将其边界Object销毁，保证其不随敌人角色移动</li>
<li>编写自动移动脚本</li>
<li>在unity设置初始speed使之移动<br>（以下均可选）</li>
<li>添加跳跃动画</li>
<li>设置相关条件，并编写动画切换脚本</li>
<li>在<code>Animation</code>界面静止状态最后一秒新建事件<code>event</code>，设置其事件函数为移动的movement。使敌人角色在播放完静止动画后执行移动函数，进行跳跃等其他动作。此时不需要在update中每秒执行movement函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Rigidbody2D rb;</span><br><span class="line">&#x2F;&#x2F;左右的行动边界</span><br><span class="line">public Transform leftPoint,rightPoint;</span><br><span class="line">private bool isFaceLeft &#x3D; true;</span><br><span class="line">public float speed;</span><br><span class="line">private float leftx, rightx;&#x2F;&#x2F;用于保存左右边界的x值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;敌人移动</span><br><span class="line">void Movement()</span><br><span class="line">&#123;</span><br><span class="line">    if (isFaceLeft)</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(-speed, rb.velocity.y);</span><br><span class="line">        if(transform.position.x &lt; leftx)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;控制敌人面向右边，即掉头</span><br><span class="line">            transform.localScale &#x3D; new Vector3(-1, 1, 1);</span><br><span class="line">            isFaceLeft &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(speed, rb.velocity.y);</span><br><span class="line">        if (transform.position.x &gt; rightx)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.localScale &#x3D; new Vector3(1, 1, 1);</span><br><span class="line">            isFaceLeft &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>Csharp-基础</title>
    <url>/post/3315830508.html</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(&quot;Hello World!&quot;); &#x2F;&#x2F;有换行符</span><br><span class="line">Console.Write(&quot;Hello New World&quot;!); &#x2F;&#x2F;无换行符</span><br></pre></td></tr></table></figure>

<p>C#区分大小写，字符串只能用<code>“”</code>，单字符char使用<code>&#39;&#39;</code></p>
<p>十进制文本：12.3m/12.3M（m/M-文本后缀）</p>
<a id="more"></a>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>字符类：string、char<br>计算类：int、decimal<br>布尔：bool</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量名区分大小写，使用驼峰命名法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char userOption;</span><br><span class="line">int gameScore;</span><br><span class="line">decimal particlesPerMillion;</span><br><span class="line">bool processedCustomer;</span><br></pre></td></tr></table></figure>

<p>使用前必须初始化。</p>
<p>可以使用<code>var</code>隐式创建变量。但初始化后推断出类型，则无法用另外的类型覆盖。且必须在初始化时使用，即<code>var word = &quot;hello!&quot;;</code></p>
<h4 id="逐字字符串"><a href="#逐字字符串" class="headerlink" title="逐字字符串"></a>逐字字符串</h4><p>逐字字符串文本保留所有空格和字符，且无需转义字符。使用时在文本字符串前加<code>@</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(&quot;C:\\Users\\Desktop&quot;);</span><br><span class="line">Console.WriteLine(@&quot;C:\Users\Desktop</span><br><span class="line">	(this is where your code goes)&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="字符串内插"><a href="#字符串内插" class="headerlink" title="字符串内插"></a>字符串内插</h4><p>使用“template”和一/多个内插表达式将多个值合为单个文本字符串。</p>
<p>内插表达式使用<code>{}</code></p>
<p>文本字符串使用<code>$</code>为前缀，该字符串变为模版</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string firstName &#x3D; &quot;Bob&quot;;</span><br><span class="line">Console.WriteLine($&quot;Hello &#123;firstName&#125;!&quot;);</span><br><span class="line"></span><br><span class="line">string projectName &#x3D; &quot;First-Project&quot;;</span><br><span class="line">Console.WriteLine($@&quot;C:\Output\&#123;projectName&#125;\Data&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>除法中商必须为<code>decimal</code>，且除数或被除数必须为<code>decimal</code>（或两者都是），才能保证完全准确的结果</p>
<p>运算顺序PEMDAS：</p>
<ul>
<li>P 圆括号</li>
<li>E 指数</li>
<li>M 乘法 和 D 除法</li>
<li>A 加法 和 S 减法</li>
</ul>
<p>C#顺序相同，但没有<code>指数</code>。可以使用<code>System.Math.Pow()</code>方法。</p>
<h3 id="NET类库"><a href="#NET类库" class="headerlink" title=".NET类库"></a>.NET类库</h3><p>包含成千上万个方法的类的集合。</p>
<p>命名空间可视为类型的“姓氏”，类被组织称不同的命名空间，以防发生命名冲突。命名空间有助于确保任何两个类中不具有相同的全名。</p>
<h4 id="状态方法"><a href="#状态方法" class="headerlink" title="状态方法"></a>状态方法</h4><p>“状态”用来描述特定时刻下执行环境的状况。在代码执行过程中，应用程序的当前状态为存储在内存中的所有值的集合。</p>
<ul>
<li><p>无状态方法（静态方法）：正常工作不依赖于应用程序的当前状态，即在不引用或更改内存中存储的任何值的情况下正常工作。</p>
</li>
<li><p>有状态方法（实例方法）：依赖于由以前的已执行代码行存储在内存中的值构建的，即有状态方法通过更新值或将新值存储在内存中来修改应用程序的状态。有状态方法在字段（类上定义的变量）中跟踪方法的状态。</p>
</li>
</ul>
<p>单个类可支持有状态方法和无状态方法。需要调用有状态方法时，必须先创建类的实例，才能访问状态。</p>
<p>类的实例即对象。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string[] ids &#x3D; new string[3];</span><br><span class="line">string[] scores &#x3D; &#123;&quot;Abc&quot;,&quot;cdsd&quot;,&quot;sss&quot;&#125;;</span><br><span class="line">int length &#x3D; scores.Length;</span><br><span class="line">foreach(string num in scores)&#123; &#x2F;&#x2F;将每个元素执行一次</span><br><span class="line">	Console.WriteLine(num); &#x2F;&#x2F; foreach中不能分配num的值，它为foreach迭代内部实现的一部分</span><br><span class="line">&#125;</span><br><span class="line">for(int i &#x3D; 0; i&lt;2; i++)&#123;</span><br><span class="line">	Console.WriteLine(scores[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>unity</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>unity-tilemap&amp;角色移动&amp;刚体&amp;碰撞</title>
    <url>/post/1100701572.html</url>
    <content><![CDATA[<h2 id="制作地图（Tilemap）"><a href="#制作地图（Tilemap）" class="headerlink" title="制作地图（Tilemap）"></a>制作地图（Tilemap）</h2><ol>
<li>设置素材大小<code>Pixels Per Unit</code>为合适的数值</li>
<li>设置sprite Mode为Multiple用于切割</li>
<li>打开素材Sprite Editor编辑，选择不同slice方式切割素材</li>
<li>选择每个单元格的素材在scene中绘制地图<a id="more"></a>

</li>
</ol>
<h2 id="添加角色"><a href="#添加角色" class="headerlink" title="添加角色"></a>添加角色</h2><ol>
<li>设置素材大小为合适数值</li>
<li>将角色拖至<code>Hierarchy</code>中，设置其<code>sorting layer</code></li>
<li>在<code>Animation</code>窗口添加多张图片以添加动画</li>
<li>拖拽时间轴使动画频率合适</li>
</ol>
<h2 id="刚体–Rigidbody"><a href="#刚体–Rigidbody" class="headerlink" title="刚体–Rigidbody"></a>刚体–Rigidbody</h2><blockquote>
<p>让平面物体拥有重量，使其有重力，阻力等，可以受力的作用</p>
</blockquote>
<ol>
<li><code>Add Component</code>中选择<code>Rigidbody 2D</code></li>
<li>设置<code>Gravity Scale</code>重力为合适的数值</li>
<li>若使角色保持直立，则勾选<code>Constraints</code>中<code>Freeze Rotation</code>的Z轴使之锁定</li>
</ol>
<h2 id="碰撞–Collider"><a href="#碰撞–Collider" class="headerlink" title="碰撞–Collider"></a>碰撞–Collider</h2><blockquote>
<p>让物体可碰撞，接触。</p>
</blockquote>
<ol>
<li><code>Add Component</code>中选择需要的collider</li>
<li>勾选<code>Edit Collider</code>编辑角色碰撞的范围</li>
<li>设置不同图层，使角色与环境分离</li>
</ol>
<h2 id="角色移动"><a href="#角色移动" class="headerlink" title="角色移动"></a>角色移动</h2><ol>
<li><code>Edit</code>-&gt;<code>Project Settings</code>-&gt;<code>Input Manager</code>获取需要的输入信息</li>
<li>左右方向Horizontal，-1为左，0不动，1为右</li>
<li>编写脚本，距离=速度speed*单位位移*Time.delTime（delTime保证不同环境下都能顺滑移动），speed越高，移动的越快</li>
<li>跳跃时给角色添加跳跃的力<code>jumpForce</code>，在unity脚本页面设置的jumpForce越大跳的越高</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]private Rigidbody2D rb;</span><br><span class="line">public float speed;</span><br><span class="line">public float jumpForce;</span><br><span class="line"></span><br><span class="line">void movement()</span><br><span class="line">&#123;</span><br><span class="line">    float horizontalMove &#x3D; Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">    float faceDirection &#x3D; Input.GetAxisRaw(&quot;Horizontal&quot;);</span><br><span class="line">    &#x2F;&#x2F;角色移动</span><br><span class="line">    if(horizontalMove !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(horizontalMove * speed * Time.deltaTime, rb.velocity.y);</span><br><span class="line">        anim.SetFloat(&quot;running&quot;, Mathf.Abs(faceDirection)); </span><br><span class="line">    &#125;</span><br><span class="line">    if(faceDirection !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        transform.localScale &#x3D; new Vector3(faceDirection, 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;角色跳跃</span><br><span class="line">    if (Input.GetButtonDown(&quot;Jump&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        rb.velocity &#x3D; new Vector2(rb.velocity.x, jumpForce * Time.deltaTime);</span><br><span class="line">        anim.SetBool(&quot;jumping&quot;, true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="角色移动时动画的改变"><a href="#角色移动时动画的改变" class="headerlink" title="角色移动时动画的改变"></a>角色移动时动画的改变</h2><ol>
<li>新建动画</li>
<li>打开<code>Animator</code>设置不同改变顺序</li>
<li>点击各箭头关闭<code>Has Exit Time</code>和<code>Transition Duration</code>使变化没有延迟时间</li>
<li>若需要变化条件，则在<code>Parameter</code>中新建不同的参数用于脚本使用</li>
<li>并在<code>Conditions</code>处设置不同的条件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[SerializeField]private Rigidbody2D rb;</span><br><span class="line">[SerializeField]private Animator anim;</span><br><span class="line"></span><br><span class="line">void switchAnim()</span><br><span class="line">    &#123;</span><br><span class="line">        anim.SetBool(&quot;idle&quot;, false);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;跳跃到下落动画切换</span><br><span class="line">        if (anim.GetBool(&quot;jumping&quot;))</span><br><span class="line">        &#123;</span><br><span class="line">            if(rb.velocity.y &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                anim.SetBool(&quot;jumping&quot;, false);</span><br><span class="line">                anim.SetBool(&quot;falling&quot;, true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if (coll.IsTouchingLayers(ground))&#x2F;&#x2F;下降到地面动画切换</span><br><span class="line">        &#123;</span><br><span class="line">            anim.SetBool(&quot;falling&quot;, false);</span><br><span class="line">            anim.SetBool(&quot;idle&quot;, true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="一些记录"><a href="#一些记录" class="headerlink" title="一些记录"></a>一些记录</h2><p>Input.GetAxis()//获取-1～0，0～1<br>Input.GetAxisRaw()//仅获取-1.0.1，左，不动，右</p>
<p>Vector2: 2维变化<br>Vector3: 3维变化    </p>
<p>FixedUpdate();<br>Update();</p>
<p>LayerMask: 在脚本中获取图层</p>
<p>public可以在script里看到<br>private不能看到，在start里初始化<br>[SerializeField]private则可以看到，但不能改</p>
]]></content>
      <categories>
        <category>unity</category>
      </categories>
      <tags>
        <tag>unity</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS设置div垂直横向居中</title>
    <url>/post/3983223589.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre><code>最近写公司登陆页面，打算设置登录框水平竖直均居中，尝试了各种方式，最终解决方式如下</code></pre><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><pre><code>父级div：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.login-div&#123;</span><br><span class="line">	width: 100%,</span><br><span class="line">	height: 100%,</span><br><span class="line">	overflow: hidden</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

子级登录框：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.login-box&#123;</span><br><span class="line">	&#x2F;&#x2F; 以左上角为原点,不处以中心位置</span><br><span class="line">	top: 50%,</span><br><span class="line">	left: 50%,</span><br><span class="line">	&#x2F;&#x2F; 往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置</span><br><span class="line">	transform: translate(-50%,-50%)</span><br><span class="line">	position: absolute</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>React(5)-构建React应用的一般步骤</title>
    <url>/post/3896685751.html</url>
    <content><![CDATA[<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>获得一张组件设计图和后台返回的JSON数据。<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0bqnovjoj30f60g00uz.jpg" alt="设计图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="划分组件层级"><a href="#划分组件层级" class="headerlink" title="划分组件层级"></a>划分组件层级</h2><p>按照给定的组件设计图，划分组件层级。</p>
<p>将组件看作函数或对象来考虑，根据单一功能原则判定组件范围，即一个组件只负责一个功能。若负责多个功能则考虑将其拆分。</p>
<p>按给定的JSON数据模型设计UI（组件结构），使两者一一对应。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ge0byibhvyj30es0g876c.jpg" alt="划分组件"></p>
<p>如上图，可将整个设计图层级分为5部分：</p>
<ol>
<li>红色区域（FilterProductTable）：整个组件应用整体</li>
<li>绿色区域（SearchBar）：获取用户输入部分</li>
<li>蓝色部分（ProductTable）：整个数据展示部分</li>
<li>粉色部分（ProductCategoryRow）：数据展示部分的产品分类标题部分</li>
<li>橘色部分（ProductRow）：数据展示部分的分类下每个产品的部分。</li>
</ol>
<p>层级关系可表示为：</p>
<ul>
<li>FilterProductTable<ul>
<li>SearchBar</li>
<li>ProductTable<ul>
<li>ProductCategoryRow</li>
<li>ProductRow</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="根据层级关系编写应用的静态版本"><a href="#根据层级关系编写应用的静态版本" class="headerlink" title="根据层级关系编写应用的静态版本"></a>根据层级关系编写应用的静态版本</h2><p>应用静态版本即使用已有的数据模型渲染一个不包含交互的UI。</p>
<p>静态版本不需要考虑交互细节，而添加交互功能需要考虑大量的细节。故在实际应用中分开进行更合适。构建静态版本只需要通过props传入所需的数据，props是父组件向子组件传递数据的方式。此时不需要考虑state，因为state代表会随时间变化的数据，应只在交互时使用。</p>
<p>编写静态版本有两种方式：自上而下和自下而上。</p>
<ol>
<li>自上而下：先构建层级较高的组件，再自上而下分步细化组件。适用于构建简单的应用。</li>
<li>自下而上：先构建最基本的组件，再一层一层向上构建。适用于构建大型的项目。</li>
</ol>
<p>静态版本的组件提供<code>render()</code>方法用于渲染数据模型。故当数据模型改变，则调用<code>ReactDOM.render()</code>重新渲染，UI相应更新，即React的单向数据流思想。</p>
<p>相应代码见<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React官方文档</a></p>
<h2 id="确定state变量"><a href="#确定state变量" class="headerlink" title="确定state变量"></a>确定state变量</h2><blockquote>
<p>全称:Don’t Repeat Yourself (摘自wikipedia),是指编程过程中不写重复代码,将能够公共的部分抽象出来,封装成工具类或者用“abstraction”类来抽象公有的东西,降低代码的耦合性,</p>
</blockquote>
<p>按照DRY原则，只保留应用所需的<code>state</code>的最小集合，其他数据由此<code>state</code>计算得出。</p>
<p>确定<code>state</code>需考虑以下问题：</p>
<ol>
<li>该数据是否由父组件通过<code>props</code>传递而来，若是，则不是<code>state</code></li>
<li>该数据是否变化？若保持不变，则不是<code>state</code></li>
<li>该数据是否能根据其他数据计算而来，若是，则不是<code>state</code>。</li>
</ol>
<p>由上文可得，产品的所有信息都可由父组件<code>FilterProductTable</code>传递而来，故不是<code>state</code>。<code>SearchBar</code>中的搜索字段和checkbox选中值需要由用户交互而变化，且无法由其他数据计算而来，故应该为<code>state</code></p>
<h2 id="确定state位置"><a href="#确定state位置" class="headerlink" title="确定state位置"></a>确定state位置</h2><p>由于React的数据是单向流动，且按组件层级自上而下传递，故<code>state</code>所属的组件很难确定。</p>
<p>判断时，依照如下步骤考虑：</p>
<ol>
<li>查看根据此<code>state</code>渲染的所有组件</li>
<li>找到这些组件的共同所有者组件，即层级高于这些组件的组件</li>
<li>该共同所有者组件或比他层级更高的组件应该拥有此<code>state</code></li>
<li>若无法找到合适的位置存放<code>state</code>，则可以创建一个新的组件来存放<code>state</code>。</li>
</ol>
<p>根据上述步骤，可发现：</p>
<ol>
<li><code>SearchBar</code>和<code>ProductTable</code>都需要此state。<code>SearchBar</code>需要state展示搜索框和checkbox的状态。<code>ProductTable</code>需要根据state筛选产品列表。</li>
<li><code>SearchBar</code>和<code>ProductTable</code>的共同所有者是<code>FilterProductTable</code></li>
<li>因此state应存放在<code>FilterProductTable</code>中。</li>
</ol>
<p>首先，将实例属性<code>this.state = {filterText: &#39;&#39;, inStockOnly: false}</code>添加到<code>FilterableProductTable</code>的 <code>constructor</code>中，设置应用的初始 <code>state</code>；接着，将<code>filterText</code>和<code>inStockOnly</code>作为<code>props</code>传入 <code>ProductTable</code>和<code>SearchBar</code>；最后，用这些<code>props</code>筛选<code>ProductTable</code>中的产品信息，并设置<code>SearchBar</code>的表单值。</p>
<p>相应代码见<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React官方文档</a></p>
<h2 id="添加state的数据流控制"><a href="#添加state的数据流控制" class="headerlink" title="添加state的数据流控制"></a>添加state的数据流控制</h2><p>之前步骤通过props和state自上而下传递了需要的数据。现在控制处于较低层级的表单组件更新较高组件中的state，以达到完成交互。</p>
<p>要实现的功能是：<br>用户改变表单的值-&gt;改变state反映用户输入。</p>
<p>state只能由拥有它的组件进行更改，故需要设置一个能触发state改变的回调函数传递给SearchBar。思路为：</p>
<ol>
<li>使用输入框的onChange事件监视用户输入</li>
<li>当用户改变表单的值，触发onChange事件，调用表单组件的handle方法。</li>
<li>表单组件的handle方法调用父组件FilterProductTable的onFilterTextChange事件</li>
<li>FilterProductTable的handleFilterTextChange方法使用setState改变state的值，更新应用</li>
</ol>
<p>所有代码见<a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React官方文档</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(4)-状态提升及组合</title>
    <url>/post/1961399673.html</url>
    <content><![CDATA[<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>React应用中，任何可变的数据应只有一个唯一数据源，此时state首先添加到需要渲染的组件中。但当多个组件需要共用反映同样的变化数据时，即其他组件也需要这个state时，需要将state提升到这些组件的共同父组件中。通过自顶向下的数据源，更新唯一的数据源state。</p>
<p>在子组件中使用<code>this.props.xxx</code>代替<code>this.state</code>。在共同父组件中使用<code>state</code>更新子组件中的值。</p>
<a id="more"></a>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>React有丰富的组合模式，供组件间的代码重用。</p>
<h3 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function FancyBorder(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&#123;&#39;FancyBorder FancyBorder-&#39; + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color&#x3D;&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&quot;Dialog-title&quot;&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p className&#x3D;&quot;Dialog-message&quot;&gt;</span><br><span class="line">        Thank you for visiting our spacecraft!</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WelcomeDialog</code>方法中<code>&lt;FancyBorder&gt;</code>标签内的内容对应<code>FancyBorder</code>函数里的<code>{props.children}</code>，此时<code>props.children</code>中的内容都被渲染到<code>&lt;div&gt;</code>中。</p>
<p>也可以通过标签属性来自行约定<code>children</code>，将所需的内容传入props。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Contacts() &#123;</span><br><span class="line">  return &lt;div className&#x3D;&quot;Contacts&quot; &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Chat() &#123;</span><br><span class="line">  return &lt;div className&#x3D;&quot;Chat&quot; &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function SplitPane(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;SplitPane&quot;&gt;</span><br><span class="line">      &lt;div className&#x3D;&quot;SplitPane-left&quot;&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div className&#x3D;&quot;SplitPane-right&quot;&gt;</span><br><span class="line">        &#123;props.right&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SplitPane</span><br><span class="line">      left&#x3D;&#123;</span><br><span class="line">        &lt;Contacts &#x2F;&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right&#x3D;&#123;</span><br><span class="line">        &lt;Chat &#x2F;&gt;</span><br><span class="line">      &#125; &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中<code>&lt;Contacts /&gt;</code>和<code>&lt;Chat /&gt;</code>本质即为对象，故可以当作props来传递。</p>
<h3 id="特例关系"><a href="#特例关系" class="headerlink" title="特例关系"></a>特例关系</h3><p>有些组件可看作其他组件的特殊实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Dialog(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color&#x3D;&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&quot;Dialog-title&quot;&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;p className&#x3D;&quot;Dialog-message&quot;&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Dialog</span><br><span class="line">      title&#x3D;&quot;Welcome&quot;</span><br><span class="line">      message&#x3D;&quot;Thank you for visiting our spacecraft!&quot; &#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(3)-列表及简单表单</title>
    <url>/post/276282746.html</url>
    <content><![CDATA[<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>使用<code>{}</code>在JSX构建一个元素集合。<br>使用JS的<code>map()</code>方法遍历数组，将数组中的元素变成<code>&lt;li&gt;</code>标签。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const number &#x3D; [1,2,3,4,5];</span><br><span class="line">const listitems &#x3D; numbers.map((number) &#x3D;&gt; </span><br><span class="line">    &lt;li&gt;&#123;number&#125;&lt;&#x2F;li&gt;</span><br><span class="line">);</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;&#x2F;ul&gt;,</span><br><span class="line">document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>当创建元素时必须包含一个key属性。key属性帮助React识别元素的变化。</p>
<h4 id="key的正确使用"><a href="#key的正确使用" class="headerlink" title="key的正确使用"></a>key的正确使用</h4><p>一个元素的key最好是元素在列表中拥有的独一无二的字符串，万不得已时才使用索引作为key。</p>
<p>元素的key只有放在就近的数组上下文才有意义。故如果提取一个组件，就应把组件的key保留在该组件的元素上，而不是它里面的子元素上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ListItem(props)&#123;</span><br><span class="line">    &#x2F;&#x2F;子元素无需指定key</span><br><span class="line">    return &lt;li&gt;&#123;props.value&#125;&lt;&#x2F;li&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function NumberList(props)&#123;</span><br><span class="line">    const numbers &#x3D; props.numbers;</span><br><span class="line">    const listItems &#x3D; numbers.map((number) &#x3D;&gt;</span><br><span class="line">    &#x2F;&#x2F;key应在数组的上下文中指定，经验法则：在map()中的元素需指定key属性</span><br><span class="line">        &lt;ListItem key&#x3D;&#123;number.toString()&#125; value&#x3D;&#123;number&#125; &#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">    return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers &#x3D; [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers&#x3D;&#123;numbers&#125; &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="key的唯一性"><a href="#key的唯一性" class="headerlink" title="key的唯一性"></a>key的唯一性</h4><p>key在兄弟节点之间必须唯一，但不是全局唯一。即当有两个不同的数组时，key可以相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const sidebar &#x3D; (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.posts.map((post) &#x3D;&gt;</span><br><span class="line">        &lt;li key&#x3D;&#123;post.id&#125;&gt;</span><br><span class="line">          &#123;post.title&#125;</span><br><span class="line">        &lt;&#x2F;li&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">  );</span><br><span class="line">  const content &#x3D; props.posts.map((post) &#x3D;&gt;</span><br><span class="line">    &lt;div key&#x3D;&#123;post.id&#125;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;post.title&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;post.content&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>key传递信息给React，但不会传递给组件。因此，若需要使用key的值，需要使用其他属性将其显式的传递出来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const content &#x3D; posts.map((post) &#x3D;&gt;</span><br><span class="line">  &lt;Post</span><br><span class="line">    key&#x3D;&#123;post.id&#125;</span><br><span class="line">    id&#x3D;&#123;post.id&#125;</span><br><span class="line">    title&#x3D;&#123;post.title&#125; &#x2F;&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="在JSX中嵌入map"><a href="#在JSX中嵌入map" class="headerlink" title="在JSX中嵌入map()"></a>在JSX中嵌入map()</h3><p>以上都是声明单独的变量并将其包含在JSX中，但JSX允许在大括号<code>{}</code>中嵌入表达式，因此可以直接内联<code>map()</code>返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function NumberList(props)&#123;</span><br><span class="line">    const numbers &#x3D; props.numbers;</span><br><span class="line">    return (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;numbers.map((number) &#x3D;&gt; </span><br><span class="line">                &lt;ListItem key&#x3D;&#123;number.toString()&#125;</span><br><span class="line">                          value&#x3D;&#123;number&#125;</span><br><span class="line">                &#x2F;&gt;</span><br><span class="line">            )&#125;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>HTML表单与其他DOM元素不同，它内部通常保持一些state，大多情况下，使用JavaScript函数可以方便的处理表单提交，同时访问用户填写的表单数据。实现此效果的标准方式是使用受控组件</p>
<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>受控组件使React的state成为唯一数据源。渲染表单的React组件控制用户输入过程中发生的操作。（结合state及事件处理操作）</p>
<h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    &#x2F;&#x2F;输入input组件值由state控制，此处设置初始值。</span><br><span class="line">    this.state &#x3D; &#123;value: &#39;&#39;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit &#x3D; this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;input框内容改变事件</span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;提交内容事件</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&#39;提交的名字: &#39; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          名字:</span><br><span class="line">          &#x2F;&#x2F;state.value是input框的唯一数据源</span><br><span class="line">          &#x2F;&#x2F;onChange事件会在用户每一次按键后更新React的state</span><br><span class="line">          &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h4><p>text的使用与input相同，但默认有初值</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select选择框的选中属性使用value控制，而不使用selected属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;value: &#39;coconut&#39;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit &#x3D; this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          选择你喜欢的风味:</span><br><span class="line">          &lt;select value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;grapefruit&quot;&gt;葡萄柚&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;lime&quot;&gt;酸橙&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;coconut&quot;&gt;椰子&lt;&#x2F;option&gt;</span><br><span class="line">            &lt;option value&#x3D;&quot;mango&quot;&gt;芒果&lt;&#x2F;option&gt;</span><br><span class="line">          &lt;&#x2F;select&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>option内容也可直接在select标签内将数组传递到vlue属性。使用多选时，设置<code>multiple={true}</code></p>
<h3 id="接受多个输入"><a href="#接受多个输入" class="headerlink" title="接受多个输入"></a>接受多个输入</h3><p>当需要处理多个input元素时，给每个元素添加<code>name</code>属性，处理函数根据<code>event.target.name</code>选择要执行的操作。<code>setState()</code>自动将部分state合并到当前state。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Reservation extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      isGoing: true,</span><br><span class="line">      numberOfGuests: 2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleInputChange &#x3D; this.handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    const target &#x3D; event.target;</span><br><span class="line">    const value &#x3D; target.name &#x3D;&#x3D;&#x3D; &#39;isGoing&#39; ? target.checked : target.value;</span><br><span class="line">    const name &#x3D; target.name;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          参与:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;isGoing&quot;</span><br><span class="line">            type&#x3D;&quot;checkbox&quot;</span><br><span class="line">            checked&#x3D;&#123;this.state.isGoing&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">        &lt;br &#x2F;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          来宾人数:</span><br><span class="line">          &lt;input</span><br><span class="line">            name&#x3D;&quot;numberOfGuests&quot;</span><br><span class="line">            type&#x3D;&quot;number&quot;</span><br><span class="line">            value&#x3D;&#123;this.state.numberOfGuests&#125;</span><br><span class="line">            onChange&#x3D;&#123;this.handleInputChange&#125; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;label&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(2)-事件处理及条件渲染</title>
    <url>/post/3697640733.html</url>
    <content><![CDATA[<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><blockquote>
<p>为了与传统HTML区别开，React事件命名采用小驼峰（camelCase）形式。<br>使用JSX语法时需要传入函数作为事件处理函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&#123;function&#125;&gt;</span><br><span class="line">Function</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ol>
<li><p>阻止默认行为必须显式的使用<code>preventDefault</code></p>
<a id="more"></a>    

 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ActionLink()&#123;</span><br><span class="line">    function handleClick(e)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        console.log(&quot;Clicked!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return (</span><br><span class="line">        &lt;a href&#x3D;&quot;#&quot; onClick&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">        Click me!</span><br><span class="line">        &lt;&#x2F;a&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> e为合成事件，无跨浏览器的兼容问题。</p>
</li>
<li><p>使用React不需要使用<code>addEventListener</code>为DOM元素添加监听器。只需要在元素初始渲染时添加监听器即可。</p>
</li>
<li><p>使用class定义组件时，通常将事件处理函数声明为class的方法。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    class Toggle extends React.Component &#123;</span><br><span class="line">        constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state &#x3D; &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 为了在回调中使用 &#96;this&#96;，这个绑定是必不可少的</span><br><span class="line">        this.handleClick &#x3D; this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      isToggleOn: !state.isToggleOn</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class="line">            &#123;this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;&#125;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &lt;Toggle &#x2F;&gt;,</span><br><span class="line">        document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p> JavaScript中class方法默认不会绑定this。若在JSX中没有绑定this.handleClick并把它传入onClick。则调用函数时，this的值为undifined。</p>
</li>
<li><p>事件绑定this<br> <strong>优先使用方法一和方法二</strong></p>
<ul>
<li><p>方法一：bind<br>如3中代码所示</p>
</li>
<li><p>方法二：class field语法<br>class field语法为实验性语法</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LoggingButton extends React.Component&#123;</span><br><span class="line">    handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;this is:&#39;, this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class="line">            Click me</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  create React app默认使用该方法。</p>
</li>
<li><p>方法三：回调函数中使用箭头函数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    class LoggingButton extends React.Component &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">        console.log(&#39;this is:&#39;, this);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">        &#x2F;&#x2F; 此语法确保 &#96;handleClick&#96; 内的 &#96;this&#96; 已被绑定。</span><br><span class="line">            return (</span><br><span class="line">                &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.handleClick()&#125;&gt;</span><br><span class="line">                Click me</span><br><span class="line">            &lt;&#x2F;button&gt;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h3 id="向事件处理函数传递参数"><a href="#向事件处理函数传递参数" class="headerlink" title="向事件处理函数传递参数"></a>向事件处理函数传递参数</h3><p>当向事件处理函数传递额外参数时，有两种方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;方法一：箭头函数</span><br><span class="line">&lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; this.deleteRow(id, e)&#125;&gt;Delete&lt;&#x2F;button&gt;</span><br><span class="line">&#x2F;&#x2F;方法二：Function.prototype.bind</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.deleteRow.bind(this,id)&#125;&gt;Delete&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>箭头函数中，事件对象e必须显式的传递，bind方式，事件对象e及更多参数会被隐式的传递。</p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="使用if渲染"><a href="#使用if渲染" class="headerlink" title="使用if渲染"></a>使用if渲染</h3><p>即if-else语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(条件)&#123;</span><br><span class="line">    return 元素1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    return 元素2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;或</span><br><span class="line">let 变量;</span><br><span class="line">if(条件)&#123;</span><br><span class="line">    变量 &#x3D; 元素1;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    变量 &#x3D; 元素2;</span><br><span class="line">&#125;</span><br><span class="line">return (变量);</span><br></pre></td></tr></table></figure>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>条件运算符为JSX中内联条件渲染的方法，通过花括号<code>{}</code>包裹代码。</p>
<h4 id="使用-amp-amp-渲染"><a href="#使用-amp-amp-渲染" class="headerlink" title="使用&amp;&amp;渲染"></a>使用&amp;&amp;渲染</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;条件 &amp;&amp; 表达式&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>true &amp;&amp; expression</code> =&gt; <code>expression</code><br><code>false &amp;&amp; expression</code> =&gt; <code>false</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="line">&lt;h2&gt;</span><br><span class="line">You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">&lt;&#x2F;h2&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; condition ? true expression : false expression&#125;</span><br></pre></td></tr></table></figure>


<h3 id="阻止渲染（隐藏组件）"><a href="#阻止渲染（隐藏组件）" class="headerlink" title="阻止渲染（隐藏组件）"></a>阻止渲染（隐藏组件）</h3><p>若希望组件隐藏，可以让<code>render</code>方法返回<code>null</code>。不进行任何渲染，此种方式不会影响组件的生命周期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function WarningBanner(props) &#123;</span><br><span class="line">  if (!props.warn) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;warning&quot;&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Page extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;showWarning: true&#125;;</span><br><span class="line">    this.handleToggleClick &#x3D; this.handleToggleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    this.setState(state &#x3D;&gt; (&#123;</span><br><span class="line">      showWarning: !state.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn&#x3D;&#123;this.state.showWarning&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.showWarning ? &#39;Hide&#39; : &#39;Show&#39;&#125;</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page &#x2F;&gt;,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>React(1)-基础知识</title>
    <url>/post/628658596.html</url>
    <content><![CDATA[<h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>React是一个声明式，高效且灵活的用于构建用户界面的JavaScript库。使用React可以将一些简短、独立的代码片段组合成复杂的UI界面，这些代码片段称为“组件”。</p>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>JSX是JavaScript的语法拓展，可以生成React“元素”。React认为渲染逻辑与其他UI逻辑内在耦合，故其没有采用将标记和逻辑分离在不同文件的方式，而是将他们共同存入“组件”的松散耦合单元中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;JSX语法</span><br><span class="line">&lt;div &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F;等同于</span><br><span class="line">React.createElement(&#39;div&#39;)</span><br></pre></td></tr></table></figure>

<p>在JSX中可以任意使用JavaScript表达式，只需要用大括号<code>{}</code>括起来。</p>
<a id="more"></a>
<ul>
<li><p>使用<code>{}</code>嵌入元素：可嵌入变量、表达式、函数等。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello,&#123;formatName(user)&#125;&lt;&#x2F;h1&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>&quot;&quot;</code>：将属性值指定为字符串字面量。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;div tabIndex&#x3D;&quot;0&quot;&gt;&lt;&#x2F;div&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>{}</code>：在属性值插入一个JavaScript表达式。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;img src&#x3D;&#123;user.avatarUrl&#125;&gt;&lt;&#x2F;img&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>JSX可以安全的插入用户输入的内容：React DOM渲染输入内容前，默认会进行转义。可以确保在应用中，永远不会注入并非自己明确编写的内容。所有内容渲染之前都被转换成了字符串。此方法可以有效防止XSS（跨站脚本）攻击。</p>
</li>
<li><p><code>React.createElement()</code>：创建React对象，即React元素。描述了用户希望在屏幕上看到的内容。React通过读取这些对象并使用他们来构建DOM以及保持随时更新。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &#123;</span><br><span class="line">    &lt;h1 className&#x3D;&quot;greeting&quot;&gt;</span><br><span class="line">        Hello, world!</span><br><span class="line">    &lt;&#x2F;h1&gt;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;等价于</span><br><span class="line">const element &#x3D; React.createElement(</span><br><span class="line">    &#39;h1&#39;,</span><br><span class="line">    &#123;className: &#39;greeting&#39;&#125;,</span><br><span class="line">    &#39;Hello, world!&#39;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;创建对象的结构如下：</span><br><span class="line">const element &#x3D; &#123;</span><br><span class="line">    type: &#39;h1&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        className: &#39;greeting&#39;,</span><br><span class="line">        children: &#39;Hello, world!&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注意点：</p>
<ol>
<li><p>空元素必须用/结束，如<code>&lt;br /&gt;</code></p>
</li>
<li><p>根元素不能为两个，如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;Hello World!&lt;p&gt;</span><br><span class="line">    &lt;br&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;&lt;p&gt;和&lt;br&#x2F;&gt;为两个根元素，故只能用&lt;div&gt;包起来。</span><br></pre></td></tr></table></figure></li>
<li><p>JSX的属性和方法命名规则都必须为小驼峰，如<code>className</code></p>
</li>
<li><p>if使用<code>&amp;&amp;</code>表示，<code>&amp;&amp;</code>前为条件，后为执行的JSX语句</p>
</li>
<li><p>if-else使用<code>a?b:c</code>，a为条件，是执行b，else执行c</p>
</li>
<li><p>循环语句使用数组的map方法实现，在回调函数里处理每个子元素。为了方便的找出哪个节点有更新，其循环的子元素都必须加唯一id。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.map((number) &#x3D;&gt; </span><br><span class="line">    &lt;listItem key&#x3D;&#123;number.toString()&#125;       &#x2F;&#x2F;key-&gt;唯一id</span><br><span class="line">              value&#x3D;&#123;number&#125; &#x2F;&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h3><p>元素是构成React应用的最小模块，是创建开销极小的普通对象。</p>
<p>每一个React元素都是一个JavaScript对象，可以在程序中保存到变量中或作为参数传递。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello, world&lt;&#x2F;h1&gt;;</span><br></pre></td></tr></table></figure>

<p>若要将React元素渲染到根DOM节点root，使用ReactDOM.render()。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const element &#x3D; &lt;h1&gt;Hello, world&lt;&#x2F;h1&gt;;</span><br><span class="line">ReactDOM.render(element, document.getElementById(&#39;root&#39;));</span><br></pre></td></tr></table></figure>

<p>React元素不可变。一旦被创建就无法更改它的子元素或属性，它代表了某个特定时刻的UI。要修改元素只能通过重新绑定新的元素渲染或通过state修改。</p>
<h3 id="组件及Props"><a href="#组件及Props" class="headerlink" title="组件及Props"></a>组件及Props</h3><p>组件，类似于JavaScript函数，接受任意的入参（props），通过<code>render</code>方法返回用于描述页面展示内容的React元素。</p>
<p>两种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法一：函数</span><br><span class="line">function Welcome(props)&#123;</span><br><span class="line">    return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：ES6的class</span><br><span class="line">class Welcome extends React.Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;h1&gt;Hello,&#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Welcome(props)&#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">const element &#x3D; &lt;Welcome name&#x3D;&quot;Sara&quot; &#x2F;&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&#39;root&#39;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意：组件名称必须使用大写字母开头。</p>
<p>自定义组件可以在其输出（return ）中引入其他组件，即组合组件。</p>
<h4 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h4><p>多层嵌套的组合组件若其中包含可复用的组件，可将组件提取出来，构建可复用的组件库。同样，若组件本身过于复杂，也可将其中的元素提取成组件，构建为可复用的组件。</p>
<blockquote>
<p>注意：组件的props绝不能修改，要像纯函数一样保护props不被修改。</p>
</blockquote>
<p>纯函数：函数不会更改入参，多次调用下相同的入参返回相同的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;非纯函数</span><br><span class="line">function test(a,b)&#123;</span><br><span class="line">    a +&#x3D; b;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;纯函数</span><br><span class="line">function test(a,b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数组件转换class组件"><a href="#函数组件转换class组件" class="headerlink" title="函数组件转换class组件"></a>函数组件转换class组件</h4><ol>
<li>创建同名<code>ES6 class</code>，继承于<code>React.Component</code>。</li>
<li>添加空的<code>render()</code>方法。</li>
<li>将函数组件的函数体移入<code>render()</code>方法中。</li>
<li>将<code>render()</code>方法中的<code>props</code>改为<code>this.props</code>。</li>
<li>删除空的函数组件。</li>
</ol>
<h3 id="state-amp-生命周期"><a href="#state-amp-生命周期" class="headerlink" title="state&amp;生命周期"></a>state&amp;生命周期</h3><blockquote>
<p>React把组件看作状态机。通过与用户的交互，实现不同的状态，渲染UI，让用户界面和数据保持一致。state与props类似，但state是私有的，完全受控于当前组件。React中，只需更新组件的state，根据新的state重新渲染用户界面。</p>
</blockquote>
<p>使用构造函数初始化<code>this.state</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props)&#123;</span><br><span class="line">    &#x2F;&#x2F;使用super函数将props传递到父类的构造函数中</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;date: new Date()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>render()</code>函数中使用<code>this.state</code>获取state中的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><blockquote>
<p>当组件第一次被渲染到DOM中时，调用<code>componentDidMount()</code>函数=&gt; 挂载(mount)<br>当组件被删除时，调用<code>componentWillUnmount()</code>。=&gt;卸载(unmount)</p>
</blockquote>
<p><strong>调用顺序：</strong></p>
<ol>
<li>当组件传给React.render()时，React调用组件的构造函数constructor()初始化this.state。</li>
<li>React调用render()方法。确定在该页面展示内容。更新DOM渲染输出。</li>
<li>当组件的输出插入到DOM后，调用componentDidMount()方法设置挂载时需运行的内容。</li>
<li>若需更新state，需在挂载内容时使用setState()方法更新state。并重新调用render()渲染更新过的数据，相应的更新DOM。</li>
<li>当组件从DOM移除，React调用componentWillUnmount()方法卸载。</li>
</ol>
<h4 id="state注意事项"><a href="#state注意事项" class="headerlink" title="state注意事项"></a>state注意事项</h4><ol>
<li><p>更新state<br>直接修改<code>state</code>不会重新渲染组件，如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;此种修改不会渲染组件</span><br><span class="line">this.state.comment &#x3D; &quot;Hello&quot;; </span><br><span class="line">&#x2F;&#x2F;使用setState才能达到更新目的</span><br><span class="line">this.setState(&#123;comment: &#39;Hello&#39;&#125;);</span><br></pre></td></tr></table></figure>
<p> 构造函数是唯一可以给<code>this.state</code>赋值的地方。</p>
</li>
<li><p>state更新可能异步<br> <code>this.props</code>和<code>this.state</code>可能是异步更新的，故如下操作无法更新内容：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;wrong</span><br><span class="line">this.setState(&#123;</span><br><span class="line">    counter: this.state.counter + this.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;true</span><br><span class="line">&#x2F;&#x2F;若想更新，可让setState()接受函数，而非对象。</span><br><span class="line">this.setState((state, props) &#x3D;&gt; (&#123;</span><br><span class="line">    counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br><span class="line">&#x2F;&#x2F;不使用匿名箭头函数，使用普通函数也可</span><br></pre></td></tr></table></figure>
</li>
<li><p>state合并更新<br> 出于性能考虑，React可能会把多个<code>setState()</code>合并成一个调用。并将提供的对象合并到当前的<code>state</code>，进行部分替换，而非全局覆盖。<br> 如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(props)&#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">        posts: [],</span><br><span class="line">        comments: []</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;更新posts时，只会替换posts部分，comments不变。更新comments同理。</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    fetchPosts().then(response &#x3D;&gt; &#123;</span><br><span class="line">        this.setState(&#123;posts: response.posts&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数据自顶向下<br>无论父组件还是子组件都无法知道某组件是否有状态，且不关心是函数组件还是class组件。除了拥有并设置了state的组件，其他组件都无法访问。但组件可以选择把它的state作为props向下传递给它的子组件。从该state派生的任何数据或UI只能影响树中低于它的组件。<br>每个组件都是真正独立的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>React</tag>
        <tag>SPA</tag>
      </tags>
  </entry>
  <entry>
    <title>前后端分离与SPA的理解</title>
    <url>/post/3950340485.html</url>
    <content><![CDATA[<h2 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h2><h3 id="一些概念理解"><a href="#一些概念理解" class="headerlink" title="一些概念理解"></a>一些概念理解</h3><ul>
<li>前端：在浏览器端运行的内容为前端。通常是用HTML+CSS+JS来实现的，如APP、小程序、H5等。</li>
<li>后端：在服务器端运行的内容为后端。如Java、C、Python、PHP等</li>
<li>静态页面：网页中没有程序代码，仅HTML。一般静态页面一旦生成，内容就不会被改变。</li>
<li>动态页面：网页文件除了HTML还包括一些程序代码使浏览器可以与服务器交互，随用户交互的不同请求动态的生成网页内容。</li>
<li>网页的静态化：将动态数据都提前生成为静态的html页面，避免从数据库取数的时间。</li>
<li>DOM：文档对象模型（Document Object Model），一种将HTML/XML文档组织成对象模型（DOM树）的建模过程。</li>
<li>虚拟DOM：DOM树结构在内存里的映射</li>
</ul>
<a id="more"></a>
<h3 id="前后端不分离架构"><a href="#前后端不分离架构" class="headerlink" title="前后端不分离架构"></a>前后端不分离架构</h3><p>传统的不分离架构的设计大致为：</p>
<ol>
<li>浏览器发出请求。</li>
<li>服务器收到请求，从数据库取出数据后，生成渲染整个页面发送给浏览器。</li>
<li>浏览器将页面展示给用户。</li>
<li>以上步骤循环进行。</li>
</ol>
<p>此种方式缺点是不但无法将前后端开发人员的职能分开（或要求开发人员掌握全栈），且在技术层面，每一次请求，要发送的内容数量很大，包括整个HTML、CSS以及JavaScript。</p>
<p>优点是服务器可以缓存整个页面，页面静态化或访问时可以不用再次访问数据。</p>
<p>若需要提升性能，要么提升服务器响应时间，要么压缩传输的内容。相比之下，压缩传输的内容的优化更有效。</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>不分离架构需传输的内容太多，是否可以只传输变化的内容。因此引出了Ajax。</p>
<p>Ajax只传输数据，不传输整个网页。此时处于一种半分离的状态。设计大概为：</p>
<ol>
<li>浏览器发出请求。</li>
<li>HTML中的JS代码以Ajax方式向后台接口请求数据。</li>
<li>后台接口返回JSON数据</li>
<li>页面解析Json数据，通过DOM渲染页面展示给用户。</li>
</ol>
<p>此种方式前端不会嵌入过多后台代码，前端专注自己的开发，不依赖后段。</p>
<p>缺点是JS会出现大量冗余。若JSON数据量大，渲染仍然会花费很长时间。若业务复杂，一个页面需要发起多次http请求才能渲染完整个页面。</p>
<h3 id="前后端分离架构"><a href="#前后端分离架构" class="headerlink" title="前后端分离架构"></a>前后端分离架构</h3><p>由此产生前后端分离架构，前端只负责view和controller层，后段只负责model层、业务处理和数据持久化。前后端只通过JSON交流。</p>
<ol>
<li>浏览器发出请求。</li>
<li>Web服务器解析请求，经过转换，发送给各个相关的后端服务器。</li>
<li>后端服务器返回处理过的业务数据。</li>
<li>Web服务器将返回的业务数据填入HTML模版发送给浏览器。</li>
<li>浏览器展示页面。</li>
</ol>
<p>前后端人员约定好接口后，就可以各自开发测试。前端不用关心业务处理，后端也不用关心前端界面。代码管理、服务部署也可以分别管理。</p>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>SPA（Single Page Web Applications）单页应用，是实践前后端分离架构最好的方案。它是一种只需要将单个页面加载到浏览器中的Web应用程序。</p>
<p>工作时，在Web页面初始化时，就加载完相应的HTML、CSS、JS内容，以后不会因用户的操作而进行页面的重新加载或跳转。当用户交互时，只通过Javascript动态变换HTML的内容，即进行部分内容的动态切换和替换。</p>
<p>优点：用户体验快，避免不必要的跳转和页面的重复渲染，加快了对数据的刷新，对服务器压力小。且共用一套后端代码即可同时应用于Web界面、手机、平板等多种客户端。</p>
<p>缺点：SEO难度较高，页面的前进后退管理复杂，且初次加载时可能耗时会较长。</p>
<h3 id="核心逻辑"><a href="#核心逻辑" class="headerlink" title="核心逻辑"></a>核心逻辑</h3><h4 id="动态切换视图"><a href="#动态切换视图" class="headerlink" title="动态切换视图"></a>动态切换视图</h4><ul>
<li><p>通过JavaScript的<code>$().replacewith()</code>等方法实现切换。</p>
</li>
<li><p>通过URL路由机制，从URL路由中的hashtag获取信息，再通过<code>window.location.hash.slice()</code>方法实现页面内容切换</p>
</li>
</ul>
<h4 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h4><ol>
<li>通过ajax获取数据</li>
<li>载入前占位提示。由于从服务器端获取数据需要时间，则设置一个占位符，如loading样式、文字提示，表示数据正在载入，请等待。</li>
<li>异步操作(取数据渲染页面)：await callback promise</li>
</ol>
<h4 id="模版替换"><a href="#模版替换" class="headerlink" title="模版替换"></a>模版替换</h4><ol>
<li>JSON数据转换：JSON是字符串，需要将它转换为DataObject使用，jQuery会自动解析，其他的库需要自己解析</li>
<li>模版替换：数据转换后就发给模版，将对应内容进行替换，得到HTML </li>
</ol>
<h4 id="双向绑定和动态渲染"><a href="#双向绑定和动态渲染" class="headerlink" title="双向绑定和动态渲染"></a>双向绑定和动态渲染</h4><p>服务器端渲染：一次请求渲染一次，新的数据变更在新的请求后渲染。</p>
<p>前端SPA渲染：用户修改数据，相应的数据要同步修改，故需要用到事件机制通知。修改数据后触发事件机制，事件绑定的函数检查修改的数据，重新通过模版渲染页面，填回DOM对应的地方，即做到自动更新。</p>
<p>问题：实现时，每次修改可能会渲染整个页面，效率十分低。</p>
<p>解决：只渲染修改的部分。</p>
<h5 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h5><blockquote>
<p>调用虚拟DOM实现动态渲染修改的内容。</p>
</blockquote>
<p>每次修改完内容，按新内容在内存里构建一个新的虚拟DOM树， 与旧的DOM树比较，检查节点变动情况，再到真实的DOM树中，修改对应的节点，完成渲染更新。</p>
<h4 id="组件化和重用"><a href="#组件化和重用" class="headerlink" title="组件化和重用"></a>组件化和重用</h4><p>支持自定义标签，在重用时只需要关注内容，不需要关心具体结构。若需要变动，只需要调整自定义标签的模版，那整个页面使用的自定义标签都会自动更新。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>SPA</tag>
        <tag>前后端分离</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式学习笔记</title>
    <url>/post/2092262605.html</url>
    <content><![CDATA[<p>正则表达式定义了字符串的模式，可以用来搜索、编辑、处理文本。用<code>//</code>包围一个正则表达式</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>测试字符串内模式（数据验证）</li>
<li>替换文本</li>
<li>基于模式匹配提取子字符串</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>正则表达式由普通字符以及特殊字符（元字符）组成。</p>
<a id="more"></a>
<h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>包括没有显式指定为元字符的所有可打印、不可打印字符。（包括所有大小写字母、数字、标点符号、其他符号）</p>
<ul>
<li>不可打印字符：匹配包括换页符<code>\f</code>、换行符<code>\n</code>、回车符<code>\r</code>、空白字符<code>\s</code>、制表符<code>\t</code>等字符。</li>
</ul>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>类似关键字，匹配特殊字符时需要先使用<code>\</code>将其转义。</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串中的开始位置，若放在方括号表达式中使用，表示不接受该方括号表达式中的字符集合</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾。若设置了<code>RegExp</code>对象的<code>Multiline</code>属性，则也匹配<code>\n</code>和 <code>\r</code></td>
</tr>
<tr>
<td>()</td>
<td>标记子字符串的开始和结束</td>
</tr>
<tr>
<td>*</td>
<td>匹配前面的子表达式0次或多次</td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式1次或多次 （至少要有一次）</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式0次或1次（最多1次）</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符\n之外的所有单字符</td>
</tr>
<tr>
<td>[</td>
<td>标记一个中括号表达式的开始</td>
</tr>
<tr>
<td>\</td>
<td>将下一个字符标记为特殊字符或向后引用或转义符或原义字符</td>
</tr>
<tr>
<td>{</td>
<td>标记限定符表达式的开始</td>
</tr>
<tr>
<td>|</td>
<td>指明两项之间的一个选择</td>
</tr>
</tbody></table>
<h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>用来指定正则表达式中一个给定组件必须出现多少次才能满足匹配，共6种：</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配前面的子表达式0次或多次，等价于<code>{0,}</code>，如<code>/zo*/</code>匹配<code>z</code>、<code>zoo</code>、<code>zoooo</code></td>
</tr>
<tr>
<td>+</td>
<td>匹配前面的子表达式1次或多次 （至少要有一次），如<code>/zo+/</code>匹配<code>zo</code>、<code>zoo</code>，不匹配<code>z</code></td>
</tr>
<tr>
<td>?</td>
<td>匹配前面的子表达式0次或1次（最多1次），如<code>/zo?/</code>，只能匹配<code>z</code>、<code>zo</code>，不匹配<code>zoooo</code>等</td>
</tr>
<tr>
<td>{n}</td>
<td><code>n</code>为非负整数。匹配前面的子表达式n次，如<code>o{2}</code>匹配<code>zoo</code>、<code>book</code>，不匹配<code>box</code></td>
</tr>
<tr>
<td>{n,}</td>
<td><code>n</code>为非负整数。至少匹配前面的子表达式n次，如<code>o{2,}</code>匹配<code>zoo</code>、<code>boooook</code>，不匹配<code>box</code></td>
</tr>
<tr>
<td>{n,m}</td>
<td><code>n</code>、<code>m</code>为非负整数，且<code>n&lt;=m</code>。最少匹配前面的子表达式n次，且最多匹配前面的子表达式m次，如<code>o{2,4}</code>匹配<code>zoo</code>、<code>boook</code>，不匹配<code>box</code>、<code>booooox</code></td>
</tr>
</tbody></table>
<blockquote>
<p>限定符出现在范围表达式之后，故应用于整个范围表达式</p>
</blockquote>
<h4 id="非贪婪限定符实现"><a href="#非贪婪限定符实现" class="headerlink" title="非贪婪限定符实现"></a>非贪婪限定符实现</h4><p><code>*</code>和<code>+</code>限定符都是贪婪的，即会尽可能多的匹配文字。若<strong><em>在其后加上?就会实现非贪婪或最小匹配</em></strong>。</p>
<p>如表达式<code>&lt;p&gt;Hello World&lt;p&gt;</code></p>
<ul>
<li>使用<code>/&lt;.*&gt;/</code>匹配，则匹配到的内容为整个表达式<code>&lt;p&gt;Hello World&lt;p&gt;</code></li>
<li>使用<code>/&lt;.*?&gt;/</code>匹配，则只匹配到<code>&lt;p&gt;</code></li>
</ul>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符将正则表达式固定到某位置，让其出现在行首行尾或某单词开头、内部、结尾。用来描述字符串或单词的边界。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配输入字符串中的开始位置，即匹配一行文本开始处的文本。若放在方括号表达式中使用，表示不接受该方括号表达式中的字符集合</td>
</tr>
<tr>
<td>$</td>
<td>匹配输入字符串的结尾，即匹配一行文本结束处的文本。若设置了<code>RegExp</code>对象的<code>Multiline</code>属性，则也匹配<code>\n</code>和 <code>\r</code></td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界，即字与空格间的位置。如<code>/\bCha/</code>匹配单词Chapter开头的三个字符。<code>/ter\b/</code>匹配单词Chapter结尾的三个字符</td>
</tr>
<tr>
<td>\B</td>
<td>非单词边界匹配，如<code>/\Bapt/</code>匹配Chapter中间的apt，但不匹配aptitude开头的apt，因为此apt出现在单词的边界</td>
</tr>
</tbody></table>
<h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p><code>()</code>：可以将选择项括起来，但其相关的匹配会被缓存，可以使用<code>?:</code>放在第一个选项消除此缓存的作用<br><code>|</code>：分割相邻的选择项。</p>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>反向引用提供查找文本中两个相同的相邻单词的匹配项的能力。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;Is is the cost of of gasoline going up up&quot;;</span><br><span class="line">var patt1 &#x3D; &#x2F;\b([a-z]+) \1\b&#x2F;ig;</span><br><span class="line">document.write(str.match(patt1));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>\b([a-z]+)</code>:匹配一个或多个字母</li>
<li><code>\1\b</code>:引用第一个子匹配项，即单词的第二个匹配项正好由第一个子匹配项匹配。</li>
<li>引用单词边界符确保只检测整个单词</li>
<li><code>i</code>:忽略大小写</li>
<li><code>g</code>:指定将该表达式应用到输入字符串能够查找到的尽可能多的匹配</li>
</ul>
<p>还可以将url分解为其组件，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;http:&#x2F;&#x2F;www.runoob.com:80&#x2F;html&#x2F;html-tutorial.html&quot;;</span><br><span class="line">var patt1 &#x3D; &#x2F;(\w+):\&#x2F;\&#x2F;([^&#x2F;:]+)(:\d*)?([^# ]*)&#x2F;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(\w+)</code>：<strong>\w等价于[a-zA-Z0-9_]，匹配下划线、所有字母和数字。</strong>该表达式表示匹配url的协议部分，即http。</li>
<li><code>:\/\/</code>：即http后的://</li>
<li><code>([^/:])</code>：匹配非<code>:</code>和<code>/</code>后的一个或多个字符，即url地址部分。</li>
<li><code>(:\d*)?</code>：<strong>\d等价于[0-9]，表示匹配所有的数字</strong>。该表达式表示匹配以:开头的0个或多个数字，即url端口号部分。<code>?</code>表示该端口号部分只匹配0次或1次</li>
<li><code>([^# ]*)</code>：表示匹配非<code>#</code>或<code>空格</code>字符的任何字符序列，即匹配url的指定路径和页信息。</li>
</ul>
<p>对正则表达式模式两边添加()会将相关匹配存储到一个临时缓冲区中，所捕获到的每个子匹配都按在正则表达式模式中从左到右出现的顺序存储，从1开始，最多存储99个捕获的子表达式。<br>可以使用非捕获元字符来重写捕获，忽略对相关匹配的保存。</p>
<h4 id="非捕获元"><a href="#非捕获元" class="headerlink" title="非捕获元"></a>非捕获元</h4><p><code>?:</code>：消除圆括号相关匹配缓存的副作用<br><code>?=</code>：正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来搜索字符串。<br><code>?!</code>：负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>正则表达式相同优先级的从左到右计算，不同优先级的先高后低。</p>
<p>下表表示优先级由高至低：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(),(?:),(?=),[]</td>
<td>圆括号和方括号</td>
</tr>
<tr>
<td>*,+,?,{n},{n,},{n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^,$,以开头的\元字符、字符</td>
<td>定位符和序列</td>
</tr>
<tr>
<td>｜</td>
<td>替换、或操作</td>
</tr>
</tbody></table>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><h3 id="基本模式匹配"><a href="#基本模式匹配" class="headerlink" title="基本模式匹配"></a>基本模式匹配</h3><p>模式是正则表达式最基本的元素，是一组描述字符串特征的字符。</p>
<p><code>^the</code>: 匹配以the开头的字符串。如匹配<code>the book is over there</code>，不匹配<code>get the book</code>。</p>
<p><code>book$</code>: 匹配以book结尾的字符串。如匹配<code>there is a book</code>，不匹配<code>the book is on the table</code>。</p>
<p><code>^book$</code>: 精准匹配book，只匹配字符串<code>book</code>。</p>
<p><code>book</code>: 与任何包含book的字符串匹配。</p>
<p>若需要匹配转义字符，则需要以<code>\</code>开头，如<code>^\t</code>，匹配以制表符开头的字符串。</p>
<h3 id="字符簇"><a href="#字符簇" class="headerlink" title="字符簇"></a>字符簇</h3><p>字符簇一组字符的集合。用方括号<code>[]</code>扩起来。如<code>[AaEeIiOoUu]</code>匹配<strong>一个元音字符</strong>。</p>
<p>用<code>-</code>连接可表示<strong>一个字符</strong>的范围。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[a-z]：所有小写字母</span><br><span class="line">[A-Z]：所有大写字母</span><br><span class="line">[a-zA-Z]：所有字母</span><br><span class="line">[0-9]：所有数字</span><br></pre></td></tr></table></figure>

<p>方括号内使用<code>^</code>表示非。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[^0-9]：除0-9所有字符</span><br><span class="line">[^a-z]：除a-z所有字符</span><br></pre></td></tr></table></figure>

<p>特殊字符<code>.</code>表示出了新行之外的所有字符。</p>
<h3 id="重复出现"><a href="#重复出现" class="headerlink" title="重复出现"></a>重复出现</h3><p>使用<code>{}</code>确定重复出现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;n&#125;：出现n次</span><br><span class="line">&#123;n,&#125;：出现至少n次</span><br><span class="line">&#123;n,m&#125;：至少出现n次但不超过m次</span><br><span class="line">?：相当于&#123;0,1&#125;，出现0次或1次</span><br><span class="line">+：&#123;1,&#125;，至少出现1次</span><br><span class="line">*：&#123;0,&#125;，出现0次或多次</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript正则表达式RegExp对象"><a href="#JavaScript正则表达式RegExp对象" class="headerlink" title="JavaScript正则表达式RegExp对象"></a>JavaScript正则表达式RegExp对象</h2><p>RefExp是JavaScript的正则表达式对象。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var patt &#x3D; new RegExp(pattern,modifiers);</span><br><span class="line"></span><br><span class="line">var patt &#x3D; &#x2F;pattern&#x2F;modifiers;</span><br></pre></td></tr></table></figure>

<ul>
<li>patterm：正则表达式模式</li>
<li>modifiers：正则表达式修饰符<ul>
<li>i：不区分大小写</li>
<li>g：执行全文搜索</li>
</ul>
</li>
</ul>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var patt &#x3D; new RegExp(&quot;^[abc]&quot;);</span><br><span class="line"></span><br><span class="line">var patt &#x3D; &#x2F;is&#x2F;g;</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>test()：搜索字符串指定的值，根据结果返回<code>true</code>或<code>false</code>。</p>
<p>exec()：检索字符中指定值。找到返回该值，未找到返回null。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Gist网站实现(6)-使用BootStrap优化网站样式</title>
    <url>/post/40b522ab.html</url>
    <content><![CDATA[<h2 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h2><p>BootStrap是一个前端组件库，包括一系列CSS和jQuery实现的组件，非常流行。</p>
<ul>
<li>通过Reboot清理统一了各个浏览器的样式</li>
<li>通过Layout提供了一个支持复杂布局的网格结构</li>
<li>通过Component提供了一系列常用的增强组件</li>
<li>通过其生态提供了大量风格各异的主题</li>
</ul>
<h3 id="优化网站样式"><a href="#优化网站样式" class="headerlink" title="优化网站样式"></a>优化网站样式</h3><h4 id="选择网站主题"><a href="#选择网站主题" class="headerlink" title="选择网站主题"></a>选择网站主题</h4><p>在<a href="https://bootswatch.com/" target="_blank" rel="noopener">BootStrap网站主题</a>页面选择主题，在选择主题的<code>download</code>下拉按钮下，右键点击<code>bootstrap.min.css</code>选择复制链接。</p>
<a id="more"></a>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdftz1qmj0j312i0qw7qd.jpg" alt="选择主题"></p>
<h4 id="导入BootStrap"><a href="#导入BootStrap" class="headerlink" title="导入BootStrap"></a>导入BootStrap</h4><p>由于Express使用的是pug(原jade)模版，故需要将html转换为pug(jade)语法。可使用<a href="http://html2jade.org/" target="_blank" rel="noopener">在线转换网站</a>，进行转换。</p>
<p>把 CSS 放到 head 标签里边，而 JS 放到 body 结束之前。 这样页面在载入时不会丢失样式，又不会因为 JS 文件延迟页面显示速度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--CSS--&gt;</span><br><span class="line">link(rel&#x3D;&#39;stylesheet&#39;, href&#x3D;&#39;https:&#x2F;&#x2F;bootswatch.com&#x2F;4&#x2F;cyborg&#x2F;bootstrap.min.css&#39;)</span><br><span class="line">&lt;!--JavaScript--&gt;</span><br><span class="line">script(src&#x3D;&#39;https:&#x2F;&#x2F;stackpath.bootstrapcdn.com&#x2F;bootstrap&#x2F;4.4.1&#x2F;js&#x2F;bootstrap.min.js&#39;, integrity&#x3D;&#39;sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6&#39;, crossorigin&#x3D;&#39;anonymous&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="修改相关样式样式"><a href="#修改相关样式样式" class="headerlink" title="修改相关样式样式"></a>修改相关样式样式</h4><ol>
<li><p>点击模版页面的preview按钮进入模版组件样式页面。<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfu8qr2z9j30ic0lkmz1.jpg" alt="组件样式"></p>
</li>
<li><p>选择对应的样式，在右边点击<code>&lt;&gt;</code>按钮复制html代码。通过<a href="http://html2jade.org/" target="_blank" rel="noopener">在线转换网站</a>进行pug(jade)语法转换<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfu8staglj31h2046mxo.jpg" alt="选择样式"><br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfu8v2ztmj31370u0dm0.jpg" alt="代码"></p>
</li>
<li><p>将转换后的语法放在页面对应位置。<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfuaw7442j318g0mq0yl.jpg" alt="设置样式"></p>
</li>
<li><p>进行样式调整</p>
</li>
</ol>
<h4 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h4><ol>
<li><p>主页及登陆页面<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfuyduf7uj31lq0c6dh6.jpg" alt="未登陆"><br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfuwkzf39j31ly0ee0ui.jpg" alt="已登陆"><br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfuym3mi7j31m00dq75l.jpg" alt="登陆页面"></p>
</li>
<li><p>我的代码页面<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfucqf6eaj317y0u0gqp.jpg" alt="我的代码"></p>
</li>
<li><p>修改代码页面<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfugunak0j31ly0psjua.jpg" alt="修改代码"></p>
</li>
<li><p>查看代码详情<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfud4r6qzj31ly0j4mzm.jpg" alt="查看代码"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>gist</tag>
        <tag>Express</tag>
        <tag>JavaScript</tag>
        <tag>BootStrap</tag>
      </tags>
  </entry>
  <entry>
    <title>Gist网站实现(5)-使用Mongoose数据库实现简单的增删改查</title>
    <url>/post/a7ca0ec2.html</url>
    <content><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><blockquote>
<p>关系数据库： MySQL、PostgreSQL  </p>
</blockquote>
<blockquote>
<p>文档数据库： mongoDB、CouchDB</p>
</blockquote>
<p>区别在于<strong><em>schema</em></strong>：</p>
<ul>
<li><p>关系数据库在插入数居前，需要先建立表结构，预先制定好字段和类型，即schema。一张表里的字段结构是一致的，一条数据，就是一个记录</p>
</li>
<li><p>文档数据库按文档组织数据，数据格式无需提前声明，各个文档内也无关联。</p>
<a id="more"></a>

</li>
</ul>
<h3 id="Mongoose"><a href="#Mongoose" class="headerlink" title="Mongoose"></a>Mongoose</h3><p>Mongoose优化了MongoDB，解决对象建模的一系列问题</p>
<p>核心概念：</p>
<ul>
<li><p>Schema：类似关系数据库建表时的字段设置。描述数据规范，类型、长度等</p>
</li>
<li><p>Model：从schema产生的构造器，通过model可以得到document。类似SSM中的sevice层，调用数据库component。可以创建、删除、查找等</p>
</li>
<li><p>Document：Document是Model的Instance实例，Document里存的都是数据。</p>
</li>
</ul>
<h3 id="使用Mongoose存储数据"><a href="#使用Mongoose存储数据" class="headerlink" title="使用Mongoose存储数据"></a>使用Mongoose存储数据</h3><h4 id="导入Mongoose模块"><a href="#导入Mongoose模块" class="headerlink" title="导入Mongoose模块"></a>导入Mongoose模块</h4><ol>
<li><p>新建文件mongoose.js，作为连接数据库的模块用于被其他模块导入</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    const mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">    mongoose.connect(&#39;mongodb:&#x2F;&#x2F;localhost&#x2F;nodegist&#39;,</span><br><span class="line">    &#123;</span><br><span class="line">    useNewUrlParser:true, useUnifiedTopology:true</span><br><span class="line">&#125;, </span><br><span class="line">err &#x3D;&gt;&#123;</span><br><span class="line">        if(err)&#123;</span><br><span class="line">            console.log(&#39;db error ......&#39;);</span><br><span class="line">            process.exit();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;将连接数据库服务装载入模块，可供其他地方导入使用</span><br><span class="line">module.exports &#x3D; mongoose;</span><br></pre></td></tr></table></figure>

<ul>
<li>mongoose.connect(url,options)：连接mongoose数据库<ul>
<li>options可选</li>
<li><code>useNewUrlParser</code>：底层MongoDB已经废弃当前连接字符串解析器。因为这是一个重大的改变，添加了<code>useNewUrlParser</code>标记，则当在用户如果遇到bug，允许用户在新的解析器中返回旧的解析器。因此除非连接阻止设置，否则你应该设置<code>useNewUrlParser: true</code></li>
<li><code>useUnifiedTopology</code>：当出现“当前服务器发现和监视引擎已弃用，将在将来的版本中删除”的连接MongoDB错误时。要使用新的服务器发现和监视引擎，按提示，要将选项<code>useUnifiedTopology:true</code>传递给mongoclient构造函数，即connect函数</li>
</ul>
</li>
</ul>
</li>
<li><p>导入mongoose模块，设计schema创建model及document</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mg &#x3D; require(&quot;..&#x2F;lib&#x2F;mongoose&quot;);</span><br><span class="line">&#x2F;&#x2F;创建model</span><br><span class="line">&#x2F;&#x2F;每调用一次就要创建一次model</span><br><span class="line">const Gist &#x3D; mg.model( &#39;Gist&#39; , &#123;</span><br><span class="line">    name: &#123;type:String&#125;,</span><br><span class="line">    type: &#123;type:String&#125;,</span><br><span class="line">    code: &#123;type:String&#125;,</span><br><span class="line">    author_id: &#123;type:String&#125;,</span><br><span class="line">    author: &#123;type:mg.Schema.Types.ObjectId, ref: &#39;Author&#39;&#125;,</span><br><span class="line">    created_at: &#123;type:String&#125;</span><br><span class="line">&#125; );</span><br><span class="line">&#x2F;&#x2F;创建document</span><br><span class="line">const gist &#x3D; new Gist(&#123;</span><br><span class="line">  name:req.body.name,</span><br><span class="line">  type:req.body.type,</span><br><span class="line">  code:req.body.code,</span><br><span class="line">  author_id:req.session.user.id,</span><br><span class="line">  author:req.session.user._id,</span><br><span class="line">  created_at:Date.now() </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建保存逻辑<br> 使用<code>await gist.save()</code>保存gist。</p>
<p> <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeqsua9h4j30i206wwew.jpg" alt="保存"></p>
</li>
<li><p>优化mongoose创建model逻辑<br> 由于2中创建model时，每调用一次Gist的model就要创建一次model，不灵活，故将创建schema逻辑独立出来创建为模块，当使用时，直接使用<code>require</code>调用即可。</p>
</li>
<li><p>优化跳转逻辑，使保存后跳转至“我的代码”页面<br> 使用<code>res.redirect</code>设置页面跳转。</p>
</li>
</ol>
<h4 id="展示数据"><a href="#展示数据" class="headerlink" title="展示数据"></a>展示数据</h4><ol>
<li><p>在“我的代码”页面，使用mongoose的find逻辑对已保存的数据进行展示</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  const Gist &#x3D; require(&quot;..&#x2F;model&#x2F;Gist&quot;);</span><br><span class="line">  &#x2F;&#x2F;设置显示时按创建时间逆序排序展示</span><br><span class="line">  const gists &#x3D; await Gist.find().sort(&#123;&#39;created_at&#39;:-1&#125;);</span><br><span class="line">  &#x2F;&#x2F;将gists信息传入页面</span><br><span class="line">  res.render(&#39;gists&#39;,&#123;</span><br><span class="line">  user:req.session.user,</span><br><span class="line">  gists</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>设计“我的代码”页面上代码的展示样式。<br> <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfskc7w8rj30ko0bwgmb.jpg" alt="我的代码"></p>
</li>
</ol>
<h4 id="使用update逻辑修改数据"><a href="#使用update逻辑修改数据" class="headerlink" title="使用update逻辑修改数据"></a>使用update逻辑修改数据</h4><ol>
<li><p>增加修改代码功能，通过点击修改按钮，跳转至修改页面</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;从路径中获取需要修改的代码片段id</span><br><span class="line">router.get(&#39;&#x2F;modify&#x2F;:id&#39;,async(req,res)&#x3D;&gt;&#123;</span><br><span class="line">    const id &#x3D; req.params.id;</span><br><span class="line">    const Gist &#x3D; require(&quot;..&#x2F;model&#x2F;Gist&quot;);</span><br><span class="line">    &#x2F;&#x2F;通过id查询要修改的gist</span><br><span class="line">    const gist &#x3D; await Gist.findById(id);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;增加校验：是否存在此gist，是否为当前登陆用户所提交的gist</span><br><span class="line">    if(!gist) throw(new Error(&quot;gist not found!&quot;));</span><br><span class="line">    if(gist.author_id !&#x3D; req.session.user.id) throw(new Error(&quot;只允许修改自己提交的代码！&quot;));</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改更新代码</span><br><span class="line">    res.render(&#39;modify&#39;,&#123;gist,user:req.session.user&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建修改代码页面，并增加相关样式。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form(action&#x3D;&quot;&#x2F;gists&#x2F;update&#x2F;&quot;+gist.id, method&#x3D;&quot;post&quot;)</span><br><span class="line">        div</span><br><span class="line">            input(name&#x3D;&quot;name&quot; value&#x3D;gist.name)</span><br><span class="line">            select(name&#x3D;&quot;type&quot;)</span><br><span class="line">                each thetype in [&quot;php&quot;,&quot;javascript&quot;,&quot;go&quot;,&quot;python&quot;]</span><br><span class="line">                    -if(gist.type&#x3D;&#x3D;thetype)</span><br><span class="line">                        option(value&#x3D;thetype selected&#x3D;&quot;true&quot;) #&#123;thetype&#125;</span><br><span class="line">                    -else</span><br><span class="line">                        option(value&#x3D;thetype) #&#123;thetype&#125;</span><br><span class="line">        div</span><br><span class="line">            textarea(name&#x3D;&quot;code&quot;, cols&#x3D;&quot;30&quot;, rows&#x3D;&quot;10&quot;) #&#123;gist.code&#125;</span><br><span class="line">        div</span><br><span class="line">            button(type&#x3D;&quot;submit&quot;) 保存修改</span><br></pre></td></tr></table></figure>

<ul>
<li><p>input：代码名，直接从url中获取</p>
</li>
<li><p>select：从gist中获取并将其选中</p>
<blockquote>
<p>写的时候忘了截图了= =。最终的样子就是表单填了内容的样子。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>添加修改代码update逻辑，修改后点击提交按钮，更新数据库内容<br>修改代码页面update逻辑与modify逻辑几乎一样，仅添加了对输入框、选择框等的校验。并将新修改的内容更新。   </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if( !req.body.name )  throw( new Error(&#39;名称不能为空&#39;) );</span><br><span class="line">if( !req.body.type )  throw( new Error(&#39;类型不能为空&#39;) );</span><br><span class="line">if( !req.body.code )  throw( new Error(&#39;代码不能为空&#39;) );</span><br><span class="line"></span><br><span class="line">    gist.name &#x3D; req.body.name;</span><br><span class="line">    gist.type &#x3D; req.body.type;</span><br><span class="line">    gist.code &#x3D; req.body.code;</span><br><span class="line">    gist.author_id &#x3D; req.session.user.id;</span><br><span class="line">    gist.created_at &#x3D; Date.now() ;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ol>
<li><p>增加删除代码功能<br> 删除代码使用mongoose的<code>deleteOne()</code>函数直接删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.get(&#39;&#x2F;remove&#x2F;:id&#39;, async(req,res)&#x3D;&gt;&#123;</span><br><span class="line">        const id &#x3D; req.params.id;</span><br><span class="line">        const Gist &#x3D; require(&quot;..&#x2F;model&#x2F;Gist&quot;);</span><br><span class="line">        const gist &#x3D; await Gist.findById(id);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;增加校验：是否存在此gist？是否为当前登陆用户所提交的gist</span><br><span class="line">        if(!gist) throw(new Error(&quot;gist not found!&quot;));</span><br><span class="line">        if(gist.author_id !&#x3D; req.session.user.id) throw(new Error(&quot;只允许修改自己提交的代码！&quot;));</span><br><span class="line">  </span><br><span class="line">        await gist.deleteOne();</span><br><span class="line">        res.redirect(&#39;&#x2F;gists&#x2F;main&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除代码时添加提醒是否删除<br>在点击按钮时使用<code>javascript:function()</code>调用js函数添加弹窗提醒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a.btn.btn-danger(href&#x3D;(&quot;javascript:remove_gist(&#39;&quot;+gist.id+&quot;&#39;);void(0);&quot;)) 删除</span><br><span class="line">    &#x2F;&#x2F;删除提醒弹窗</span><br><span class="line">    function remove_gist(id)&#123;</span><br><span class="line">        &#x2F;&#x2F;若点击确定删除，则执行remove删除逻辑</span><br><span class="line">        if(confirm(&quot;真的要删除吗？本操作无法恢复&quot;))&#123;</span><br><span class="line">        location &#x3D; &#39;&#x2F;gists&#x2F;remove&#x2F;&#39;+id;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdftawhffrj311a09ywfp.jpg" alt="删除"></p>
</li>
</ol>
<h4 id="搜索数据"><a href="#搜索数据" class="headerlink" title="搜索数据"></a>搜索数据</h4><ol>
<li><p>创建搜索逻辑</p>
<ul>
<li><p>添加搜索组件，将搜索条件search传入逻辑</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form(action&#x3D;&quot;&#x2F;gists&#x2F;main&quot;)</span><br><span class="line">    input(type&#x3D;&#39;search&#39;, placeholder&#x3D;&#39;关键字&#39;, name&#x3D;&quot;search&quot;, value&#x3D;search)</span><br><span class="line">    button(type&#x3D;&#39;submit&#39;) 搜索</span><br></pre></td></tr></table></figure></li>
<li><p>实现搜索逻辑</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const gists &#x3D; await Gist.find(search).sort(&#123;&#39;created_at&#39;:-1&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdfsjpkacuj30ms09kjs8.jpg" alt="搜索"></p>
</li>
</ul>
</li>
<li><p>优化逻辑，设计查询条件（name、code）</p>
<ul>
<li><p>查询条件是js对象，需满足查询<code>name</code>or<code>code</code>，且查询的范围必须为该用户可查看的范围。</p>
</li>
<li><p>查询条件使用正则表达式，则其查询对象的key为<code>{$regex: new RegExp( search, &#39;i&#39;)}</code></p>
<ul>
<li>$regex: 启用正则表达式，冒号后面是值</li>
<li>new RegExp(): js中创建正则表达式</li>
<li>search: 规则，描述字符串的特征</li>
<li>i: 正则表达式参数，i表示忽略大小写</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const search &#x3D; req.query.search ? </span><br><span class="line">  &#123;</span><br><span class="line">    &#x2F;&#x2F;查询条件必须为当前用户可看范围，使用and</span><br><span class="line">    $and:[</span><br><span class="line">      &#x2F;&#x2F;查询条件name和code为or关系</span><br><span class="line">      &#123;</span><br><span class="line">        $or:[</span><br><span class="line">          &#123;name:&#123;$regex:new RegExp(req.query.search,&#39;i&#39;)&#125;&#125;,</span><br><span class="line">          &#123;code:&#123;$regex:new RegExp(req.query.search,&#39;i&#39;)&#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">      ,&#123;&#39;author_id&#39;:req.session.user.id&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125; </span><br><span class="line">  :&#123;&#39;author_id&#39;:req.session.user.id&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="展示gist详细信息"><a href="#展示gist详细信息" class="headerlink" title="展示gist详细信息"></a>展示gist详细信息</h4><p>展示gist详细信息，需要同时展示作者信息，故需要多个实体。</p>
<h5 id="多实体功能实现方法"><a href="#多实体功能实现方法" class="headerlink" title="多实体功能实现方法"></a>多实体功能实现方法</h5><p>对于多实体的功能有三种实现方式：Map、Subdocument、Populate。</p>
<ul>
<li>Map：保存作者信息时，直接使用Map类型，在取数据时，使用get方法。</li>
<li>Subdocument：在建立gist的Schema前，建立author的Schema，在gist中直接使用authorSchema嵌套。<ul>
<li>这种方式数据更规范。</li>
<li>当其parent Document的save、validate中间件触发时，Subdocument的中间件也被触发。故对数据的控制更有力（有点类似父类和子类）。</li>
<li>访问数据时，直接使用.即可。</li>
</ul>
</li>
<li>Populate：Populate的实现是在gist里只存入供查询的author的id（此id为标识author的id，不是人为定义的id）。在查完gist后，再通过此id将author的内容进行扩展。扩展的方法是通过gist的model里为author设置的ref参数，至此就获得了author的全部信息（类似一种二次查询）。<ul>
<li>Map和Subdocument的问题是都把信息嵌入了document中，若有修改时，则需要全部修改，不够灵活。</li>
<li>此种方法author的信息也是需要存入数据库以供populate查询。</li>
<li>传输时，只传输标识author的id</li>
</ul>
</li>
</ul>
<h5 id="展示gist详细信息实现步骤（该部分使用Populate方式实现）"><a href="#展示gist详细信息实现步骤（该部分使用Populate方式实现）" class="headerlink" title="展示gist详细信息实现步骤（该部分使用Populate方式实现）"></a>展示gist详细信息实现步骤（该部分使用Populate方式实现）</h5><ol>
<li><p>创建Author的Shema  </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const mg &#x3D; require(&quot;..&#x2F;lib&#x2F;mongoose&quot;);</span><br><span class="line"></span><br><span class="line">const AuthorSchema &#x3D; new mg.Schema(&#123;</span><br><span class="line">    name:&#123;type:String&#125;,</span><br><span class="line">    avatar:&#123;type:String&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const Author &#x3D; mg.model(&#39;Author&#39;,AuthorSchema);</span><br><span class="line"></span><br><span class="line">module.exports&#x3D;Author;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将author信息存入数据库</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Author &#x3D; require(&quot;..&#x2F;model&#x2F;Author&quot;);</span><br><span class="line">&#x2F;&#x2F;将用户数据存入数据库</span><br><span class="line">const user_data &#x3D; user.data;</span><br><span class="line">let author &#x3D; await Author.findOne(&#123;&quot;id&quot;:user_data.id&#125;);</span><br><span class="line">if(!author)&#123;&#x2F;&#x2F;如果用户不存在，则新建一个用户</span><br><span class="line">  author &#x3D; new Author(&#123;</span><br><span class="line">    id:user_data.id,</span><br><span class="line">    name:user_data.name,</span><br><span class="line">    avatar:user_data.avatar_url</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;else&#123;&#x2F;&#x2F;若存在，则更新为最新信息</span><br><span class="line">  author.name &#x3D; user_data.name;</span><br><span class="line">  author.avatar &#x3D; user_data.avatar_url;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">await author.save();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将用户_id存入session</span><br><span class="line">req.session.user &#x3D; user.data;</span><br><span class="line">req.session.user._id &#x3D; author._id;</span><br></pre></td></tr></table></figure></li>
<li><p>展示gist详细信息及作者信息</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extends layout</span><br><span class="line">block content</span><br><span class="line">    .d-flex.justify-content-between</span><br><span class="line">        h4 #&#123;gist.name&#125;</span><br><span class="line">            span.badge.badge-secondary #&#123;gist.type&#125;</span><br><span class="line">        div #&#123;gist.author.name&#125;</span><br><span class="line"></span><br><span class="line">    pre</span><br><span class="line">        code#thecode.tcode(class&#x3D;gist.type) #&#123;gist.code&#125;</span><br><span class="line"></span><br><span class="line">    .form-group.row</span><br><span class="line">        a.btn.btn-primary(href&#x3D;(&quot;&#x2F;gists&#x2F;main&quot;) style&#x3D;&quot;&quot;) 返回上页</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdftsrilknj31xo0ekdho.jpg" alt="详细信息展示"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>gist</tag>
        <tag>Express</tag>
        <tag>JavaScript</tag>
        <tag>Mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB安装手册</title>
    <url>/post/2734088481.html</url>
    <content><![CDATA[<p>在学习Node.js的过程中需要使用Mongoose，故安装MongeDB进行使用。但过程中踩了不少坑。以下安装步骤是多次踩坑后可以正常运行的版本。</p>
<p>安装环境：Mac OS 10.15.3</p>
<h2 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h2><h3 id="方法1-使用官网安装包"><a href="#方法1-使用官网安装包" class="headerlink" title="方法1:使用官网安装包"></a>方法1:使用官网安装包</h3><p><a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">官网安装包下载链接</a></p>
<a id="more"></a>
<p>选择对应的操作系统和包格式点击下载即可。</p>
<blockquote>
<p>此方法个人在下载时一直报错，可能是因为浏览器中安装的下载插件问题，故最后未采用此方式下载。</p>
</blockquote>
<h3 id="方法2-获取官网下载链接使用命令行下载"><a href="#方法2-获取官网下载链接使用命令行下载" class="headerlink" title="方法2:获取官网下载链接使用命令行下载"></a>方法2:获取官网下载链接使用命令行下载</h3><p>在官网下载页面复制下载链接：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdealyx2fnj317s0o6acd.jpg" alt="复制官网下载链接"></p>
<ol>
<li><p>在iterm中使用命令行下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% sudo curl -O https:&#x2F;&#x2F;fastdl.mongodb.org&#x2F;osx&#x2F;mongodb-macos-x86_64-4.2.5.tgz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压后，将文件夹重命名为mongodb（<strong><em>重要！！！</em></strong>）</p>
</li>
</ol>
<blockquote>
<p>此方法下载成功且无任何报错</p>
</blockquote>
<h3 id="方法3-使用brew下载"><a href="#方法3-使用brew下载" class="headerlink" title="方法3:使用brew下载"></a>方法3:使用brew下载</h3><blockquote>
<p>确保自己的开发环境中已安装brew</p>
<p>brew安装教程<a href="https://zhuanlan.zhihu.com/p/99104545" target="_blank" rel="noopener">点击此进行跳转</a></p>
</blockquote>
<p>在iterm中使用命令行(<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">以下步骤参考于MongoDB官方下载文档</a>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% brew tap mongodb&#x2F;brew</span><br><span class="line"></span><br><span class="line">Macbook% brew install mongodb-community@4.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>第一次使用brew下载安装包没有没有按官网的步骤下载，参考了其他大佬的教程，最终没有安装成功，出现了很多奇怪的问题，可能是版本不太一样。<br>后来使用此方法进行下载，但下载后安装遇到了一些问题，初步怀疑是第一次用brew安装后的一些操作没有卸载整理完，故安装失败。</p>
</blockquote>
<h2 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol>
<li><p>使用命令行打开环境变量文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% open -e .bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>将安装MongoDB的目录下bin的地址添加到环境变量中（<strong><em>此步骤一定要配置对！！重要！！！否则后来可能会无法打开Mongo</em></strong>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;bin:$PATH</span><br><span class="line">&#x2F;&#x2F;保存文件</span><br></pre></td></tr></table></figure>
</li>
<li><p>使配置生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% source .bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证是否已安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% mongod -version</span><br></pre></td></tr></table></figure>

<p> 出现以下信息，则说明安装成功：</p>
<p> <img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdeb7a9ou9j30ni07yq61.jpg" alt="配置成功信息"></p>
</li>
</ol>
<h3 id="创建log和data目录"><a href="#创建log和data目录" class="headerlink" title="创建log和data目录"></a>创建log和data目录</h3><blockquote>
<p>很多教程都表示要使用<code>mkdir -p /data/db</code>创建目录，但使用各个方法都无法创建成功，故以下自己创建目录</p>
</blockquote>
<ol>
<li><p>在MongoDB的安装目录下新建log目录和data目录（本人安装目录为/usr/local/mongodb，该目录就是之前解压后重命名的文件夹）<br><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdebdsqowzj30nm03640e.jpg" alt="创建目录"></p>
</li>
<li><p>进入/usr/local/etc目录打开mongod.conf文件，修改log路径和data路径为步骤1中创建的目录地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  path: &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;mongo.log</span><br><span class="line">  logAppend: true</span><br><span class="line">storage:</span><br><span class="line">  dbPath: &#x2F;usr&#x2F;local&#x2F;mongodb&#x2F;data</span><br><span class="line">net:</span><br><span class="line">  bindIp: 127.0.0.1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有的教程直接进行第三步运行，但我直接运行第三步后配置并没有改变，出现了一些问题，故还是增加了第二步</p>
</blockquote>
</li>
<li><p>运行MongoDB服务</p>
<blockquote>
<p>MongoDB默认数据保存的地址为/data/db，但我一直没创建成功，故修改了地址后，在启动服务时指定dbpath的位置。由于做了第二步也可不指定，以防万一。</p>
</blockquote>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Macbook% mongod --dbpath data --logpath log&#x2F;mongod.log --logappend</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;--logappend:后台运行</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动后，当前终端不要关闭。</p>
</blockquote>
<p> <strong>遇到的问题：</strong></p>
<p> 在运行MongoDB服务时，有以下报错：</p>
<blockquote>
<p>NETWORK  [initandlisten] Failed to unlink socket file /tmp/mongodb-27017.sock Permission denied</p>
</blockquote>
<ul>
<li><p>原因查询:</p>
<p>  在mongodb目录下使用命令<code>ls -lat /tmp/mongodb-27017.sock</code>查看权限，显示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MacBook% srwx------  1 root  wheel  0  4  1 12:27 &#x2F;tmp&#x2F;mongodb-27017.sock</span><br></pre></td></tr></table></figure></li>
<li><p>解决办法：使用命令<code>sudo rm /tmp/mongodb-27017.sock</code>删除该文件即可。</p>
</li>
</ul>
</li>
<li><p>启动数据库<br> 新打开一个终端，输入mongo连接数据库。<br> 若出现<code>command not found</code>错误，直接使用命令<code>source .bash_profile</code>再次使环境变量生效，再使用mongo连接即可解决。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
        <tag>Web</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Gist网站实现(4)-我的代码页面输入合法性检测</title>
    <url>/post/bf43cd72.html</url>
    <content><![CDATA[<h2 id="添加表单提供提交代码片段功能"><a href="#添加表单提供提交代码片段功能" class="headerlink" title="添加表单提供提交代码片段功能"></a>添加表单提供提交代码片段功能</h2><h3 id="设计表单"><a href="#设计表单" class="headerlink" title="设计表单"></a>设计表单</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">form(action&#x3D;&quot;&#x2F;gists&#x2F;save&quot;, method&#x3D;&quot;post&quot;)</span><br><span class="line">        div</span><br><span class="line">            input(name&#x3D;&quot;name&quot;)</span><br><span class="line">            select(name&#x3D;&quot;type&quot;)</span><br><span class="line">                option(value&#x3D;&quot;C&quot;) C</span><br><span class="line">                option(value&#x3D;&quot;C++&quot;) C++</span><br><span class="line">                option(value&#x3D;&quot;C#&quot;) C#</span><br><span class="line">                option(value&#x3D;&quot;Java&quot;) Java</span><br><span class="line">                option(value&#x3D;&quot;JavaScript&quot;) JavaScript</span><br><span class="line">                option(value&#x3D;&quot;php&quot;) PHP</span><br><span class="line">                option(value&#x3D;&quot;Python&quot;) Python</span><br><span class="line">        div</span><br><span class="line">            textarea(name&#x3D;&quot;code&quot;,cols&#x3D;&quot;30&quot;,row&#x3D;&quot;10&quot;)</span><br><span class="line">        div</span><br><span class="line">            button(type&#x3D;&quot;submit&quot;) 保存</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p><img src="https://s1.ax1x.com/2020/03/19/8sO3gU.jpg" alt="8sO3gU.jpg"></p>
<h3 id="保存代码逻辑"><a href="#保存代码逻辑" class="headerlink" title="保存代码逻辑"></a>保存代码逻辑</h3><h4 id="检查输入数据合法性"><a href="#检查输入数据合法性" class="headerlink" title="检查输入数据合法性"></a>检查输入数据合法性</h4><blockquote>
<p>若输入内容不符合要求，则无法保存，提示错误并重新输入</p>
</blockquote>
<blockquote>
<p>使用错误处理中间件处理报错， 使用<code>req.body</code>取得 post 传入的数据</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.post(&quot;&#x2F;save&quot;, (req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">  if (!req.body.name) return next(new Error(&quot;Gist Name不能为空!&quot;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/19/8sO8vF.jpg" alt="8sO8vF.jpg"></p>
<h4 id="添加错误页并修改样式"><a href="#添加错误页并修改样式" class="headerlink" title="添加错误页并修改样式"></a>添加错误页并修改样式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;错误页</span><br><span class="line">extends layout</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">    h1&#x3D;message</span><br><span class="line">    h2&#x3D;error.status</span><br><span class="line"></span><br><span class="line">    div</span><br><span class="line">        a(href&#x3D;&quot;javascript:history.back(1)&quot;) 点此返回</span><br><span class="line"></span><br><span class="line">    pre.gray #&#123;error.stack&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;样式</span><br><span class="line">.gray &#123;</span><br><span class="line">  color: gray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/19/8sOYDJ.jpg" alt="8sOYDJ.jpg"></p>
<h4 id="修改错误逻辑为自动捕获"><a href="#修改错误逻辑为自动捕获" class="headerlink" title="修改错误逻辑为自动捕获"></a>修改错误逻辑为自动捕获</h4><blockquote>
<p>上述错误逻辑为主动传入 next，并不灵活，使用 express-async-errors 处理异步操作时主动抛出异常</p>
</blockquote>
<h5 id="安装导入-express-async-errors-模块"><a href="#安装导入-express-async-errors-模块" class="headerlink" title="安装导入 express-async-errors 模块"></a>安装导入 express-async-errors 模块</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;输入命令安装模块</span><br><span class="line">$ yarn add express-async-errors</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;导入模块</span><br><span class="line">require(&#39;express-async-errors&#39;);</span><br></pre></td></tr></table></figure>

<h5 id="修改错误逻辑为主动-throw"><a href="#修改错误逻辑为主动-throw" class="headerlink" title="修改错误逻辑为主动 throw"></a>修改错误逻辑为主动 throw</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!req.body.name)</span><br><span class="line">  throw(new Error(&quot;Gist Name不能为空!&quot;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;测试异步时错误处理</span><br><span class="line">router.post(&quot;&#x2F;save&quot;, async(req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;if (!req.body.name) throw new Error(&quot;Gist Name不能为空!&quot;);</span><br><span class="line">  const content &#x3D; await fs.Promises.readFile( &quot;index.php&quot; );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/19/8sOUER.jpg" alt="8sOUER.jpg"></p>
]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>gist</tag>
        <tag>Express</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Gist网站实现(3)-创建导航优化页面跳转</title>
    <url>/post/130e4ba5.html</url>
    <content><![CDATA[<h2 id="创建导航优化页面跳转"><a href="#创建导航优化页面跳转" class="headerlink" title="创建导航优化页面跳转"></a>创建导航优化页面跳转</h2><h3 id="创建导航"><a href="#创建导航" class="headerlink" title="创建导航"></a>创建导航</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doctype html</span><br><span class="line">html</span><br><span class="line">  head</span><br><span class="line">    title&#x3D; title</span><br><span class="line">    link(rel&#x3D;&#39;stylesheet&#39;, href&#x3D;&#39;&#x2F;stylesheets&#x2F;style.css&#39;)</span><br><span class="line">  body</span><br><span class="line">    div.menu</span><br><span class="line">      a(href&#x3D;&quot;&#x2F;&quot;) 首页</span><br><span class="line">      -if(user &amp;&amp; user.login)</span><br><span class="line">        a(href&#x3D;&quot;&#x2F;gists&#x2F;main&quot;) 我的代码</span><br><span class="line">        a(href&#x3D;&quot;&#x2F;users&#x2F;logout&quot;) 退出登陆#&#123;user.login&#125;</span><br><span class="line">      -else</span><br><span class="line">        a(href&#x3D;&quot;&#x2F;users&#x2F;login&quot;) 登陆</span><br><span class="line">    block content</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h4 id="添加导航样式"><a href="#添加导航样式" class="headerlink" title="添加导航样式"></a>添加导航样式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.menu &gt; * &#123;</span><br><span class="line">  margin-right: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/19/8sOeBj.jpg" alt="8sOeBj.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/03/19/8sO13T.jpg" alt="8sO13T.jpg"></p>
]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>gist</tag>
        <tag>Express</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Gist网站实现(2)-通过会话和session绑定登陆状态及登入登出跳转</title>
    <url>/post/a4d55a1a.html</url>
    <content><![CDATA[<h2 id="使用会话和-session-保存登陆状态"><a href="#使用会话和-session-保存登陆状态" class="headerlink" title="使用会话和 session 保存登陆状态"></a>使用会话和 session 保存登陆状态</h2><h3 id="安装包-express-session、session-file-store"><a href="#安装包-express-session、session-file-store" class="headerlink" title="安装包 express-session、session-file-store"></a>安装包 express-session、session-file-store</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add express-session session-file-store</span><br></pre></td></tr></table></figure>

<h3 id="导入安装的模块"><a href="#导入安装的模块" class="headerlink" title="导入安装的模块"></a>导入安装的模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;导入session模块，需要cookie后，session需要依赖cookie</span><br><span class="line">var session &#x3D; require(&quot;express-session&quot;);</span><br><span class="line">var FileStore &#x3D; require(&quot;session-file-store&quot;)(session);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="配置-session-参数"><a href="#配置-session-参数" class="headerlink" title="配置 session 参数"></a>配置 session 参数</h3><blockquote>
<p>sercet: 添加此参数提高安全性</p>
</blockquote>
<blockquote>
<p>resave: 强制将会话保存回会话存储，即使在请求期间从未修改过会话也是如此。</p>
</blockquote>
<blockquote>
<p>rolling: 强制在每个响应上设置会话标识符 cookie。到期重置为原始的 maxAge，重置到期倒数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(cookieParser(&#39;SOMEd31$&#39;));&#x2F;&#x2F;添加secret，提高安全性</span><br><span class="line">app.use(session(&#123;</span><br><span class="line">  secret:&#39;SOMEd31$&#39;,</span><br><span class="line">  resave: true,</span><br><span class="line">  rolling: true,</span><br><span class="line">  saveUninitialized: true,</span><br><span class="line">  cookie:&#123;</span><br><span class="line">    path:&#39;&#x2F;&#39;,       &#x2F;&#x2F;cookie路径</span><br><span class="line">    httpOnly:true,</span><br><span class="line">    secure:false,</span><br><span class="line">    maxAge: 60*60*1000*24     &#x2F;&#x2F;过期时间</span><br><span class="line">  &#125;,</span><br><span class="line">  store: new FileStore(&#123;&#125;)    &#x2F;&#x2F;采用文件来存储，否则默认为采用内存存储</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="将-github-登陆用户数据存入-session"><a href="#将-github-登陆用户数据存入-session" class="headerlink" title="将 github 登陆用户数据存入 session"></a>将 github 登陆用户数据存入 session</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">req.session.user &#x3D; user.data;&#x2F;&#x2F;将传回的数据存入session</span><br><span class="line">res.redirect(&#39;&#x2F;&#39;);&#x2F;&#x2F;返回首页</span><br></pre></td></tr></table></figure>

<blockquote>
<p>操作 session 时，会有文件变动</p>
</blockquote>
<h4 id="在模板中访问-session"><a href="#在模板中访问-session" class="headerlink" title="在模板中访问 session"></a>在模板中访问 session</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.get(&#39;&#x2F;&#39;, function(req, res, next) &#123;</span><br><span class="line">  res.render(&#39;index&#39;, &#123; title: &#39;AwesoLynn&#39; , user:req.session.user &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;模板jade文件中添加读取的session信息</span><br><span class="line">extends layout</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">  h1&#x3D; title</span><br><span class="line">  p 欢迎来到 #&#123;title&#125; , #&#123;user.login&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/19/8sOKNq.jpg" alt="8sOKNq.jpg"></p>
<h2 id="优化登陆页面"><a href="#优化登陆页面" class="headerlink" title="优化登陆页面"></a>优化登陆页面</h2><blockquote>
<p>若已登入用户访问登录页，则自动跳入首页，略过授权页面</p>
</blockquote>
<blockquote>
<p>若未登陆用户访问需登入才囊查看的页面，则自动跳入登陆页。</p>
</blockquote>
<h3 id="添加代码片段页-需登陆才能访问"><a href="#添加代码片段页-需登陆才能访问" class="headerlink" title="添加代码片段页(需登陆才能访问)"></a>添加代码片段页(需登陆才能访问)</h3><h4 id="封装-gists-路由"><a href="#封装-gists-路由" class="headerlink" title="封装 gists 路由"></a>封装 gists 路由</h4><p>新建 gists.js 文件，封装 gists 路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var express &#x3D; require(&quot;express&quot;);</span><br><span class="line">var router &#x3D; express.Router();</span><br><span class="line"></span><br><span class="line">router.get(&quot;&#x2F;&quot;, function(req, res, next) &#123;</span><br><span class="line">  res.render(&quot;gists&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; router;&#x2F;&#x2F;封装router模块</span><br></pre></td></tr></table></figure>

<h4 id="导入-gists-路由"><a href="#导入-gists-路由" class="headerlink" title="导入 gists 路由"></a>导入 gists 路由</h4><blockquote>
<p>在 app.js 文件导入 gists 路由</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gistsRouter &#x3D; require(&quot;.&#x2F;routes&#x2F;gists&quot;);</span><br><span class="line">app.use(&quot;&#x2F;gists&quot;, gistsRouter);</span><br></pre></td></tr></table></figure>

<h4 id="创建-gists-模板页"><a href="#创建-gists-模板页" class="headerlink" title="创建 gists 模板页"></a>创建 gists 模板页</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extends layout</span><br><span class="line"></span><br><span class="line">block content</span><br><span class="line">    h1 gists</span><br><span class="line">    p Welcome to Gists</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/19/8sOlCV.jpg" alt="8sOlCV.jpg"></p>
<h4 id="设置-gists-页面为登陆才可访问"><a href="#设置-gists-页面为登陆才可访问" class="headerlink" title="设置 gists 页面为登陆才可访问"></a>设置 gists 页面为登陆才可访问</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!req.session.user)</span><br><span class="line">  return res.redirect(&#39;&#x2F;users&#x2F;login&#39;);&#x2F;&#x2F;若没有登陆则转入登陆页面</span><br><span class="line">res.render(&quot;gists&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="创建退出登陆逻辑"><a href="#创建退出登陆逻辑" class="headerlink" title="创建退出登陆逻辑"></a>创建退出登陆逻辑</h4><blockquote>
<p>使用 req.session.destroy 来销毁服务器上的 session 文件。它是异步的，故可使用 async 和 await</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;退出逻辑</span><br><span class="line">router.get(&#39;&#x2F;logout&#39;,async (req,res)&#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">  if( req.session ) await req.session.destroy();</span><br><span class="line">  res.redirect(&#39;&#x2F;&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="处理首页用户不存在时显示信息"><a href="#处理首页用户不存在时显示信息" class="headerlink" title="处理首页用户不存在时显示信息"></a>处理首页用户不存在时显示信息</h4><blockquote>
<p>原首页会显示用户信息，登出后 session 销毁，user 不存在，故需要处理 user 不存在的情况</p>
</blockquote>
<blockquote>
<p>pug/jade 文件可通过-嵌入 JS 语法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">block content</span><br><span class="line">  h1&#x3D; title</span><br><span class="line">  -if(user) &#x2F;&#x2F;若已经登陆，则显示信息及退出链接</span><br><span class="line">    p Welcome to #&#123;title&#125;，#&#123;user.login&#125;</span><br><span class="line">      a(href&#x3D;&quot;&#x2F;users&#x2F;logout&quot;) Logout</span><br><span class="line">  -else &#x2F;&#x2F;若没有登陆，则显示登入链接</span><br><span class="line">    p Welcome to #&#123;title&#125;</span><br><span class="line">      a(href&#x3D;&quot;&#x2F;users&#x2F;login&quot;) Login</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/19/8sOM40.jpg" alt="8sOM40.jpg"></p>
<p><img src="https://s1.ax1x.com/2020/03/19/8sOmHs.jpg" alt="8sOmHs.jpg"></p>
<h4 id="使用中间件优化登陆访问逻辑"><a href="#使用中间件优化登陆访问逻辑" class="headerlink" title="使用中间件优化登陆访问逻辑"></a>使用中间件优化登陆访问逻辑</h4><blockquote>
<p>上述方式需要在每个登陆才能访问的页面添加逻辑判断，故使用中间件优化此通用逻辑</p>
</blockquote>
<blockquote>
<p>使用中间件，每当访问 gist 的请求，都会自动执行此中间件函数，若为未登陆状态，则转入登陆页面，否则，调用 next()进入下一个函数 gistRouter</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(&#39;&#x2F;gists&#39;,( req , res , next )&#x3D;&gt;&#123;</span><br><span class="line">  if( !req.session.user )</span><br><span class="line">    return res.redirect(&#39;&#x2F;users&#x2F;login&#39;);</span><br><span class="line">  else</span><br><span class="line">    next();</span><br><span class="line">&#125;,gistsRouter);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>gist</tag>
        <tag>Express</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Gist网站实现(1)-通过第三方登陆GitHub</title>
    <url>/post/3bcbab20.html</url>
    <content><![CDATA[<h2 id="安装-Express"><a href="#安装-Express" class="headerlink" title="安装 Express"></a>安装 Express</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g express-generator</span><br></pre></td></tr></table></figure>

<h3 id="新建-Express-项目初始化"><a href="#新建-Express-项目初始化" class="headerlink" title="新建 Express 项目初始化"></a>新建 Express 项目初始化</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx express-generator --view&#x3D;pug nodegist</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="安装依赖包并检查"><a href="#安装依赖包并检查" class="headerlink" title="安装依赖包并检查"></a>安装依赖包并检查</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd nodegist</span><br><span class="line">npm i yarn -g</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure>

<p><img src="https://ftp.bmp.ovh/imgs/2020/03/44e5a8852717b06e.jpg" alt="安装依赖包并检查"></p>
<h3 id="安装-nodemon-工具，使其监控文件变动，自己重启服务。"><a href="#安装-nodemon-工具，使其监控文件变动，自己重启服务。" class="headerlink" title="安装 nodemon 工具，使其监控文件变动，自己重启服务。"></a>安装 nodemon 工具，使其监控文件变动，自己重启服务。</h3><p>yarn add nodemon –dev</p>
<p>修改 package.json，将 script 下的 start 命令的 node 换为 nodemon。下次使用 yarn start 时即可通过 nodemon 启动</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/5512f974bc701b70.jpg" alt="nodemon"></p>
<h2 id="通过第三方登入-github"><a href="#通过第三方登入-github" class="headerlink" title="通过第三方登入 github"></a>通过第三方登入 github</h2><h3 id="直接登陆-github"><a href="#直接登陆-github" class="headerlink" title="直接登陆 github"></a>直接登陆 github</h3><p>用户在 github 登陆，输入用户名密码，传入 github，github 查询对应数据库，确认无误后，通过 session 标识用户登陆成功</p>
<h3 id="第三方登陆"><a href="#第三方登陆" class="headerlink" title="第三方登陆"></a>第三方登陆</h3><p>第三方不可信，故不直接使用用户名和密码进行登陆，而是采用限制性的登入授权解决。=&gt;OAuth</p>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图源自 easy 老师方糖全站课堂：</a></p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/03/fe5cc456c2233b7b.jpg" alt="github"></p>
<p>核心步骤为：<strong>获取 Code，用 Code 换 AccessToken</strong></p>
<h4 id="添加登陆页面"><a href="#添加登陆页面" class="headerlink" title="添加登陆页面"></a>添加登陆页面</h4><blockquote>
<p>页面由路由、回调函数、模板三部分组成</p>
</blockquote>
<p>1、在 routes/users.js 添加路由规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">router.get(&#39;&#x2F;login&#39;,function(res,res,next)&#123;</span><br><span class="line">   res.render(&#39;login&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>2、新建 views/login.jade 作为模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extends layout</span><br><span class="line">block content</span><br><span class="line">h1 login</span><br><span class="line">p</span><br><span class="line">a(href&#x3D;&#39;#&#39;) Login with Github</span><br></pre></td></tr></table></figure>

<blockquote>
<p>jade 是 Express 默认模板引擎，现已改名为 pug，其采用缩进来区分层级。<br>每一层将标签名写在最前面，然后用括号写属性，最后是标签对应的文字内容。<br>html2jade.org 可在线把 HTML 转化为 jade 语法<br>开头的<code>extends layout</code>即以 layout.jade 为基础，进行 block 替换</p>
</blockquote>
<h4 id="创建-OAuth-App"><a href="#创建-OAuth-App" class="headerlink" title="创建 OAuth App"></a>创建 OAuth App</h4><p><img src="https://pic.downk.cc/item/5e6f4ec6e83c3a1e3a7d04fa.jpg" alt="1"></p>
<p><img src="https://pic.downk.cc/item/5e6f4ec6e83c3a1e3a7d04fc.jpg" alt="2"></p>
<p><img src="https://s1.ax1x.com/2020/03/16/8JOQpV.jpg" alt="3"></p>
<h4 id="拼接请求链接（Github-的-OAuth-文档）"><a href="#拼接请求链接（Github-的-OAuth-文档）" class="headerlink" title="拼接请求链接（Github 的 OAuth 文档）"></a>拼接请求链接（Github 的 OAuth 文档）</h4><ol>
<li>定义 Client 相关信息为常量</li>
</ol>
<p><img src="https://pic.downk.cc/item/5e6f4ec6e83c3a1e3a7d0500.jpg" alt="5"></p>
<ol start="2">
<li>拼接 GET 参数，使用 encodeURIComponent 进行编码，保证参数中有特殊字符时不会报错</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/16/8JOnkn.jpg" alt="6"></p>
<ol start="3">
<li>将 url 作为参数传给模板</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/16/8JOuYq.jpg" alt="7"></p>
<ol start="4">
<li>在模板 views/login.jade 将 a 标签的 href 换为 url</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/16/8JOeTs.jpg" alt="8"></p>
<ol start="5">
<li>打开 login 页面即可看到授权页面</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/16/8JOVmQ.jpg" alt="9"></p>
<p><img src="https://s1.ax1x.com/2020/03/16/8JORht.jpg" alt="10"></p>
<h4 id="创建授权页面后回调函数"><a href="#创建授权页面后回调函数" class="headerlink" title="创建授权页面后回调函数"></a>创建授权页面后回调函数</h4><ol>
<li>点击授权按钮后，code 会出现在回调 URL 上</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/16/8JO2tI.jpg" alt="11"></p>
<ol start="2">
<li>安装必要的库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add axios url-search-params-polyfill querystring</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 users.js 引入新安装的库</li>
</ol>
<blockquote>
<p>NodeJS 特性</p>
</blockquote>
<blockquote>
<p>当我们通过 require 载入 module.exports 导出的内容时，如果是对象， NodeJS 会自动缓存它。如果是函数，则不会被缓存。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构成表单数据</span><br><span class="line">require(&#39;url-search-params-polyfill&#39;);</span><br><span class="line">&#x2F;&#x2F;发起HTTP请求</span><br><span class="line">const axios &#x3D; require(&#39;axios&#39;);</span><br><span class="line">&#x2F;&#x2F;分析URL里的参数</span><br><span class="line">const querystring &#x3D; require(&#39;querystring&#39;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新增 callback 路由规则，实现回调函数</li>
</ol>
<p>检查 url 中是否有 code，没有则报错</p>
<ol start="5">
<li>获取到 code 后需要再次发送请求获取 accessToken，此时根据文档需要发送 POST，故无法通过拼接 URL 实现</li>
</ol>
<blockquote>
<p>通过 axios 库发起请求，axios 支持 await 语法，其 post 方法接受两个参数，url 和要发送的数据</p>
</blockquote>
<blockquote>
<p>通过 URLSearchParams 按格式拼接要发送的数据</p>
</blockquote>
<blockquote>
<p>通过 url-search-params-polyfill 兼容低版本环境</p>
</blockquote>
<ol start="6">
<li>使用 querystring.parse 从 URL 中提取出 access_token，则即可使用 access token 调用接口</li>
</ol>
<p>完整代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F;req,res为Express传递的两个参数，分别为request请求和response响应</span><br><span class="line"> router.get(&quot;&#x2F;ghcallback&quot;, async (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  if (!req.query.code) res.status(500).send(&quot;bad code!&quot;);</span><br><span class="line">  console.log(&quot;in callback&quot;);</span><br><span class="line">  console.log(req.query.code);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;拼接POST请求参数</span><br><span class="line">  let params &#x3D; new URLSearchParams();</span><br><span class="line">  params.append(&quot;client_id&quot;, GH_CLIENT_ID);</span><br><span class="line">  params.append(&quot;client_secret&quot;, GH_CLIENT_SECRET);</span><br><span class="line">  params.append(&quot;code&quot;, req.query.code);</span><br><span class="line">  params.append(&quot;redirect_url&quot;, GH_CALLBACK);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;发起请求</span><br><span class="line">  const &#123; data &#125; &#x3D; await axios.post(</span><br><span class="line">    &quot;https:&#x2F;&#x2F;github.com&#x2F;login&#x2F;oauth&#x2F;access_token&quot;,</span><br><span class="line">    params</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;使用querystring提取access_token的值</span><br><span class="line">  if (data) &#123;</span><br><span class="line">    const acode &#x3D; querystring.parse(data).access_token;</span><br><span class="line">    &#x2F;&#x2F;使用access_token调用Github接口查询当前用户的信息</span><br><span class="line">    const user &#x3D; await axios.get(</span><br><span class="line">      &quot;https:&#x2F;&#x2F;api.github.com&#x2F;user?access_token&#x3D;&quot; + acode</span><br><span class="line">    );</span><br><span class="line">    console.log(&quot;Got user info:&quot;, user.data);</span><br><span class="line"></span><br><span class="line">    res.json(user.data);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/16/8JOj3V.jpg" alt="info"></p>
]]></content>
      <categories>
        <category>Express</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>gist</tag>
        <tag>Express</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(5)-Express基础</title>
    <url>/post/1628986583.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Express 是一个简洁灵活的 Node.js Web 应用框架，其特点为：</p>
<ul>
<li><p>可以设置中间件来响应 HTTP 请求</p>
</li>
<li><p>定义了路由表用于执行不同的 HTTP 请求动作</p>
</li>
<li><p>可以通过向模板传递参数来动态渲染 HTML 页面</p>
<a id="more"></a>

</li>
</ul>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>请求发送到服务器，服务端在监听处理请求时的过程很复杂，若将这些负责的业务拆分成子部分，则每个子部份就是一个中间件，类似一个流水线工作流程。</p>
<blockquote>
<p>function(req, res, next)</p>
</blockquote>
<blockquote>
<p>若符合 function 中的条件，则执行对应的 end()函数结束此次路由，若不符合条件，则执行 next()函数进入 function2</p>
</blockquote>
<blockquote>
<p>类同与异步的 promise.then().then()</p>
</blockquote>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图参考 easy 老师方糖全站课堂内容：</a></p>
<p><img src="https://i.loli.net/2020/03/16/amscOKBu1qZRNSD.jpg" alt="中间件"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> var express &#x3D; require(&#39;express&#39;);</span><br><span class="line"> var app &#x3D; express();</span><br><span class="line"></span><br><span class="line"> app.get(&#39;&#x2F;&#39;, function(req, res, next) &#123;&#x2F;&#x2F;function(req, res, next)为中间件</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 当前中间件函数没有结束请求&#x2F;响应循环，调用next(), 将控制权传递给下一个中间件函数继续往下处理，否则页面到此会被挂起</span><br><span class="line">    next();&#x2F;&#x2F;有next()才会往下进行下一个中间件，否则一直被挂起</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;next()代表的下一个中间件</span><br><span class="line">app.get(&#39;&#x2F;end&#39;, function(req, res) &#123;</span><br><span class="line">    &#x2F;&#x2F;此时没有next(),故到此结束</span><br><span class="line">    res.send(&#39;-----END-----&#39;);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h3 id="错误中间件"><a href="#错误中间件" class="headerlink" title="错误中间件"></a>错误中间件</h3><blockquote>
<p>function(err, req, res, next)</p>
</blockquote>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图参考 easy 老师方糖全站课堂内容：</a></p>
<p><img src="https://i.loli.net/2020/03/16/AKTki9687StbFu5.jpg" alt="错误中间件"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(function(err, req, res, next) &#123;&#x2F;&#x2F;function(err, req, res, next)为错误处理中间件</span><br><span class="line">  console.error(err.stack);</span><br><span class="line">  res.status(500).send(&#39;Something broke!&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;另一种写法</span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">  next(new Error(&quot;XXX error&quot;));&#x2F;&#x2F;next()将请求交给新建的错误处理中间件。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="单文件-Express-app"><a href="#单文件-Express-app" class="headerlink" title="单文件 Express app"></a>单文件 Express app</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line">const app &#x3D; express()</span><br><span class="line">const port &#x3D; 3000</span><br><span class="line"></span><br><span class="line">app.get(&#39;&#x2F;&#39;, (req, res) &#x3D;&gt; res.send(&#39;Hello World!&#39;))</span><br><span class="line"></span><br><span class="line">app.listen(port, () &#x3D;&gt; console.log(&#96;Example app listening on port &#96;+ port));</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/16/Of4DapRuvUVq5mE.jpg" alt="output"></p>
<h2 id="使用-Express-generate-生成-Express-项目"><a href="#使用-Express-generate-生成-Express-项目" class="headerlink" title="使用 Express generate 生成 Express 项目"></a>使用 Express generate 生成 Express 项目</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Node.js v8.2.0直接使用npx命令使用生成器</span><br><span class="line">$ npx express-generator</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;之前版本先安装生成器包</span><br><span class="line">$ npm install -g express-generator</span><br><span class="line">$ express</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成项目myapp</span><br><span class="line">&#x2F;&#x2F;将view引擎设置成pug，jade已不被支持</span><br><span class="line">$ express --view&#x3D;pug myapp</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;运行</span><br><span class="line">&#x2F;&#x2F;安装依赖</span><br><span class="line">$ cd myapp</span><br><span class="line">$ npm install</span><br><span class="line">&#x2F;&#x2F;运行</span><br><span class="line">$ set DEBUG&#x3D;myapp:*</span><br><span class="line">$ npm start</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打开页面http:&#x2F;&#x2F;localhost:3000&#x2F;查看结果</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/03/16/BNmsdbH4D3yvjqU.jpg" alt="express"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>Express</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(4)-模块及文件系统</title>
    <url>/post/3550571859.html</url>
    <content><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>模块是 Node.js 的基本组成部分，文件和模块一一对应，即一个 Node.js 文件就是一个模块。</p>
<blockquote>
<p><code>exports</code>：模块公开的接口，即封装模块的关键字</p>
</blockquote>
<blockquote>
<p><code>require</code>：从外部获取一个模块的接口，即调用模块的关键字</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;引入当前目录下的hello文件</span><br><span class="line">var hello &#x3D; require(&quot;.&#x2F;hello&quot;);</span><br><span class="line">&#x2F;&#x2F;使用exports将world作为模块访问的接口</span><br><span class="line">exports.world&#x3D;function()&#123;</span><br><span class="line">    console.log(&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <a id="more"></a>
<h3 id="require-调用模块机制"><a href="#require-调用模块机制" class="headerlink" title="require 调用模块机制"></a>require 调用模块机制</h3><p><img src="https://s1.ax1x.com/2020/03/16/8GZTTx.jpg" alt="require"></p>
<blockquote>
<p>其中，</p>
</blockquote>
<blockquote>
<p>原生模块：Node.js 自带的模块，如 http、fs 等。</p>
</blockquote>
<blockquote>
<p>文件模块：某目录下的文件，使用前必须先使用<code>exports</code>封装模块</p>
</blockquote>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br></pre></td></tr></table></figure>

<p>文件模块中所有方法均有异步同步两种，异步方法的最后一个参数为回掉函数，第一个参数包含了错误信息。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步读取</span><br><span class="line">fs.readFile(&#39;fs.txt&#39;, function (err, data) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;异步: &quot; + data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步读取</span><br><span class="line">var data &#x3D; fs.readFileSync(&#39;fs.txt&#39;);</span><br><span class="line">console.log(&quot;同步: &quot; + data.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;------END------&quot;);</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/03/16/8Gmoi6.jpg" alt="output"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(3)-回调与事件</title>
    <url>/post/407120575.html</url>
    <content><![CDATA[<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>回调是 Node.js 异步编程的直接体现。回调函数在完成任务后就会被调用。Node 的所有 API 都支持回调函数。回调函数是一种非阻塞的方式。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f1(value,callback1,callback2,...)&#123;&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="进程、线程"><a href="#进程、线程" class="headerlink" title="进程、线程"></a>进程、线程</h3><blockquote>
<p>进程：系统中正在运行的一个应用程序，是资源分配的最小单位。</p>
</blockquote>
<blockquote>
<p>线程：系统分配处理器时间资源的最小单位，程序执行的最小单位。</p>
</blockquote>
<h4 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h4><blockquote>
<p>1.进程包含一个或多个线程。</p>
</blockquote>
<blockquote>
<p>2.进程=线程+内存+文件/网络句柄</p>
</blockquote>
<blockquote>
<p>3.线程=栈+程序计数器+线程独立内存 TLS</p>
</blockquote>
<blockquote>
<p>4.一个程序至少有一个进程，一个进程至少有一个线程，其第一个线程即为此进程的主线程。</p>
</blockquote>
<blockquote>
<p>5.一个线程可以创建和撤销另一个线程，同一个进程的多个线程可以并发执行。</p>
</blockquote>
<h3 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h3><blockquote>
<p><strong>同步、异步关注应用层，阻塞、非阻塞更多针对进程和线程而谈</strong></p>
</blockquote>
<blockquote>
<p>同步：发送方发送请求之后，需要等接收方发回响应后才接着发。</p>
</blockquote>
<blockquote>
<p>异步：发送方发送请求后，不等待接收方响应请求，继续发送下个请求。</p>
</blockquote>
<blockquote>
<p>阻塞调用：调用结果返回之前，当前线程会被挂起，调用线程在获得结果后才会返回数据。</p>
</blockquote>
<blockquote>
<p>非阻塞调用：调用结果返回之前，当前线程也不会被挂起，而是立刻返回执行下一个调用。</p>
</blockquote>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>进程通信方面，同步、异步和阻塞、非阻塞基本是同义词，发送方阻塞/非阻塞与接收方阻塞/非阻塞互不影响。</p>
</li>
<li><p>I/O 系统调用层面，非阻塞 I/O 系统调用和异步 IO 系统调用都不会阻塞进程，但非阻塞 I/O 系统调用 read()立即返回的是可以立即拿到的数据，完整或不完整的结果或空值都可；而异步 I/O 系统调用 read()返回的结果必须是完整的。</p>
</li>
<li><p>非阻塞 I/O 系统调用可用来实现线程级别的 I/O 并发，与通过多线程实现的 I/O 并发相比，可减少内存消耗及进程切换的开销。</p>
</li>
</ol>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote>
<p>Node.js 是单进程单线程的应用程序，但通过 V8 引擎提供的异步执行回调接口，可以处理大量的并发。</p>
</blockquote>
<blockquote>
<p>Node.js 所有的事件机制，都通过观察者模式实现。其单线程类似进入一个<code>while(true)</code>的事件循环，知道没有事件观察者退出，每个异步事件都生成一个事件观察者，若有事件发生就调用该回调函数。</p>
</blockquote>
<blockquote>
<p>观察者模式：其定义了对象的一对多依赖，当一个对象改变，所有依赖它的观察者都会收到通知并自动更新。</p>
</blockquote>
<h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Node.js 使用事件驱动模型。当 web server 收到请求，就将他关闭放到任务队列中，然后服务下一个 web 请求，通过先进先出的原则，任务队列中的事件会被放到调用栈上进行处理（若为非阻塞 I/O 操作，则直接调用栈执行完毕，若为文件或其他数据库等需长时间的操作，则会被放入 Libuv 处理，当前任务挂起，处理下一个任务），当此请求处理完成，它会将结果重新放回任务队列，当到达队列开头，此处理结果被返回给用户（<strong>非阻塞 I/O</strong>或<strong>事件驱动 I/O</strong>）</p>
<p><a href="https://study.163.com/course/courseMain.htm?courseId=1209581854" target="_blank" rel="noopener">下图 Node.js 工作流程源自 easy 老师方糖全站课堂（超值！！买买买！！！）：</a></p>
<p><a href="https://imgchr.com/i/83rcH1" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/03/15/83rcH1.md.jpg" alt="node.js"></a></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li>事件驱动程序</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var events &#x3D; require(&quot;events&quot;);</span><br><span class="line">var eventEmitter &#x3D; new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">var connectHandler &#x3D; function connected() &#123;</span><br><span class="line">  console.log(&quot;Connect Success!!&quot;);</span><br><span class="line">  &#x2F;&#x2F;触发data_received事件</span><br><span class="line">  eventEmitter.emit(&quot;data_received&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;绑定事件处理</span><br><span class="line">eventEmitter.on(&quot;connection&quot;, connectHandler);</span><br><span class="line">&#x2F;&#x2F;绑定data_received事件</span><br><span class="line">eventEmitter.on(&quot;data_received&quot;, function() &#123;</span><br><span class="line">  console.log(&quot;data received success!!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;触发connection事件</span><br><span class="line">eventEmitter.emit(&quot;connection&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;------END------&quot;);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/83ryu9.jpg" alt="event"></p>
<ol start="2">
<li>文件读入</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&quot;fs.txt&quot;, (err, data) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    console.log(&quot;------ERROR------&quot;);</span><br><span class="line">    console.log(err.stack);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&quot;------DATA------&quot;);</span><br><span class="line">  console.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;------END------&quot;);</span><br></pre></td></tr></table></figure>

<p>运行成功：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/83rrjJ.jpg" alt="fs1"></p>
<p>运行失败：</p>
<p><img src="https://s1.ax1x.com/2020/03/15/83r6BR.jpg" alt="fs2"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(2)-REPL(交互式解释器)</title>
    <url>/post/2853246140.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>REPL 表示一个电脑环境类似 Windows 的 cmd 或 powershell 终端，Unix/Linux 的 shell。可进行一些读取、执行、打印、循环操作。</p>
</blockquote>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$node    &#x2F;&#x2F;进入node REPL</span><br><span class="line">&gt; 1+6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; x&#x3D;100</span><br><span class="line">100</span><br><span class="line"></span><br><span class="line">&gt; var y&#x3D;50</span><br><span class="line">undifined</span><br><span class="line"></span><br><span class="line">&gt; console.log(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<h3 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var x&#x3D;0;</span><br><span class="line">undefined</span><br><span class="line"></span><br><span class="line">&gt; while(x&lt;6)&#123;</span><br><span class="line">... x++;        &#x2F;&#x2F;...为换行，node会自动检测是否为连续的表达式</span><br><span class="line">... console.log(&quot;x:&quot;+x);</span><br><span class="line">...&#125;</span><br><span class="line">x:1</span><br><span class="line">x:2</span><br><span class="line">x:3</span><br><span class="line">x:4</span><br><span class="line">x:5</span><br><span class="line">x:6</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

<h3 id="下划线变量"><a href="#下划线变量" class="headerlink" title="下划线变量"></a>下划线变量</h3><blockquote>
<p>node 中下划线_可代表上一个表达式的结果。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; var x&#x3D;5;</span><br><span class="line">undefined</span><br><span class="line">&gt; var y&#x3D;10;</span><br><span class="line">undefined</span><br><span class="line">&gt; x+y</span><br><span class="line">15</span><br><span class="line">&gt; var sum&#x3D;_;</span><br><span class="line">undefined</span><br><span class="line">&gt; console.log(&quot;sum:&quot;+sum);</span><br><span class="line">sum:15</span><br></pre></td></tr></table></figure>

<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+c: 退出当前表达式</span><br><span class="line"></span><br><span class="line">ctrl+c(两次)&#x2F;ctrl+d：退出node REPL</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js(1)-创建应用</title>
    <url>/post/2478022751.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Node.js 为运行在服务端的 JavaScript。它是一个基于 Chrome JavaScript 运行时建立的平台，也是一个事件驱动 I/O 服务端的 JavaScript，基于 Google 的 V8 引擎。</p>
<a id="more"></a>

<p>Node.js 应用由以下部分组成：</p>
<ul>
<li><p>引入 required 模块：使用 require 指令载入 Node.js 模块</p>
</li>
<li><p>创建服务器：服务器监听客户端请求。</p>
</li>
<li><p>接收、响应请求</p>
</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="引入-required-模块"><a href="#引入-required-模块" class="headerlink" title="引入 required 模块"></a>引入 required 模块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const server &#x3D; http.createServer();&#x2F;&#x2F;创建服务器</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;给服务器绑定request事件，并使用匿名函数作为其回调函数</span><br><span class="line">server.on(&quot;request&quot;, (req, res) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(req.url); &#x2F;&#x2F;输出请求的url地址</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;通过normalize将URL规范成路径</span><br><span class="line">  &#x2F;&#x2F;通过join将他和当前目录拼接起来</span><br><span class="line">  &#x2F;&#x2F;__dirname代表当前文件所在目录</span><br><span class="line">  const doc_path &#x3D; path.join(</span><br><span class="line">    __dirname,</span><br><span class="line">    &quot;document_root&quot;,</span><br><span class="line">    path.normalize(req.url)</span><br><span class="line">  );</span><br><span class="line">  console.log(doc_path);</span><br><span class="line"></span><br><span class="line">  const ext &#x3D; path.extname(req.url); &#x2F;&#x2F;获取扩展名</span><br><span class="line">  let mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;;</span><br><span class="line">  switch (</span><br><span class="line">    ext &#x2F;&#x2F;指定对应的MIME信息</span><br><span class="line">  ) &#123;</span><br><span class="line">    case &quot;.html&quot;:</span><br><span class="line">    case &quot;.htm&quot;:</span><br><span class="line">      mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;text&#x2F;html&quot; &#125;;</span><br><span class="line">      break;</span><br><span class="line">    case &quot;.css&quot;:</span><br><span class="line">      mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;text&#x2F;css&quot; &#125;;</span><br><span class="line">      break;</span><br><span class="line">    case &quot;.ico&quot;:</span><br><span class="line">      mime &#x3D; &#123; &quot;Content-Type&quot;: &quot;image&#x2F;x-icon&quot; &#125;;</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;使用existSync判断文件是否存在</span><br><span class="line">  &#x2F;&#x2F;使用extname去掉url目录，以防路径为目录，但目录里没有文件</span><br><span class="line">  if (path.extname(req.url) !&#x3D; &quot;&quot; &amp;&amp; fs.existsSync(doc_path)) &#123;</span><br><span class="line">    &#x2F;&#x2F;Response里边会包含MIME信息以告诉浏览器这是个什么格式的文件</span><br><span class="line">    res.writeHead(200, mime); &#x2F;&#x2F;输出状态码</span><br><span class="line">    content &#x3D; fs.readFileSync(doc_path); &#x2F;&#x2F;通过readFileSync读取文件内容</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    res.writeHead(404, mime);</span><br><span class="line">    content &#x3D; &quot;文件不存在&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  res.write(content); &#x2F;&#x2F;将内容写到request响应里去</span><br><span class="line"></span><br><span class="line">  res.end();&#x2F;&#x2F;发送响应数据</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(8080);&#x2F;&#x2F;监听8080端口</span><br></pre></td></tr></table></figure>

<h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><p><img src="https://s2.ax1x.com/2020/03/08/3xIOiT.jpg" alt="测试结果"></p>
]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Node.js</tag>
        <tag>JavaScript</tag>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title>纯HTML/CSS/JS实现九宫格拼图游戏</title>
    <url>/post/1512225577.html</url>
    <content><![CDATA[<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><p><img src="https://i.loli.net/2020/02/21/MBsWOjbg8ED7wLd.gif" alt="showall.gif"></p>
<p>github地址：<a href="https://github.com/ChangeZ24/game-gridpuzzle" target="_blank" rel="noopener">https://github.com/ChangeZ24/game-gridpuzzle</a></p>
<p>在线试玩地址： <a href="http://awesolynn.me/game-gridpuzzle/gridpuzzle.html">http://awesolynn.me/game-gridpuzzle/gridpuzzle.html</a></p>
<a id="more"></a>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>整个九宫格看作一个 div，分为 9 份，位置号为 1~9</p>
</li>
<li><p>九宫格内 8 个活动格看作 8 个 div，格号为 1~8，第 9 格为空格，记为 0</p>
</li>
</ul>
<h3 id="乱序排列九宫格内-8-个活动格"><a href="#乱序排列九宫格内-8-个活动格" class="headerlink" title="乱序排列九宫格内 8 个活动格"></a>乱序排列九宫格内 8 个活动格</h3><blockquote>
<p>算法：</p>
</blockquote>
<blockquote>
<p>1、从第 9 格空格开始，选取随机位置号为 1~9 的某格进行两两替换</p>
</blockquote>
<blockquote>
<p>2、接下来，第 8 格，即格号为 8（初始后格号为 8 的格同在位置 8），则选取随机位置号为 1~8 的格进行两两替换</p>
</blockquote>
<blockquote>
<p>以此类推</p>
</blockquote>
<h3 id="活动格鼠标点击进行滑动"><a href="#活动格鼠标点击进行滑动" class="headerlink" title="活动格鼠标点击进行滑动"></a>活动格鼠标点击进行滑动</h3><blockquote>
<p>算法：</p>
</blockquote>
<blockquote>
<p>1、初始时，使用数组记录每个位置可移动的位置号，如位置 1，可移动到位置 2 和位置 4</p>
</blockquote>
<blockquote>
<p>2、使用数组记录每个位置格的左上角点的 x、y 值，在 css 中即为 left、top 值，即每个格从位置 1 移动到位置 2，改变的位移值。</p>
</blockquote>
<blockquote>
<p>3、当鼠标进行点击某格时，若其可移动的格内有空格，则其位移变为空格的 x、y 值，完成移动的动作。</p>
</blockquote>
<h3 id="时间记录"><a href="#时间记录" class="headerlink" title="时间记录"></a>时间记录</h3><blockquote>
<p>时间记录，同样使用<code>setInterval()</code>函数按 1000ms 的间隔进行实时计算。</p>
</blockquote>
<h3 id="关卡设置"><a href="#关卡设置" class="headerlink" title="关卡设置"></a>关卡设置</h3><blockquote>
<p>本游戏共设置 3 关，当每关成功完成拼图，会出现提示<code>play more</code>表示进入下一关</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/BYJ6b4WPpdKz8j9.gif" alt="next.gif"></p>
<blockquote>
<p>当位于最后一关时，成功后只会提示<code>congratulations</code>，表示游戏结束。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/eXKdZgihUxIpHzy.gif" alt="suss.gif"></p>
<h3 id="暂停、重玩机制"><a href="#暂停、重玩机制" class="headerlink" title="暂停、重玩机制"></a>暂停、重玩机制</h3><blockquote>
<p>当点击开始游戏后，开始游戏的按钮会自动变为暂停游戏</p>
</blockquote>
<blockquote>
<p>点击暂停游戏后，时间暂停，各活动格也无法点击，只有点击开始游戏继续玩或点击重新开始，重启此关</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/5gc2CEVIyBKTMpl.gif" alt="pause.gif"></p>
<blockquote>
<p>点击重新开始，会重新启动所在的关卡，重排整个图。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/21/1r2jPMApN3wGTgo.gif" alt="reset.gif"></p>
<h2 id="疑惑-学习点"><a href="#疑惑-学习点" class="headerlink" title="疑惑/学习点"></a>疑惑/学习点</h2><h3 id="对-CSS-中-position-的理解"><a href="#对-CSS-中-position-的理解" class="headerlink" title="对 CSS 中 position 的理解"></a>对 CSS 中 position 的理解</h3><h4 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h4><p>position：用于层的绝对定位，即让一个层位于一个层内具体什么位置</p>
<p>参数：</p>
<ul>
<li><p>static：默认。按页面文档流放置，忽略 top、bottom、left、right 设置的值</p>
</li>
<li><p>relative：相对位置。对象不可层叠，可通过 top、bottom、left、right 设置在文档流中的位置</p>
</li>
<li><p>absolute：绝对位置。对象可通过 z-index 设置层叠，对象被从文档流拖出，根据 top、bottom、left、right 等属性进行绝对定位。</p>
</li>
<li><p>fixed：固定位置。通过 top、bottom、left、right 进行定位，页面滚动，对象仍存在于固定的位置不变。</p>
</li>
</ul>
<h4 id="对相对、绝对位置的理解"><a href="#对相对、绝对位置的理解" class="headerlink" title="对相对、绝对位置的理解"></a>对相对、绝对位置的理解</h4><ol>
<li><p>当子级使用<code>position: absolute;</code>时。其父级通常定义为<code>position: relative;</code></p>
<p>父级使用<code>position: relative;</code>相对位置时，最好同时定义其<code>width</code>和<code>height</code>。</p>
<p>此时，子级使用<code>position: absolute;</code>，设置的<code>top/bottom、left/right</code>即为距离父级上/下侧、左/右侧的距离，有点类似外边距。</p>
<blockquote>
<p><strong>注意</strong>：此时<code>top/bottom</code>二选一，<code>left/right</code>二选一！</p>
</blockquote>
</li>
<li><p>当子级使用<code>position: absolute;</code>但父级没有设置<code>position: relative;</code>时，无论子级处于 div 哪一层，都会被拖出文档流，以 <code>body</code>为父级，所设置的所有 <code>top/bottom、left/right</code>都会为距离<code>body</code>的上/下侧、左/右侧的距离，不受其父级控制。</p>
</li>
</ol>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol>
<li><p>实验楼拼图实现教学</p>
<p><a href="https://www.shiyanlou.com/courses/161" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/161</a></p>
</li>
<li><p>CSS 中 position 相关讲解</p>
<p><a href="http://www.divcss5.com/rumen/r403.shtml" target="_blank" rel="noopener">http://www.divcss5.com/rumen/r403.shtml</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>Grid Puzzle</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo建站指南</title>
    <url>/post/1566052460.html</url>
    <content><![CDATA[<h2 id="下载安装必要工具"><a href="#下载安装必要工具" class="headerlink" title="下载安装必要工具"></a>下载安装必要工具</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><blockquote>
<p>搭建网站需要进行版本管理，故下载 git 进行使用。</p>
</blockquote>
<blockquote>
<p>下载网址： <a href="https://www.git-scm.com/download" target="_blank" rel="noopener">https://www.git-scm.com/download</a></p>
</blockquote>
<blockquote>
<p>使用说明可参考 git 官方文档：<a href="https://www.git-scm.com/doc" target="_blank" rel="noopener">https://www.git-scm.com/doc</a></p>
</blockquote>
<ul>
<li>安装时，一键 next 即可<a id="more"></a></li>
<li>安装后，在文件夹内或桌面点击鼠标右键，若出现如下工具，则证明安装成功:</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/iyzHFrNle78sTZn.jpg" alt="git.jpg"></p>
<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><blockquote>
<p>Hexo 是基于 Node.js 编写的，所以需要安装一下 Node.js 和里面的 npm 工具。</p>
</blockquote>
<blockquote>
<p>网址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a></p>
</blockquote>
<h4 id="安装后检查是否安装成功"><a href="#安装后检查是否安装成功" class="headerlink" title="安装后检查是否安装成功"></a>安装后检查是否安装成功</h4><ul>
<li><code>win+R</code> 打开运行，输入<code>cmd</code>：</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/rn3PRI9HsfzwM4h.jpg" alt="cmd.jpg"></p>
<ul>
<li>检查 node.js 和 npm 是否安装成功：</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/I2HDLrPgampFnke.jpg" alt="node.jpg"></p>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><blockquote>
<p>hexo 即为此次搭建网站的框架</p>
</blockquote>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li><p>创建一个文件夹，名字任取，作为以后网站所有文件的存储地，即本地仓库</p>
</li>
<li><p>进入文件夹，按住<code>shift</code>键点击鼠标右键，win10 选择“在此处打开 powershell 窗口”，win7 选择“在此处打开命令窗口”</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/xKdosqQEHlnMr4X.jpg" alt="powershell2.jpg"></p>
<ul>
<li><p>输入命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装结束，输入命令检查是否安装成功</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="初始化-hexo"><a href="#初始化-hexo" class="headerlink" title="初始化 hexo"></a>初始化 hexo</h4><ul>
<li><p>初始化 hexo 框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>初始化后一般在博客文件夹会出现以下文件：</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/K8XiTDvh4rexBp5.jpg" alt="folder.jpg"></p>
<ul>
<li><p>在文件夹内安装 npm 相关组件</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成页面</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地服务器打开查看页面</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
</li>
<li><p>若出现此页面，证明生成页面成功</p>
<p><img src="https://i.loli.net/2020/02/20/8fZiS1Wln3x4Ksj.jpg" alt="pagelocal.jpg"></p>
</li>
<li><p><code>ctrl+C</code>关掉本地</p>
</li>
</ul>
<h2 id="使用-Github-作为服务器部署-hexo-网站"><a href="#使用-Github-作为服务器部署-hexo-网站" class="headerlink" title="使用 Github 作为服务器部署 hexo 网站"></a>使用 Github 作为服务器部署 hexo 网站</h2><h3 id="配置-github"><a href="#配置-github" class="headerlink" title="配置 github"></a>配置 github</h3><ul>
<li><p>若没有 github 账号，则首先需要注册</p>
<p>网址：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
</li>
<li><p>新建仓库，点击页面右上角+，新建仓库 repository</p>
<p><img src="https://i.loli.net/2020/02/21/NVMhiTOzBWPGp9U.jpg" alt="repository.jpg"></p>
</li>
<li><p>填入信息，注意仓库名必须为：<strong>你的 github 用户名.github.io</strong></p>
<p>例如：ChangeZ24.github.io</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5P8P.jpg" alt="github"></p>
</li>
<li><p>在 blog 目录内点击鼠标右键，选择在此处打开 git Bash</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/sgNcERCUeFvb7VD.jpg" alt="gitbash.jpg"></p>
<ul>
<li><p>生成 SSH key</p>
<blockquote>
<p>SSH key 提供了一种与 GitHub 通信的方式，通过这种方式，能够在不输入密码的情况下，将 GitHub 作为自己的 remote 端服务器，进行版本控制</p>
</blockquote>
<p>输入命令生成 SSH key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;github用户名&quot;</span><br><span class="line">git config --global user.email &quot;github登陆邮箱&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以使用此命令检查是否输入正确</span><br><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 SSH key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;github登陆邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>创建完成后会在我的电脑 C 盘出现 id_rsa、id_rsa.pub 文件</p>
<p><img src="https://i.loli.net/2020/02/20/2Uu6ZaMjqlENSz4.jpg" alt="id.jpg"></p>
</li>
<li><p>打开 id_rsa.pub 文件，复制里面全部内容（即 key）</p>
</li>
<li><p>打开 github 导入 key</p>
<p><img src="https://i.loli.net/2020/02/21/84Wx7mUcVqRMB3Y.jpg" alt="setting.jpg"></p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5SUA.jpg" alt="3m5SUA.jpg"></p>
<p><img src="https://i.loli.net/2020/02/20/5RXFkjyDr2IH4e9.jpg" alt="createSSH.jpg"></p>
<p>新建时 SSHkey 的 title 可以随便填。</p>
</li>
<li><p>在 git Bash 中输入以下命令检查是否导入成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh git@github.com</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="将-hexo-部署到-github"><a href="#将-hexo-部署到-github" class="headerlink" title="将 hexo 部署到 github"></a>将 hexo 部署到 github</h3><ul>
<li><p>修改站点的配置文件_config.yml</p>
<blockquote>
<p><strong>注意</strong></p>
</blockquote>
<blockquote>
<p>存储在博客目录文件下的_config.yml 为<strong>站点的配置文件</strong></p>
</blockquote>
<blockquote>
<p>存储在博客目录的/theme/xxx(模板名)/_config.yml 为<strong>模板的配置文件</strong></p>
</blockquote>
<p>修改站点配置文件_config.yml 的 deploy 属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  # 此路径可直接在github仓库复制，如下图所示</span><br><span class="line">  repository:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;github用户名&#x2F;你的github用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>repository 路径可直接在仓库页面复制 http 路径：</p>
<p><img src="https://i.loli.net/2020/02/20/cQmOy5DBiz6eKbl.jpg" alt="githubhttp.jpg"></p>
</li>
<li><p>安装部署 git 的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>清理部署项目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成部署命令可一起使用</span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署成功即可在<code>http://github用户名.github.io</code>查看生成的页面</p>
<p><img src="https://i.loli.net/2020/02/20/8fZiS1Wln3x4Ksj.jpg" alt="pagelocal.jpg"></p>
</li>
</ul>
<h2 id="常用的-hexo-命令"><a href="#常用的-hexo-命令" class="headerlink" title="常用的 hexo 命令"></a>常用的 hexo 命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目缓存内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br><span class="line"></span><br><span class="line">hexo new page &quot;page名&quot; &#x2F;&#x2F;新建页面</span><br><span class="line">hexo new &quot;文章名&quot; &#x2F;&#x2F;新建文章</span><br></pre></td></tr></table></figure>

<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><ul>
<li>在 hexo 官网选择喜欢的模板</li>
</ul>
<p>网址：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p>
<ul>
<li>在 blog 目录下打开命令行或 git Bash 输入命令下载主题</li>
</ul>
<blockquote>
<p>主题下载命令一般在主题页面，或预览页面主题创作人的文章里都有</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Shen-Yu&#x2F;hexo-theme-ayer.git themes&#x2F;ayer</span><br></pre></td></tr></table></figure>

<ul>
<li>修改站点配置文件_config.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">theme: ayer  #在此处修改想要使用的主题名</span><br></pre></td></tr></table></figure>

<ul>
<li>重新生成部署页面即可看到新主题下的网页</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目缓存内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br></pre></td></tr></table></figure>

<h2 id="设置自己的个人域名"><a href="#设置自己的个人域名" class="headerlink" title="设置自己的个人域名"></a>设置自己的个人域名</h2><pre><code>目前生成的页面都是通过github提供的xxx.github.io访问，若想使用自己的个性化域名则需要以下步骤</code></pre><h3 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h3><blockquote>
<p>申请域名有很多网站，国内大多使用<a href="https://wanwang.aliyun.com/?spm=5176.8142029.digitalization.2.e9396d3e46JCc5" target="_blank" rel="noopener">阿里云</a>，不同的域名后缀价格不同，挑选自己喜欢可承受的即可。<br>国外域名可使用<a href="https://sg.godaddy.com/domains/domain-name-search" target="_blank" rel="noopener">godaddy</a>、<a href="https://www.namesilo.com/" target="_blank" rel="noopener">namesilo</a>等购买，国外域名一般不需要备案。</p>
</blockquote>
<h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><p>本人注册的域名时在 namesilo 购买，故以 namesilo 为例：</p>
<ul>
<li><p>登陆 namesilo 在自己的账户页面，点击 Account Domain 后的数字，进入域名管理页面</p>
<p><img src="https://i.loli.net/2020/02/20/ZDBEhn9WfrKbLvQ.jpg" alt="namesilo1.jpg"></p>
</li>
<li><p>选择 option 下的蓝色小人图标，进入解析界面</p>
<p><img src="https://i.loli.net/2020/02/20/p4fmEQvedOkT6MA.jpg" alt="domain.jpg"></p>
</li>
<li><p>将 namesoil 自动生成的所有记录删除，即 sevice 下所有未 parking 状态的记录，一般情况为 3 条 A 记录，1 条 CNAME 记录</p>
</li>
<li><p>添加自己的解析内容</p>
<ul>
<li><p>新建一个 A 记录</p>
<p><img src="https://i.loli.net/2020/02/20/lFyMoJXKYPnswN1.jpg" alt="a.jpg"></p>
</li>
<li><p>在系统 cmd 界面 ping github.io 的 ip</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5EDg.jpg" alt="3m5EDg.jpg"></p>
</li>
<li><p>在框内填写解析 ip</p>
<p><img src="https://i.loli.net/2020/02/20/ODTXBP4WRYyZcVK.jpg" alt="A2.jpg"></p>
</li>
<li><p>新建 CNAME 记录</p>
<p><img src="https://i.loli.net/2020/02/20/CP6BZFTMnqYycbh.jpg" alt="cname.jpg"></p>
</li>
<li><p>域名解析</p>
<blockquote>
<p>点击 SUBMIT 之后，回到域名管理界面，等待 status 状态变为 Active，则为解析成功，一般大概需要几分钟时间。</p>
</blockquote>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5p4I.jpg" alt="3m5p4I.jpg"></p>
</li>
</ul>
</li>
</ul>
<h3 id="在-github-关联域名"><a href="#在-github-关联域名" class="headerlink" title="在 github 关联域名"></a>在 github 关联域名</h3><ul>
<li><p>进入 github 博客仓库，选择 settings 进入项目设置</p>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5CCt.jpg" alt="3m5CCt.jpg"></p>
</li>
<li><p>在 Option 界面找到 git page 属性进行以下设置</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/02/20/D1tE3YZ8naOTmFS.jpg" alt="githubpage.jpg"></p>
<h3 id="在博客目录下的-source-文件夹新建-CNAME-文件，在文件内填写自己的域名"><a href="#在博客目录下的-source-文件夹新建-CNAME-文件，在文件内填写自己的域名" class="headerlink" title="在博客目录下的 source 文件夹新建 CNAME 文件，在文件内填写自己的域名"></a>在博客目录下的 source 文件夹新建 CNAME 文件，在文件内填写自己的域名</h3><blockquote>
<p>保存时，注意选择所有文件类型，文件名仅为 CNAME，无后缀</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/20/VxqNsOWwflFrESG.jpg" alt="cname2.jpg"></p>
<p><img src="https://i.loli.net/2020/02/20/3aSFl1etGmCx5kU.jpg" alt="cname1.jpg"></p>
<h3 id="重新部署生成页面"><a href="#重新部署生成页面" class="headerlink" title="重新部署生成页面"></a>重新部署生成页面</h3><ul>
<li>生成部署页面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清理项目缓存内容</span><br><span class="line">hexo g      &#x2F;&#x2F;生成页面</span><br><span class="line">hexo d      &#x2F;&#x2F;部署页面</span><br></pre></td></tr></table></figure>

<ul>
<li>在浏览器输入自己的域名即可看到生成的网页</li>
</ul>
<blockquote>
<p><strong>注意：记得清理浏览器缓存。</strong></p>
</blockquote>
<ul>
<li>使用<code>hexo new “文章名”</code>新建文章，在博客目录的 source/_posts/下找到“文章名.md”，即可使用 Markdown 编辑自己的文章了</li>
</ul>
<blockquote>
<p>写好后，注意使用<code>hexo g -d</code>重新生成，部署页面</p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>纯HTML/CSS/JS实现扫雷游戏</title>
    <url>/post/2192395528.html</url>
    <content><![CDATA[<h2 id="使用语言"><a href="#使用语言" class="headerlink" title="使用语言"></a>使用语言</h2><p>  该半个月在<a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web" target="_blank" rel="noopener">MDN Web Docs</a>网站学习网页开发，在学完 HTML、CSS、JavaScript 相关内容以后，决定用项目练练手。在<a href="https://www.shiyanlou.com/courses/?tag=%E5%85%A8%E9%83%A8&fee=all&sort=default&category=Web%20%E5%89%8D%E7%AB%AF&page=2" target="_blank" rel="noopener">实验楼 Web 开发</a>找到仅有的几个纯 HTML + CSS + JavaScript 项目作为练习。</p>
<p>  此项目即为纯Html + CSS + JavaScript的网页版扫雷游戏实现。</p>
<p>  github地址: <a href="https://github.com/ChangeZ24/game-minesweeper" target="_blank" rel="noopener">https://github.com/ChangeZ24/game-minesweeper</a></p>
<p>  在线试玩页面：<a href="http://awesolynn.me/game-minesweeper/">http://awesolynn.me/game-minesweeper/</a></p>
  <a id="more"></a>

<h2 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h3><p><img src="https://i.loli.net/2020/02/19/4y2JApmUso1Q6YH.jpg" alt="index.jpg"></p>
<h3 id="游戏页"><a href="#游戏页" class="headerlink" title="游戏页"></a>游戏页</h3><p><img src="https://s2.ax1x.com/2020/02/21/3m5eEj.gif" alt="3m5eEj.gif"></p>
<h2 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h2><h3 id="选择游戏难度"><a href="#选择游戏难度" class="headerlink" title="选择游戏难度"></a>选择游戏难度</h3><ol>
<li><p>游戏难度参照 win10 自带扫雷设置：</p>
<ul>
<li>初级 9*9 雷：10</li>
<li>中级 16*16 雷：40</li>
<li>高级 30*16 雷：99</li>
</ul>
</li>
<li><p>选择游戏难度后，点击开始游戏按钮跳转进入游戏页面。</p>
</li>
<li><p>游戏难度自带参数通过 url 传递</p>
</li>
</ol>
<h3 id="左键点击格子显示数字-雷"><a href="#左键点击格子显示数字-雷" class="headerlink" title="左键点击格子显示数字/雷"></a>左键点击格子显示数字/雷</h3><ol>
<li><p>为每个格子绑定 onmousedown 事件，通过其 event.button 值确定点击左键</p>
</li>
<li><p>初始化时，设定扫雷 mineSweeper 类，其中，地图格子以二维数组形式 landArrs 存在</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;由于扫雷每个格子中的内容为数字或雷。数字表示以其为中心的九宫格内雷的数量，故以九宫格中数字1~8表示，0为空格，9为雷</span><br><span class="line">landArrs[i][j]&#x3D;0;&#x2F;&#x2F;空格</span><br><span class="line">landArrs[i][j]&#x3D;1;&#x2F;&#x2F;数字1~8</span><br><span class="line">landArrs[i][j]&#x3D;9;&#x2F;&#x2F;雷</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>游戏开始前，按所选难度的雷数，将各雷随机放在地图内，再根据雷的位置计算雷周围数字的设置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1.初始化所有格子为0</span><br><span class="line">landArrs[i][j]&#x3D;0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2.按雷数随机放置雷位置</span><br><span class="line">&#x2F;&#x2F;随机数a-b：Math.floor(Math.random() * (max - min)) + min</span><br><span class="line">var randomNum &#x3D; Math.floor(Math.random() * (row * col - 0) + 0);</span><br><span class="line">var rNum &#x3D; parseInt(randomNum &#x2F; this.colCount);&#x2F;&#x2F;随机数所在的格子行数</span><br><span class="line">var cNum &#x3D; parseInt(randomNum % this.colCount);&#x2F;&#x2F;随机数所在的格子列数</span><br><span class="line">&#x2F;&#x2F;判断该位置是否已放置雷（省略）</span><br><span class="line">landArrs[rNum][cNum] &#x3D; 9;&#x2F;&#x2F;放置雷</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.按雷位置，计算其周边数字</span><br><span class="line">&#x2F;&#x2F;算法：遍历每个雷，将每个雷上下左右8格均+1</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>点中雷，游戏失败</li>
</ol>
<h3 id="右键点击插旗或取消旗子"><a href="#右键点击插旗或取消旗子" class="headerlink" title="右键点击插旗或取消旗子"></a>右键点击插旗或取消旗子</h3><ol>
<li><p>为每个格子绑定 onmousedown 事件，通过其 event.button 值确定点击右键</p>
</li>
<li><p>点击右键则将此格的 class 设置为 flag，按 CSS 样式放置旗子背景图—-&gt;插旗</p>
</li>
<li><p>再次点击右键则将已插旗的格子 class 设置为空字符串，取消 CSS 样式—-&gt;拔旗</p>
</li>
</ol>
<h3 id="点击格子为空值无数字时，自动连续展开其周边格子"><a href="#点击格子为空值无数字时，自动连续展开其周边格子" class="headerlink" title="点击格子为空值无数字时，自动连续展开其周边格子"></a>点击格子为空值无数字时，自动连续展开其周边格子</h3><blockquote>
<p>算法：</p>
<ol>
<li>点击格子值为 0，则以该格为中心查看其周围8个格</li>
<li>若其周围格为被打开过，则打开该格。</li>
<li>若其周围格再次遇到 0，自动循环查找</li>
</ol>
</blockquote>
<h3 id="花费时间即剩余雷数计算"><a href="#花费时间即剩余雷数计算" class="headerlink" title="花费时间即剩余雷数计算"></a>花费时间即剩余雷数计算</h3><ol>
<li><p>花费时间</p>
<blockquote>
<p>采用 JS 异步时间间隔 setInterval()算法，每 1s 更新一次时间<br>setInterval(displayTime, 1000);</p>
</blockquote>
</li>
<li><p>剩余雷数</p>
<blockquote>
<p>每标记一处，html 更新一次内容</p>
</blockquote>
</li>
</ol>
<h3 id="双击设定：满足已标记数与自身数字一致时自动打开格子"><a href="#双击设定：满足已标记数与自身数字一致时自动打开格子" class="headerlink" title="双击设定：满足已标记数与自身数字一致时自动打开格子"></a>双击设定：满足已标记数与自身数字一致时自动打开格子</h3><ol>
<li><p>双击已打开的数字格。</p>
<blockquote>
<p>当双击位置周围已标记雷数等于该位置数字时操作有效，相当于对该数字周围未打开的方块均进行一次左键单击操作。<br>地雷未标记完全时使用双击无效。</p>
</blockquote>
</li>
<li><p>若数字周围有标错的地雷，则游戏结束，标错的地雷上会显示一个“×”</p>
</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/21/3m5VbQ.gif" alt="3m5VbQ.gif"></p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><ol>
<li><p>实验楼扫雷实现教程</p>
<p><a href="https://www.shiyanlou.com/courses/144" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/144</a></p>
</li>
<li><p>MDN Web Docs</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>CSS</tag>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>MineSweeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Web学习(1)--网络基础</title>
    <url>/post/957423368.html</url>
    <content><![CDATA[<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>  Web开发与网络息息相关，故首先从打好网络基础入手：<br>  <a id="more"></a></p>
<p>  <img src="https://i.loli.net/2020/02/19/Q3fYNHwpL6XPcng.jpg" alt="internet.jpg"></p>
<h2 id="参考学习内容"><a href="#参考学习内容" class="headerlink" title="参考学习内容"></a>参考学习内容</h2><p>  MDN Web Docs</p>
<p>  <a href="https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Internet</tag>
      </tags>
  </entry>
</search>
